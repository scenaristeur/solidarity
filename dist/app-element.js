!function(n){var g={};function t(e){if(g[e])return g[e].exports;var I=g[e]={i:e,l:!1,exports:{}};return n[e].call(I.exports,I,I.exports,t),I.l=!0,I.exports}t.m=n,t.c=g,t.d=function(n,g,e){t.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:e})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,g){if(1&g&&(n=t(n)),8&g)return n;if(4&g&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(t.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&g&&"string"!=typeof n)for(var I in n)t.d(e,I,function(g){return n[g]}.bind(null,I));return e},t.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(g,"a",g),g},t.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},t.p="",t(t.s=3)}([function(module,exports){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _solid_auth_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n // Export a singleton instance of SolidAuthClient\n\nconst auth = new _solid_auth_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n/* harmony default export */ __webpack_exports__[\"default\"] = (auth); // Bind methods to instance, so they can be invoked as regular functions\n// (e.g., to pass around the fetch function)\n\nObject.getOwnPropertyNames(_solid_auth_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype).forEach(property => {\n  const value = auth[property];\n\n  if (typeof value === 'function') {\n    auth[property] = value.bind(auth);\n  }\n}); // Expose window.SolidAuthClient for backward compatibility\n\nif (typeof window !== 'undefined') {\n  if ('SolidAuthClient' in window) {\n    console.warn('Caution: multiple versions of solid-auth-client active.');\n  } else {\n    let warned = false;\n    Object.defineProperty(window, 'SolidAuthClient', {\n      enumerable: true,\n      get: () => {\n        if (!warned) {\n          warned = true;\n          console.warn('window.SolidAuthClient has been deprecated.');\n          console.warn('Please use window.solid.auth instead.');\n        }\n\n        return auth;\n      }\n    });\n  }\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SolidAuthClient; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _authn_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);\n/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* global fetch */\n\n\n\n\n\n\n // Store the global fetch, so the user is free to override it\n\nconst globalFetch = fetch;\nclass SolidAuthClient extends events__WEBPACK_IMPORTED_MODULE_1___default.a {\n  constructor() {\n    super(...arguments);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_pendingSession\", void 0);\n  }\n\n  fetch(input, options) {\n    this.emit('request', Object(_url_util__WEBPACK_IMPORTED_MODULE_6__[\"toUrlString\"])(input));\n    return Object(_authn_fetch__WEBPACK_IMPORTED_MODULE_2__[\"authnFetch\"])(Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])(), globalFetch, input, options);\n  }\n\n  login(idp, options) {\n    options = _objectSpread({}, defaultLoginOptions(Object(_url_util__WEBPACK_IMPORTED_MODULE_6__[\"currentUrlNoParams\"])()), {}, options);\n    return _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"login\"](idp, options);\n  }\n\n  async popupLogin(options) {\n    options = _objectSpread({}, defaultLoginOptions(), {}, options);\n\n    if (!/https?:/.test(options.popupUri)) {\n      options.popupUri = new URL(options.popupUri || '/.well-known/solid/login', window.location).toString();\n    }\n\n    if (!options.callbackUri) {\n      options.callbackUri = options.popupUri;\n    }\n\n    const popup = Object(_popup__WEBPACK_IMPORTED_MODULE_3__[\"openIdpPopup\"])(options.popupUri);\n    const session = await Object(_popup__WEBPACK_IMPORTED_MODULE_3__[\"obtainSession\"])(options.storage, popup, options);\n    this.emit('login', session);\n    this.emit('session', session);\n    return session;\n  }\n\n  async currentSession() {\n    let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])();\n    // Try to obtain a stored or pending session\n    let session = this._pendingSession || (await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"getSession\"])(storage)); // If none found, attempt to create a new session\n\n    if (!session) {\n      // Try to create a new OIDC session from stored tokens\n      try {\n        this._pendingSession = _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"currentSession\"](storage);\n        session = await this._pendingSession;\n      } catch (err) {\n        console.error(err);\n      } // Save the new session and emit session events\n\n\n      if (session) {\n        await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"saveSession\"])(storage)(session);\n        this.emit('login', session);\n        this.emit('session', session);\n      }\n\n      delete this._pendingSession;\n    }\n\n    return session;\n  }\n\n  async trackSession(callback) {\n    /* eslint-disable standard/no-callback-literal */\n    callback((await this.currentSession()));\n    this.on('session', callback);\n  }\n\n  stopTrackSession(callback) {\n    this.removeListener('session', callback);\n  }\n\n  async logout() {\n    let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])();\n    const session = await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"getSession\"])(storage);\n\n    if (session) {\n      try {\n        await _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"logout\"](storage, globalFetch);\n        this.emit('logout');\n        this.emit('session', null);\n      } catch (err) {\n        console.warn('Error logging out:');\n        console.error(err);\n      }\n\n      await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"clearSession\"])(storage);\n    }\n  }\n\n}\n\nfunction defaultLoginOptions(url) {\n  return {\n    callbackUri: url ? url.split('#')[0] : '',\n    popupUri: '',\n    storage: Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])()\n  };\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authnFetch\", function() { return authnFetch; });\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/* harmony import */ var _host__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);\n\n\n\n\n\nasync function authnFetch(storage, fetch, input, options) {\n  // If not authenticated, perform a regular fetch\n  const session = await Object(_session__WEBPACK_IMPORTED_MODULE_3__[\"getSession\"])(storage);\n\n  if (!session) {\n    return fetch(input, options);\n  } // If we know the server expects credentials, send them\n\n\n  if (await shouldShareCredentials(storage, input)) {\n    return Object(_webid_oidc__WEBPACK_IMPORTED_MODULE_4__[\"fetchWithCredentials\"])(session, fetch, input, options);\n  } // If we don't know for sure, try a regular fetch first\n\n\n  let resp = await fetch(input, options); // If the server then requests credentials, send them\n\n  if (resp.status === 401) {\n    await Object(_host__WEBPACK_IMPORTED_MODULE_2__[\"updateHostFromResponse\"])(storage)(resp);\n\n    if (await shouldShareCredentials(storage, input)) {\n      resp = Object(_webid_oidc__WEBPACK_IMPORTED_MODULE_4__[\"fetchWithCredentials\"])(session, fetch, input, options);\n    }\n  }\n\n  return resp;\n}\n\nasync function shouldShareCredentials(storage, input) {\n  const requestHost = await Object(_host__WEBPACK_IMPORTED_MODULE_2__[\"getHost\"])(storage)(Object(_url_util__WEBPACK_IMPORTED_MODULE_1__[\"toUrlString\"])(input));\n  return requestHost != null && requestHost.requiresAuth;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"fetch\"]; }());\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentUrl\", function() { return currentUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentUrlNoParams\", function() { return currentUrlNoParams; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"navigateTo\", function() { return navigateTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"originOf\", function() { return originOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toUrlString\", function() { return toUrlString; });\n/* eslint-env browser */\nfunction getLocation() {\n  return typeof window !== 'undefined' ? window.location : {\n    href: 'https://example.org/',\n    pathname: '/',\n    origin: 'example.org'\n  };\n}\n\nconst currentUrl = () => getLocation().href;\nconst currentUrlNoParams = () => getLocation().origin + getLocation().pathname;\nconst navigateTo = url => {\n  getLocation().href = url;\n};\nconst originOf = url => new URL(url).origin;\nconst toUrlString = url => {\n  if (typeof url !== 'string') {\n    url = 'url' in url ? url.url : url.toString();\n  }\n\n  return new URL(url, currentUrl()).toString();\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHost\", function() { return getHost; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveHost\", function() { return saveHost; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateHostFromResponse\", function() { return updateHostFromResponse; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* globalRequest, Response, URL */\n\n\n\nfunction getHost(storage) {\n  return async url => {\n    const {\n      host\n    } = new URL(url);\n    const session = await Object(_session__WEBPACK_IMPORTED_MODULE_1__[\"getSession\"])(storage);\n\n    if (session && host === new URL(session.idp).host) {\n      return {\n        url: host,\n        requiresAuth: true\n      };\n    }\n\n    const {\n      hosts\n    } = await Object(_storage__WEBPACK_IMPORTED_MODULE_2__[\"getData\"])(storage);\n    return hosts && hosts[host];\n  };\n}\nfunction saveHost(storage) {\n  return async (_ref) => {\n    let {\n      url,\n      requiresAuth\n    } = _ref;\n    await Object(_storage__WEBPACK_IMPORTED_MODULE_2__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n      hosts: _objectSpread({}, data.hosts, {\n        [url]: {\n          requiresAuth\n        }\n      })\n    }));\n  };\n}\nfunction updateHostFromResponse(storage) {\n  return async resp => {\n    if (_webid_oidc__WEBPACK_IMPORTED_MODULE_3__[\"requiresAuth\"](resp)) {\n      const {\n        host\n      } = new URL(resp.url);\n      await saveHost(storage)({\n        url: host,\n        requiresAuth: true\n      });\n    }\n  };\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSession\", function() { return getSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveSession\", function() { return saveSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearSession\", function() { return clearSession; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\nasync function getSession(storage) {\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"getData\"])(storage);\n  return data.session || null;\n}\nfunction saveSession(storage) {\n  return async session => {\n    const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n      session\n    }));\n    return data.session;\n  };\n}\nasync function clearSession(storage) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n    session: null\n  }));\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAMESPACE\", function() { return NAMESPACE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultStorage\", function() { return defaultStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getData\", function() { return getData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateStorage\", function() { return updateStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asyncStorage\", function() { return asyncStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memStorage\", function() { return memStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ipcStorage\", function() { return ipcStorage; });\n/* harmony import */ var _ipc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n\nconst NAMESPACE = 'solid-auth-client';\nconst defaultStorage = () => {\n  const hasLocalStorage = typeof window !== 'undefined' && 'localStorage' in window;\n  return asyncStorage(hasLocalStorage ? window.localStorage : memStorage());\n};\n/**\n * Gets the deserialized stored data\n */\n\nasync function getData(store) {\n  let serialized;\n  let data;\n\n  try {\n    serialized = await store.getItem(NAMESPACE);\n    data = JSON.parse(serialized || '{}');\n  } catch (e) {\n    console.warn('Could not deserialize data:', serialized);\n    console.error(e);\n    data = {};\n  }\n\n  return data;\n}\n/**\n * Updates a Storage object without mutating its intermediate representation.\n */\n\nasync function updateStorage(store, update) {\n  const currentData = await getData(store);\n  const newData = update(currentData);\n  await store.setItem(NAMESPACE, JSON.stringify(newData));\n  return newData;\n}\n/**\n * Takes a synchronous storage interface and wraps it with an async interface.\n */\n\nfunction asyncStorage(storage) {\n  return {\n    getItem: key => {\n      return Promise.resolve(storage.getItem(key));\n    },\n    setItem: (key, val) => {\n      return Promise.resolve(storage.setItem(key, val));\n    },\n    removeItem: key => {\n      return Promise.resolve(storage.removeItem(key));\n    }\n  };\n}\nconst memStorage = () => {\n  const store = {};\n  return {\n    getItem: key => {\n      if (typeof store[key] === 'undefined') return null;\n      return store[key];\n    },\n    setItem: (key, val) => {\n      store[key] = val;\n    },\n    removeItem: key => {\n      delete store[key];\n    }\n  };\n};\nfunction ipcStorage(client) {\n  return {\n    getItem: key => client.request('storage/getItem', key),\n    setItem: (key, val) => client.request('storage/setItem', key, val),\n    removeItem: key => client.request('storage/removeItem', key)\n  };\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Server\", function() { return Server; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Client\", function() { return Client; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/*\n  This module describes a simple IPC interface for communicating between browser windows.\n  window.postMessage() is the transport interface, and a request/response interface\n  is defined on top of it as follows:\n\n  const request = {\n    'solid-auth-client': {\n      id: 1234,\n      method: 'doSomethingPlease',\n      args: [ 'one', 'two', 'three' ]\n    }\n  }\n\n  const response = {\n    'solid-auth-client': {\n      id: 1234,\n      ret: 'the_value'\n    }\n  }\n*/\nconst NAMESPACE = 'solid-auth-client';\n/**\n * Receives and handles remote procedure calls.\n */\n\nclass Server {\n  constructor(clientWindow, clientOrigin, handle) {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_clientWindow\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_clientOrigin\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_handler\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_messageListener\", void 0);\n\n    this._clientWindow = clientWindow;\n    this._clientOrigin = clientOrigin;\n    this._handler = handle;\n\n    this._messageListener = event => this._handleMessage(event);\n  }\n\n  async _handleMessage(_ref) {\n    let {\n      data,\n      origin\n    } = _ref;\n\n    // Ensure we can post to the origin\n    if (origin !== this._clientOrigin) {\n      console.warn(\"solid-auth-client is listening to \".concat(this._clientOrigin, \" \") + \"so ignored a message received from \".concat(origin, \".\"));\n      return;\n    } // Parse the request and send it to the handler\n\n\n    const req = data && data[NAMESPACE];\n\n    if (req && req.method) {\n      const {\n        id,\n        method,\n        args\n      } = req;\n      const ret = await this._handler(method, ...args);\n\n      this._clientWindow.postMessage({\n        [NAMESPACE]: {\n          id,\n          ret\n        }\n      }, this._clientOrigin);\n    }\n  }\n\n  start() {\n    window.addEventListener('message', this._messageListener);\n  }\n\n  stop() {\n    window.removeEventListener('message', this._messageListener);\n  }\n\n}\n/**\n * Makes remote procedure calls.\n */\n\nclass Client {\n  constructor(serverWindow, serverOrigin) {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_serverWindow\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_serverOrigin\", void 0);\n\n    this._serverWindow = serverWindow;\n    this._serverOrigin = serverOrigin;\n  }\n\n  request(method) {\n    // Send the request as a message to the server window\n    const id = Math.random();\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    this._serverWindow.postMessage({\n      [NAMESPACE]: {\n        id,\n        method,\n        args\n      }\n    }, this._serverOrigin); // Create a promise that resolves to the request's return value\n\n\n    return new Promise((resolve, reject) => {\n      // Listen for responses to the request\n      window.addEventListener('message', responseListener); // Cancel if the response takes too long\n\n      const timeout = setTimeout(() => {\n        reject(new Error('Could not connect to main window.'));\n        window.removeEventListener('message', responseListener);\n      }, 2000); // Processes a possible response to the request\n\n      function responseListener(_ref2) {\n        let {\n          data\n        } = _ref2;\n        const resp = data && data[NAMESPACE];\n\n        if (resp && resp.id === id && resp.hasOwnProperty('ret')) {\n          resolve(resp.ret);\n          clearTimeout(timeout);\n          window.removeEventListener('message', responseListener);\n        }\n      }\n    });\n  }\n\n}\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"login\", function() { return login; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentSession\", function() { return currentSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logout\", function() { return logout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRegisteredRp\", function() { return getRegisteredRp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requiresAuth\", function() { return requiresAuth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetchWithCredentials\", function() { return fetchWithCredentials; });\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var auth_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);\n/* harmony import */ var auth_header__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(auth_header__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18);\n/* harmony import */ var _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(80);\n/* harmony import */ var _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* global Response */\n\n\n\n\n\nasync function login(idp, options) {\n  try {\n    const rp = await getRegisteredRp(idp, options);\n    await saveAppHashFragment(options.storage);\n    return sendAuthRequest(rp, options);\n  } catch (err) {\n    console.warn('Error logging in with WebID-OIDC');\n    console.error(err);\n    return null;\n  }\n}\nasync function currentSession() {\n  let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"defaultStorage\"])();\n\n  try {\n    // Obtain the Relying Party\n    const rp = await getStoredRp(storage);\n\n    if (!rp) {\n      return null;\n    } // Obtain and clear the OIDC URL fragment\n\n\n    const url = Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"currentUrl\"])();\n\n    if (!/#(.*&)?access_token=/.test(url)) {\n      return null;\n    }\n\n    window.location.hash = '';\n    await restoreAppHashFragment(storage); // Obtain a session from the Relying Party\n\n    const storeData = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n    const session = await rp.validateResponse(url, storeData);\n\n    if (!session) {\n      return null;\n    }\n\n    return _objectSpread({}, session, {\n      webId: session.idClaims.sub,\n      idp: session.issuer\n    });\n  } catch (err) {\n    console.warn('Error finding a WebID-OIDC session');\n    console.error(err);\n    return null;\n  }\n}\nasync function logout(storage, fetch) {\n  const rp = await getStoredRp(storage);\n\n  if (rp) {\n    try {\n      // First log out from the IDP\n      await rp.logout(); // Then, log out from the RP\n\n      try {\n        await fetch('/.well-known/solid/logout', {\n          credentials: 'include'\n        });\n      } catch (e) {// Ignore errors for when we are not on a Solid pod\n      }\n    } catch (err) {\n      console.warn('Error logging out of the WebID-OIDC session');\n      console.error(err);\n    }\n  }\n}\nasync function getRegisteredRp(idp, options) {\n  // To reuse a possible previous RP,\n  // it be for the same IDP and redirect URI\n  let rp = await getStoredRp(options.storage);\n\n  if (!rp || rp.provider.url !== idp || !rp.registration.redirect_uris.includes(options.callbackUri)) {\n    // Register a new RP\n    rp = await registerRp(idp, options);\n    await storeRp(options.storage, idp, rp);\n  }\n\n  return rp;\n}\n\nasync function getStoredRp(storage) {\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n  const {\n    rpConfig\n  } = data;\n\n  if (rpConfig) {\n    rpConfig.store = storage;\n    return _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default.a.from(rpConfig);\n  } else {\n    return null;\n  }\n}\n\nasync function storeRp(storage, idp, rp) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n    rpConfig: rp\n  }));\n  return rp;\n}\n\nfunction registerRp(idp, opts) {\n  const {\n    storage,\n    callbackUri\n  } = opts;\n  const responseType = 'id_token token';\n  const clientNameI18n = {};\n  Object.entries(opts).filter((_ref) => {\n    let [key, _] = _ref;\n    return key.startsWith('clientName#');\n  }).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    return clientNameI18n[key.replace('clientName#', 'client_name#')] = value;\n  });\n  const supplementaryOptions = {\n    logo_uri: opts.logoUri,\n    contacts: opts.contacts,\n    client_name: opts.clientName\n  };\n\n  const registration = _objectSpread({\n    issuer: idp,\n    grant_types: ['implicit'],\n    redirect_uris: [callbackUri],\n    response_types: [responseType],\n    scope: 'openid profile'\n  }, clientNameI18n, {}, supplementaryOptions);\n\n  const options = {\n    defaults: {\n      authenticate: {\n        redirect_uri: callbackUri,\n        response_type: responseType\n      }\n    },\n    store: storage\n  };\n  return _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default.a.register(idp, registration, options);\n}\n\nasync function sendAuthRequest(rp, _ref3) {\n  let {\n    callbackUri,\n    storage\n  } = _ref3;\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n  const url = await rp.createRequest({\n    redirect_uri: callbackUri\n  }, data);\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(storage, () => data);\n  return Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"navigateTo\"])(url);\n}\n\nasync function saveAppHashFragment(store) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(store, data => _objectSpread({}, data, {\n    appHashFragment: window.location.hash\n  }));\n}\n\nasync function restoreAppHashFragment(store) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(store, (_ref4) => {\n    let {\n      appHashFragment = ''\n    } = _ref4,\n        data = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_ref4, [\"appHashFragment\"]);\n\n    window.location.hash = appHashFragment;\n    return data;\n  });\n}\n/**\n * Answers whether a HTTP response requires WebID-OIDC authentication.\n */\n\n\nfunction requiresAuth(resp) {\n  if (resp.status !== 401) {\n    return false;\n  }\n\n  const wwwAuthHeader = resp.headers.get('www-authenticate');\n\n  if (!wwwAuthHeader) {\n    return false;\n  }\n\n  const auth = auth_header__WEBPACK_IMPORTED_MODULE_2__[\"parse\"](wwwAuthHeader);\n  return auth.scheme === 'Bearer' && auth.params && auth.params.scope === 'openid webid';\n}\n/**\n * Fetches a resource, providing the WebID-OIDC ID Token as authentication.\n * Assumes that the resource has requested those tokens in a previous response.\n */\n\nasync function fetchWithCredentials(session, fetch, input, options) {\n  // Create a copy of the headers\n  const headers = {};\n  const origHeaders = options ? options.headers : input.headers;\n\n  if (origHeaders) {\n    const entries = typeof origHeaders.entries === 'function' ? origHeaders.entries() : Object.entries(origHeaders);\n\n    for (const [name, value] of entries) {\n      headers[name] = value;\n    }\n  } // Add Authorization header\n\n\n  const popToken = await _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4___default.a.issueFor(Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"toUrlString\"])(input), session);\n  headers.authorization = \"Bearer \".concat(popToken);\n  return fetch(input, _objectSpread({}, options, {\n    credentials: 'include',\n    headers\n  }));\n}\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar objectWithoutPropertiesLoose = __webpack_require__(13);\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"format\", {\n  enumerable: true,\n  get: function get() {\n    return _format.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function get() {\n    return _parse.default;\n  }\n});\n\nvar _format = _interopRequireDefault(__webpack_require__(15));\n\nvar _parse = _interopRequireDefault(__webpack_require__(17));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = __webpack_require__(16);\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar xxx = function xxx(key) {\n  return function (value) {\n    return `${key}=${value && !(0, _util.isToken)(value) ? (0, _util.quote)(value) : value}`;\n  };\n};\n\nvar build = function build(params) {\n  return params.reduce(function (prev, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        values = _ref2[1];\n\n    var transform = xxx(key);\n\n    if (!(0, _util.isToken)(key)) {\n      throw new TypeError();\n    }\n\n    if (Array.isArray(values)) {\n      return _toConsumableArray(prev).concat(_toConsumableArray(values.map(transform)));\n    }\n\n    return _toConsumableArray(prev).concat([transform(values)]);\n  }, []);\n};\n\nvar challenge = function challenge(params, options) {\n  if (Array.isArray(params)) {\n    return build(params);\n  } else if (typeof params === 'object') {\n    var entries = params;\n    return challenge(Object.keys(params).map(function (key) {\n      return [key, entries[key]];\n    }), options);\n  }\n\n  throw new TypeError();\n};\n\nvar _default = function _default(scheme, token, params) {\n  var obj = typeof scheme === 'string' ? {\n    scheme,\n    token,\n    params\n  } : scheme;\n\n  if (typeof obj !== 'object') {\n    throw new TypeError();\n  } else if (!(0, _util.isScheme)(obj.scheme)) {\n    throw new TypeError('Invalid scheme.');\n  }\n\n  return [obj.scheme].concat(_toConsumableArray(typeof obj.token !== 'undefined' ? [obj.token] : []), _toConsumableArray(typeof obj.params !== 'undefined' ? challenge(obj.params) : [])).join(' ');\n};\n\nexports.default = _default;\n//# sourceMappingURL=format.js.map\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unquote = exports.quote = exports.isScheme = exports.isToken = void 0;\nvar token = /^[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+$/;\n\nvar isToken = function isToken(str) {\n  return typeof str === 'string' && token.test(str);\n};\n\nexports.isToken = isToken;\nvar isScheme = isToken;\nexports.isScheme = isScheme;\n\nvar quote = function quote(str) {\n  return `\"${str.replace(/\"/g, '\\\\\"')}\"`;\n};\n\nexports.quote = quote;\n\nvar unquote = function unquote(str) {\n  return str.substr(1, str.length - 2).replace(/\\\\\"/g, '\"');\n};\n\nexports.unquote = unquote;\n//# sourceMappingURL=util.js.map\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = __webpack_require__(16);\n\n// lol dis\nvar body = /((?:[a-zA-Z0-9._~+\\/-]+=*(?:\\s+|$))|[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+)(?:=([^\\\\\"=\\s,]+|\"(?:[^\"\\\\]|\\\\.)*\"))?/g; // eslint-disable-line\n\nvar normalize = function normalize(prev, _cur) {\n  // Fixup quoted strings and tokens with spaces around them\n  var cur = _cur.charAt(0) === '\"' ? (0, _util.unquote)(_cur) : _cur.trim(); // Marshal\n\n  if (Array.isArray(prev)) {\n    return prev.concat(cur);\n  } else if (typeof prev === 'string') {\n    return [prev, cur];\n  }\n\n  return cur;\n};\n\nvar parseProperties = function parseProperties(scheme, string) {\n  var token = null;\n  var params = {}; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    var res = body.exec(string);\n\n    if (res === null) {\n      break;\n    }\n\n    if (res[2]) {\n      params[res[1]] = normalize(params[res[1]], res[2]);\n    } else {\n      token = normalize(token, res[1]);\n    }\n  }\n\n  return {\n    scheme,\n    params,\n    token\n  };\n};\n\nvar _default = function _default(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Header value must be a string.');\n  }\n\n  var start = str.indexOf(' ');\n  var scheme = str.substr(0, start);\n\n  if (!(0, _util.isScheme)(scheme)) {\n    throw new TypeError(`Invalid scheme ${scheme}`);\n  }\n\n  return parseProperties(scheme, str.substr(start));\n};\n\nexports.default = _default;\n//# sourceMappingURL=parse.js.map\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(19);\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * Dependencies\n */\nconst assert = __webpack_require__(21);\n\nconst fetch = __webpack_require__(5);\n\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nconst {\n  JSONDocument\n} = __webpack_require__(28);\n\nconst {\n  JWKSet\n} = __webpack_require__(37);\n\nconst AuthenticationRequest = __webpack_require__(68);\n\nconst AuthenticationResponse = __webpack_require__(70);\n\nconst RelyingPartySchema = __webpack_require__(79);\n\nconst onHttpError = __webpack_require__(74);\n\nconst FormUrlEncoded = __webpack_require__(69);\n/**\n * RelyingParty\n *\n * @class\n * Client interface for OpenID Connect Relying Party.\n *\n * @example\n *  let client = RelyingParty({\n *    provider: {\n *      name: 'Anvil Research, Inc.',\n *      url: 'https://forge.anvil.io'\n *      // configuration\n *      // jwks\n *    },\n *    defaults: {\n *      popToken: false,\n *      authenticate: {\n *        response_type: 'code',\n *        display: 'popup',\n *        scope: 'openid profile email'\n *      },\n *      register: {\n *        client_name: 'Example',\n *        client_uri: 'https://example.com',\n *        logo_uri: 'https://example.com/assets/logo.png',\n *        redirect_uris: ['https://app.example.com/callback'],\n *        response_types: ['code', 'code id_token token'],\n *        grant_types: ['authorization_code'],\n *        default_max_age: 7200,\n *        post_logout_redirect_uris: ['https://app.example.com']\n *      },\n *    },\n *    registration: {\n *      // if you have it saved somewhere\n *    },\n *    store: localStorage || req.session\n *  })\n *\n *  client.discover() => Promise\n *  client.jwks() => Promise\n *  client.authenticate()\n *  client.authenticateUri()\n *  client.validateResponse(uri) => Promise\n *  client.userinfo() => Promise\n *  client.logout()\n */\n\n\nclass RelyingParty extends JSONDocument {\n  /**\n   * Schema\n   */\n  static get schema() {\n    return RelyingPartySchema;\n  }\n  /**\n   * from\n   *\n   * @description\n   * Create a RelyingParty instance from a previously registered client.\n   *\n   * @param {Object} data\n   * @returns {Promise<RelyingParty>}\n   */\n\n\n  static from(data) {\n    let rp = new RelyingParty(data);\n    let validation = rp.validate(); // schema validation\n\n    if (!validation.valid) {\n      return Promise.reject(new Error(JSON.stringify(validation)));\n    }\n\n    let jwks = rp.provider.jwks; // request the JWK Set if missing\n\n    if (!jwks) {\n      return rp.jwks().then(() => rp);\n    } // otherwise import the JWK Set to webcrypto\n\n\n    return JWKSet.importKeys(jwks).then(jwks => {\n      rp.provider.jwks = jwks;\n      return rp;\n    });\n  }\n  /**\n   * register\n   *\n   * @param issuer {string} Provider URL\n   * @param registration {Object} Client dynamic registration options\n   * @param options {Object}\n   * @param options.defaults\n   * @param [options.store] {Session|Storage}\n   * @returns {Promise<RelyingParty>} RelyingParty instance, registered.\n   */\n\n\n  static register(issuer, registration, options) {\n    let rp = new RelyingParty({\n      provider: {\n        url: issuer\n      },\n      defaults: Object.assign({}, options.defaults),\n      store: options.store\n    });\n    return Promise.resolve().then(() => rp.discover()).then(() => rp.jwks()).then(() => rp.register(registration)).then(() => rp);\n  }\n  /**\n   * Discover\n   *\n   * @description Fetches the issuer's OpenID Configuration.\n   * @returns {Promise<Object>} Resolves with the provider configuration response\n   */\n\n\n  discover() {\n    try {\n      let issuer = this.provider.url;\n      assert(issuer, 'RelyingParty provider must define \"url\"');\n      let url = new URL(issuer);\n      url.pathname = '.well-known/openid-configuration';\n      return fetch(url.toString()).then(onHttpError('Error fetching openid configuration')).then(response => {\n        return response.json().then(json => this.provider.configuration = json);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * Register\n   *\n   * @description Register's a client with provider as a Relying Party\n   *\n   * @param options {Object}\n   * @returns {Promise<Object>} Resolves with the registration response object\n   */\n\n\n  register(options) {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.registration_endpoint, 'OpenID Configuration is missing registration_endpoint.');\n      let uri = configuration.registration_endpoint;\n      let method = 'post';\n      let headers = new Headers({\n        'Content-Type': 'application/json'\n      });\n      let params = this.defaults.register;\n      let body = JSON.stringify(Object.assign({}, params, options));\n      return fetch(uri, {\n        method,\n        headers,\n        body\n      }).then(onHttpError('Error registering client')).then(response => {\n        return response.json().then(json => this.registration = json);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n\n  serialize() {\n    return JSON.stringify(this);\n  }\n  /**\n   * jwks\n   *\n   * @description Promises the issuer's JWK Set.\n   * @returns {Promise}\n   */\n\n\n  jwks() {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.jwks_uri, 'OpenID Configuration is missing jwks_uri.');\n      let uri = configuration.jwks_uri;\n      return fetch(uri).then(onHttpError('Error resolving provider keys')).then(response => {\n        return response.json().then(json => JWKSet.importKeys(json)).then(jwks => this.provider.jwks = jwks);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * createRequest\n   *\n   * @param options {Object} Authn request options hashmap\n   * @param options.redirect_uri {string}\n   * @param options.response_type {string} e.g. 'code' or 'id_token token'\n   * @param session {Session|Storage} req.session or localStorage\n   * @returns {Promise<string>} Authn request URL\n   */\n\n\n  createRequest(options, session) {\n    return AuthenticationRequest.create(this, options, session || this.store);\n  }\n  /**\n   * Validate Response\n   *\n   * @param response {string} req.query or req.body.text\n   * @param session {Session|Storage} req.session or localStorage or similar\n   *\n   * @returns {Promise<Session>}\n   */\n\n\n  validateResponse(response, session = this.store) {\n    let options;\n\n    if (response.match(/^http(s?):\\/\\//)) {\n      options = {\n        rp: this,\n        redirect: response,\n        session\n      };\n    } else {\n      options = {\n        rp: this,\n        body: response,\n        session\n      };\n    }\n\n    const authResponse = new AuthenticationResponse(options);\n    return AuthenticationResponse.validateResponse(authResponse);\n  }\n  /**\n   * userinfo\n   *\n   * @description Promises the authenticated user's claims.\n   * @returns {Promise}\n   */\n\n\n  userinfo() {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.userinfo_endpoint, 'OpenID Configuration is missing userinfo_endpoint.');\n      let uri = configuration.userinfo_endpoint;\n      let access_token = this.store.access_token;\n      assert(access_token, 'Missing access token.');\n      let headers = new Headers({\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${access_token}`\n      });\n      return fetch(uri, {\n        headers\n      }).then(onHttpError('Error fetching userinfo')).then(response => response.json());\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * logoutRequest\n   *\n   * Composes and returns the logout request URI, based on the OP's\n   * `end_session_endpoint`, with appropriate parameters.\n   *\n   * Note: Calling client code has the responsibility to clear the local\n   * session state (for example, by calling `rp.clearSession()`). In addition,\n   * some IdPs (such as Google) may not provide an `end_session_endpoint`,\n   * in which case, this method will return null.\n   *\n   * @see https://openid.net/specs/openid-connect-session-1_0.html#RPLogout\n   *\n   * @throws {Error} If provider config is not initialized\n   *\n   * @throws {Error} If `post_logout_redirect_uri` was provided without a\n   *   corresponding `id_token_hint`\n   *\n   * @param [options={}] {object}\n   *\n   * @param [options.id_token_hint] {string} RECOMMENDED.\n   *   Previously issued ID Token passed to the logout endpoint as\n   *   a hint about the End-User's current authenticated session with the\n   *   Client. This is used as an indication of the identity of the End-User\n   *   that the RP is requesting be logged out by the OP. The OP *need not* be\n   *   listed as an audience of the ID Token when it is used as an\n   *   `id_token_hint` value.\n   *\n   * @param [options.post_logout_redirect_uri] {string} OPTIONAL. URL to which\n   *   the RP is requesting that the End-User's User Agent be redirected after\n   *   a logout has been performed. The value MUST have been previously\n   *   registered with the OP, either using the `post_logout_redirect_uris`\n   *   Registration parameter or via another mechanism. If supplied, the OP\n   *   SHOULD honor this request following the logout.\n   *\n   *   Note: The requirement to validate the uri for previous registration means\n   *   that, in practice, the `id_token_hint` is REQUIRED if\n   *   `post_logout_redirect_uri` is used. Otherwise, the OP has no way to get\n   *   the `client_id` to load the saved client registration, to validate the\n   *   uri. The only way it can get it is by decoding the `id_token_hint`.\n   *\n   * @param [options.state] {string} OPTIONAL. Opaque value used by the RP to\n   *   maintain state between the logout request and the callback to the\n   *   endpoint specified by the `post_logout_redirect_uri` query parameter. If\n   *   included in the logout request, the OP passes this value back to the RP\n   *   using the `state` query parameter when redirecting the User Agent back to\n   *   the RP.\n   *\n   * TODO: In the future, consider adding `response_mode` param, for the OP to\n   *   determine how to return the `state` back the RP.\n   *   @see http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\n   *\n   * TODO: Handle special cases for popular providers (Google, MSFT)\n   *\n   * @returns {string|null} Logout uri (or null if no end_session_endpoint was\n   *   provided in the IdP config)\n   */\n\n\n  logoutRequest(options = {}) {\n    const {\n      id_token_hint,\n      post_logout_redirect_uri,\n      state\n    } = options;\n    let configuration;\n    assert(this.provider, 'OpenID Configuration is not initialized');\n    configuration = this.provider.configuration;\n    assert(configuration, 'OpenID Configuration is not initialized');\n\n    if (!configuration.end_session_endpoint) {\n      console.log(`OpenId Configuration for ` + `${configuration.issuer} is missing end_session_endpoint`);\n      return null;\n    }\n\n    if (post_logout_redirect_uri && !id_token_hint) {\n      throw new Error('id_token_hint is required when using post_logout_redirect_uri');\n    }\n\n    const params = {};\n\n    if (id_token_hint) {\n      params.id_token_hint = id_token_hint;\n    }\n\n    if (post_logout_redirect_uri) {\n      params.post_logout_redirect_uri = post_logout_redirect_uri;\n    }\n\n    if (state) {\n      params.state = state;\n    }\n\n    const url = new URL(configuration.end_session_endpoint);\n    url.search = FormUrlEncoded.encode(params);\n    return url.href;\n  }\n  /**\n   * Logout\n   *\n   * @deprecated\n   *\n   * TODO: Add deprecation warnings, then remove. Client code should\n   *   use `logoutRequest()` instead\n   *\n   * @returns {Promise}\n   */\n\n\n  logout() {\n    let configuration;\n\n    try {\n      assert(this.provider, 'OpenID Configuration is not initialized.');\n      configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.end_session_endpoint, 'OpenID Configuration is missing end_session_endpoint.');\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    if (!configuration.end_session_endpoint) {\n      this.clearSession();\n      return Promise.resolve(undefined);\n    }\n\n    let uri = configuration.end_session_endpoint;\n    let method = 'get';\n    return fetch(uri, {\n      method,\n      credentials: 'include'\n    }).then(onHttpError('Error logging out')).then(() => this.clearSession()); // TODO: Validate `frontchannel_logout_uri` if necessary\n\n    /**\n     * frontchannel_logout_uri - OPTIONAL. RP URL that will cause the RP to log\n     * itself out when rendered in an iframe by the OP.\n     *\n     * An `iss` (issuer) query parameter and a `sid`\n     * (session ID) query parameter MAY be included by the OP to enable the RP\n     * to validate the request and to determine which of the potentially\n     * multiple sessions is to be logged out. If a sid (session ID) query\n     * parameter is included, an iss (issuer) query parameter MUST also be\n     * included.\n     * @see https://openid.net/specs/openid-connect-frontchannel-1_0.html#RPLogout\n     */\n  }\n\n  clearSession() {\n    let session = this.store;\n\n    if (!session) {\n      return;\n    }\n\n    delete session[SESSION_PRIVATE_KEY];\n  }\n  /**\n   * @param uri {string} Target Resource Server URI\n   * @param idToken {IDToken} ID Token to be embedded in the PoP token\n   *\n   * @returns {Promise<PoPToken>}\n   */\n\n\n  popTokenFor(uri, idToken) {\n    return PoPToken.issueFor(uri, idToken);\n  }\n\n}\n\nconst SESSION_PRIVATE_KEY = 'oidc.session.privateKey';\nRelyingParty.SESSION_PRIVATE_KEY = SESSION_PRIVATE_KEY;\nmodule.exports = RelyingParty;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(22);\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(23);\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(25);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(26);\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)))\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"window\"]; }());\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  Formats: __webpack_require__(29),\n  Initializer: __webpack_require__(30),\n  JSONDocument: __webpack_require__(31),\n  JSONMapping: __webpack_require__(34),\n  JSONPatch: __webpack_require__(32),\n  JSONPointer: __webpack_require__(33),\n  JSONSchema: __webpack_require__(35),\n  Validator: __webpack_require__(36)\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * JSON Schema Formats\n *\n * TODO\n * Is there a good way to express these over multiple lines with comments\n * for easier debugging and auditing?\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\nvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\nvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\nvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\nvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\n/**\n * Formats\n */\n\nvar Formats = function () {\n  function Formats() {\n    _classCallCheck(this, Formats);\n  }\n\n  _createClass(Formats, [{\n    key: 'register',\n\n\n    /**\n     * Register\n     *\n     * @description\n     * Register a new mapping from named format to RegExp instance\n     *\n     * TODO\n     * We can do some extra validation of the RegExp to\n     * ensure it's the acceptable subset of RegExps allowed\n     * by JSON Schema.\n     *\n     * @param {string} name\n     * @param {RegExp} pattern\n     * @returns {RegExp}\n     */\n    value: function register(name, pattern) {\n      // verify name is a string\n      if (typeof name !== 'string') {\n        throw new Error('Format name must be a string');\n      }\n\n      // cast a string to RegExp\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n      }\n\n      return this[name] = pattern;\n    }\n\n    /**\n     * Resolve\n     *\n     * @description\n     * Given a format name, return the corresponding registered validation. In the\n     * event a format is not registered, throw an error.\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(name) {\n      var format = this[name];\n\n      if (!format) {\n        throw new Error('Unknown JSON Schema format.');\n      }\n\n      return format;\n    }\n\n    /**\n     * Test\n     *\n     * @description\n     * Test that a value conforms to a format.\n     *\n     * @param {string} name\n     * @param {string} value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(name, value) {\n      var format = this.resolve(name);\n      return format.test(value);\n    }\n  }], [{\n    key: 'initialize',\n\n\n    /**\n     * Initialize\n     *\n     * @description\n     * Create a new Formats instance and register default formats\n     *\n     * @returns {Formats}\n     */\n    value: function initialize() {\n      var formats = new Formats();\n      formats.register('date-time', DATETIME_REGEXP);\n      formats.register('uri', URI_REGEXP);\n      formats.register('email', EMAIL_REGEXP);\n      formats.register('ipv4', IPV4_REGEXP);\n      formats.register('ipv6', IPV6_REGEXP);\n      formats.register('hostname', HOSTNAME_REGEXP);\n      return formats;\n    }\n  }]);\n\n  return Formats;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Formats.initialize();\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Initializer\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = function () {\n\n  /**\n   * constructor\n   */\n  function Initializer(schema, options) {\n    _classCallCheck(this, Initializer);\n\n    Object.assign(this, options || {});\n    this.root = this.root || this;\n\n    this.root.depth = this.root.depth || 1;\n\n    if (this.level > this.root.depth) {\n      this.root.depth = this.level;\n    }\n\n    this.level = this.level || 0;\n    this.schema = schema;\n  }\n\n  /**\n   * compile (static)\n   */\n\n\n  _createClass(Initializer, [{\n    key: 'compile',\n\n\n    /**\n     * compile\n     */\n    value: function compile() {\n      var root = this.root,\n          depth = this.depth,\n          level = this.level;\n\n      var declarations = '';\n      var body = '';\n\n      // traverse the schema and generate code\n      body += this.default();\n      body += this.properties();\n      //body += this.additionalProperties()\n      body += this.items();\n      //body += this.additionalItems()\n\n\n      // value\n      body += this.member();\n      body += this.item();\n\n      // after traversing the schema\n      // generate the variable declarations\n      if (root === this) {\n        for (var i = 1; i <= this.root.depth; i++) {\n          declarations += this.declaration(i);\n        }\n\n        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n      }\n\n      return body;\n    }\n\n    /**\n     * declaration\n     */\n\n  }, {\n    key: 'declaration',\n    value: function declaration(level) {\n      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n    }\n\n    /**\n     * default\n     */\n\n  }, {\n    key: 'default',\n    value: function _default() {\n      var schema = this.schema,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\n      var block = '';\n\n      if (schema.hasOwnProperty('default')) {\n\n        if (key) {\n          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (index) {\n          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * member\n     */\n\n  }, {\n    key: 'member',\n    value: function member() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      // `key` tells us to treat this subschema as an object member vs an array item\n      // and the absence of the other values here indicates we are dealing with a\n      // primitive value\n      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\n        // first generate the assignment statement\n        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\n        // for nested container objects, add the counter incrementing statement\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        // wrap the foregoing in a check for presence on the source\n        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * item\n     */\n\n  }, {\n    key: 'item',\n    value: function item() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          index = this.index;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\n        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var properties = schema.properties;\n\n      var block = '';\n\n      if (properties) {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\n          block += initializer.compile();\n        });\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n\n          if (index) {\n            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n          }\n\n          if (key) {\n            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n          }\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {}\n\n    /**\n     * items\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var items = schema.items;\n\n      var block = '';\n\n      if (items) {\n\n        if (Array.isArray(items)) {\n          // TODO\n          //\n          //\n          //\n          //\n          //\n          // ...\n\n        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n          var _index = 'i' + (level + 1);\n          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\n          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n        }\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {}\n  }], [{\n    key: 'compile',\n    value: function compile(schema) {\n      var initializer = new Initializer(schema);\n      var block = initializer.compile();\n\n      //console.log(beautify(block))\n      try {\n        return new Function('target', 'source', 'options', block);\n      } catch (e) {\n        console.log(e, e.stack);\n      }\n    }\n  }]);\n\n  return Initializer;\n}();\n\nmodule.exports = Initializer;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPatch = __webpack_require__(32);\n\n/**\n * JSONDocument\n *\n * @class\n * JSONDocument is a high level interface that binds together all other features of\n * this package and provides the principle method of data modeling.\n */\n\nvar JSONDocument = function () {\n  _createClass(JSONDocument, null, [{\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      throw new Error('Schema must be defined by classes extending JSONDocument');\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} data\n     * @param {Object} options\n     */\n\n  }]);\n\n  function JSONDocument() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSONDocument);\n\n    this.initialize(data, options);\n  }\n\n  /**\n   * Initialize\n   *\n   * @param {Object} data\n   * @param {Object} options\n   */\n\n\n  _createClass(JSONDocument, [{\n    key: 'initialize',\n    value: function initialize() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = this.constructor.schema;\n\n      schema.initialize(this, data, options);\n    }\n\n    /**\n     * Validate\n     *\n     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(alternate) {\n      var schema = this.constructor.schema;\n\n      return (alternate || schema).validate(this);\n    }\n\n    /**\n     * Patch\n     *\n     * @param {Array} ops\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(ops) {\n      var patch = new JSONPatch(ops);\n      patch.apply(this);\n    }\n\n    /**\n     * Select\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {}\n\n    /**\n     * Project\n     *\n     * @description\n     * Given a mapping, return an object projected from the current instance.\n     *\n     * @example\n     * let schema = new JSONSchema({\n     *   properties: {\n     *     foo: { type: 'Array' }\n     *   }\n     * })\n     *\n     * let mapping = new JSONMapping({\n     *   '/foo/0': '/bar/baz'\n     * })\n     *\n     * class FooTracker extends JSONDocument {\n     *   static get schema () { return schema }\n     * }\n     *\n     * let instance = new FooTracker({ foo: ['qux'] })\n     * instance.project(mapping)\n     * // => { bar: { baz: 'qux' } }\n     *\n     * @param {JSONMapping} mapping\n     * @return {Object}\n     */\n\n  }, {\n    key: 'project',\n    value: function project(mapping) {\n      return mapping.project(this);\n    }\n\n    /**\n     * Serialize\n     *\n     * @param {Object} object\n     * @returns {string}\n     */\n\n  }], [{\n    key: 'serialize',\n    value: function serialize(object) {\n      return JSON.stringify(object);\n    }\n\n    /**\n     * Deserialize\n     *\n     * @param {string} data\n     * @return {*}\n     */\n\n  }, {\n    key: 'deserialize',\n    value: function deserialize(data) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        throw new Error('Failed to parse JSON');\n      }\n    }\n  }]);\n\n  return JSONDocument;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONDocument;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = __webpack_require__(33);\n\n/**\n * Modes\n */\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * Operations list\n */\nvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\n/**\n * Patch\n *\n * @class\n * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n * https://tools.ietf.org/html/rfc6902\n */\n\nvar JSONPatch = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Array} ops\n   */\n  function JSONPatch(ops) {\n    _classCallCheck(this, JSONPatch);\n\n    this.ops = ops || [];\n  }\n\n  /**\n   * Apply\n   *\n   * @todo handle errors/roll back\n   * @todo protect properties that are private in the schema\n   * @todo map JSON Pointers real property names\n   *\n   * @param {Object} target\n   */\n\n\n  _createClass(JSONPatch, [{\n    key: 'apply',\n    value: function apply(target) {\n      var _this = this;\n\n      this.ops.forEach(function (operation) {\n        var op = operation.op;\n\n        if (!op) {\n          throw new Error('Missing \"op\" in JSON Patch operation');\n        }\n\n        if (OPERATIONS.indexOf(op) === -1) {\n          throw new Error('Invalid \"op\" in JSON Patch operation');\n        }\n\n        if (!operation.path) {\n          throw new Error('Missing \"path\" in JSON Patch operation');\n        }\n\n        _this[op](operation, target);\n      });\n    }\n\n    /**\n     * Add\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'add',\n    value: function add(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch add operation');\n      }\n\n      var pointer = new JSONPointer(op.path, SILENT);\n      pointer.add(target, op.value);\n    }\n\n    /**\n     * Remove\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(op, target) {\n      var pointer = new JSONPointer(op.path);\n      pointer.remove(target);\n    }\n\n    /**\n     * Replace\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch replace operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      pointer.replace(target, op.value);\n    }\n\n    /**\n     * Move\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'move',\n    value: function move(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch move operation');\n      }\n\n      if (op.path.match(new RegExp('^' + op.from))) {\n        throw new Error('Invalid \"from\" in JSON Patch move operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      from.remove(target);\n      pointer.add(target, value);\n    }\n\n    /**\n     * Copy\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch copy operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      pointer.add(target, value);\n    }\n\n    /**\n     * Test\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'test',\n    value: function test(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch test operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var value = pointer.get(target);\n\n      switch (_typeof(op.value)) {\n        //case 'string':\n        //case 'number':\n        //case 'boolean':\n        //  if (value !== op.value) {\n        //    throw new Error('Mismatching JSON Patch test value')\n        //  }\n        default:\n          if (value !== op.value) {\n            throw new Error('Mismatching JSON Patch test value');\n          }\n      }\n    }\n  }]);\n\n  return JSONPatch;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPatch;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n\n  /**\n   * Escape\n   */\n\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n\n      return '#/' + value;\n    }\n\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      // iterate through the tokens\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        // set the property on the target location\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          }\n\n          // handle missing target location based on \"mode\"\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          }\n\n          // reference the next object in the path\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      }\n\n      // delete from the target\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPointer;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = __webpack_require__(33);\n\n/**\n * JSONPointer mode\n */\nvar RECOVER = 1;\n\n/**\n * JSONMapping\n *\n * @class\n * Defines a means to declaratively translate between object\n * representations using JSON Pointer syntax.\n */\n\nvar JSONMapping = function () {\n\n  /**\n   * Constructor\n   *\n   * @description Translate pointers from JSON Strings into Pointer objects\n   * @param {Object} mapping\n   */\n  function JSONMapping(mapping) {\n    var _this = this;\n\n    _classCallCheck(this, JSONMapping);\n\n    Object.defineProperty(this, 'mapping', {\n      enumerable: false,\n      value: new Map()\n    });\n\n    Object.keys(mapping).forEach(function (key) {\n      var value = mapping[key];\n      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n    });\n  }\n\n  /**\n   * Map\n   *\n   * @description Assign values from source to target by reading the mapping\n   * from right to left.\n   * @param {Object} target\n   * @param {Object} source\n   */\n\n\n  _createClass(JSONMapping, [{\n    key: 'map',\n    value: function map(target, source) {\n      this.mapping.forEach(function (right, left) {\n        left.add(target, right.get(source));\n      });\n    }\n\n    /**\n     * Project\n     *\n     * @description Assign values from source to target by reading the mapping\n     * from left to right.\n     * @param {Object} source\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'project',\n    value: function project(source, target) {\n      this.mapping.forEach(function (right, left) {\n        right.add(target, left.get(source));\n      });\n    }\n  }]);\n\n  return JSONMapping;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONMapping;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = __webpack_require__(30);\nvar Validator = __webpack_require__(36);\n\n/**\n * JSONSchema\n *\n * @class\n * Compiles JSON Schema documents to an object with object initialization\n * and validation methods.\n */\n\nvar JSONSchema = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Object} schema\n   */\n  function JSONSchema(schema) {\n    _classCallCheck(this, JSONSchema);\n\n    // TODO: optionally parse JSON string?\n    Object.assign(this, schema);\n\n    // add schema-derived initialize and validate methods\n    Object.defineProperties(this, {\n      initialize: {\n        enumerable: false,\n        writeable: false,\n        value: Initializer.compile(schema)\n      },\n      validate: {\n        enumerable: false,\n        writeable: false,\n        value: Validator.compile(schema)\n      }\n    });\n  }\n\n  /**\n   * Extend\n   *\n   * @description\n   * ...\n   * Dear future,\n   *\n   * This function was meticulously plagiarized from some curious amalgam of\n   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n   *\n   * Goodnight.\n   *\n   * @param {Object} schema\n   * @returns {JSONSchema}\n   */\n\n\n  _createClass(JSONSchema, [{\n    key: 'extend',\n    value: function extend(schema) {\n      function isObject(data) {\n        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n      }\n\n      function extender(target, source) {\n        var result = Object.assign({}, target);\n        if (isObject(target) && isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(result, _defineProperty({}, key, source[key]));\n              } else {\n                result[key] = extender(target[key], source[key]);\n              }\n            } else {\n              Object.assign(result, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n        return result;\n      }\n\n      var descriptor = extender(this, schema);\n      return new JSONSchema(descriptor);\n    }\n  }]);\n\n  return JSONSchema;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONSchema;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar formats = __webpack_require__(29);\n\n/**\n * For variable iterator counter\n *\n * @type {number}\n */\nvar indexCount = 0;\n\n/**\n * Validator\n *\n * Compile an object describing a JSON Schema into a validation function.\n */\n\nvar Validator = function () {\n  _createClass(Validator, null, [{\n    key: 'compile',\n\n\n    /**\n     * Compile (static)\n     *\n     * @description\n     * Compile an object describing a JSON Schema into a validation function.\n     *\n     * @param {Object} schema\n     * @returns {Function}\n     */\n    value: function compile(schema) {\n      var validator = new Validator(schema);\n\n      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\n      return new Function('data', body);\n    }\n\n    /**\n     * Return current iterator index counter and increase value\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'counter',\n    get: function get() {\n      return indexCount++;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} schema - object representation of a schema\n     * @param {string} options - compilation options\n     */\n\n  }]);\n\n  function Validator(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Validator);\n\n    // assign schema to this\n    this.schema = schema;\n\n    // assign all options to this\n    Object.assign(this, options);\n\n    // ensure address is defined\n    if (!this.address) {\n      this.address = '';\n    }\n\n    // ensure require is boolean\n    if (this.require !== true) {\n      this.require = false;\n    }\n  }\n\n  /**\n   * Compile\n   *\n   * @description\n   * The instance compile method is \"dumb\". It only sequences invocation of\n   * more specific compilation methods. It generates code to\n   *\n   *  - read a value from input\n   *  - validate type(s) of input\n   *  - validate constraints described by various schema keywords\n   *\n   * Conditional logic related to code generation is pushed downsteam to\n   * type-specific methods.\n   */\n\n\n  _createClass(Validator, [{\n    key: 'compile',\n    value: function compile() {\n      var block = '';\n\n      if (this.require) {\n        block += this.required();\n      }\n\n      // type validation\n      block += this.type();\n\n      // type specific validation generators\n      // null and boolean are covered by this.type()\n      // integer should be covered by number and this.type()\n      block += this.array();\n      block += this.number();\n      block += this.object();\n      block += this.string();\n\n      // non-type-specific validation generators\n      block += this.enum();\n      block += this.anyOf();\n      block += this.allOf();\n      block += this.not();\n      block += this.oneOf();\n\n      return block;\n    }\n\n    /**\n     * push\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n    }\n\n    /**\n     * pop\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n    }\n\n    /**\n     * type\n     *\n     * @description\n     * > An instance matches successfully if its primitive type is one of the\n     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n     * > JSON Schema Validation Section 5.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'type',\n    value: function type() {\n      var type = this.schema.type,\n          address = this.address;\n\n      var block = '';\n\n      if (type) {\n        var types = Array.isArray(type) ? type : [type];\n        var conditions = types.map(function (type) {\n          // TODO: can we make a mapping object for this to clean it up?\n          if (type === 'array') return '!Array.isArray(value)';\n          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n          if (type === 'integer') return '!Number.isInteger(value)';\n          if (type === 'null') return 'value !== null';\n          if (type === 'number') return 'typeof value !== \\'number\\'';\n          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n          if (type === 'string') return 'typeof value !== \\'string\\'';\n        }).join(' && ');\n\n        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Type-specific validations\n     *\n     * Type checking is optional in JSON Schema, and a schema can allow\n     * multiple types. Generated code needs to apply type-specific validations\n     * only to appropriate values, and ignore everything else. Type validation\n     * itself is handled separately from other validation keywords.\n     *\n     * The methods `array`, `number`, `object`, `string` generate type-specific\n     * validation code blocks, wrapped in a conditional such that they will\n     * only be applied to values of that type.\n     *\n     * For example, the `number` method, given the schema\n     *\n     *     { minimum: 3 }\n     *\n     * will generate\n     *\n     *     if (typeof value === 'number') {\n     *       if (value < 3) {\n     *         valid = false\n     *         errors.push({ message: '...' })\n     *       }\n     *     }\n     *\n     * Integer values are also numbers, and are validated the same as numbers\n     * other than the type validation itself. Therefore no `integer` method is\n     * needed.\n     */\n\n    /**\n     * array\n     *\n     * @description\n     * Invoke methods for array-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to array values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'array',\n    value: function array() {\n      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * number\n     *\n     * @description\n     * Invoke methods for number-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to number values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'number',\n    value: function number() {\n      var keywords = ['minimum', 'maximum', 'multipleOf'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * object\n     *\n     * @description\n     * Invoke methods for object-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to object values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'object',\n    value: function object() {\n      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * string\n     *\n     * @description\n     * Invoke methods for string-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to string values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * validations\n     *\n     * @description\n     * Iterate over an array of keywords and invoke code generator methods\n     * for each. Concatenate the results together and return. Used by \"type\"\n     * methods such as this.array() and this.string()\n     *\n     * @param {Array} keywords\n     * @returns {string}\n     */\n\n  }, {\n    key: 'validations',\n    value: function validations(keywords) {\n      var _this = this;\n\n      var schema = this.schema;\n\n      var block = '';\n\n      var constraints = Object.keys(schema).filter(function (key) {\n        return keywords.indexOf(key) !== -1;\n      });\n\n      constraints.forEach(function (keyword) {\n        block += _this[keyword]();\n      });\n\n      return block;\n    }\n\n    /**\n     * enum\n     *\n     * @description\n     * > An instance validates successfully against this keyword if its value\n     * > is equal to one of the elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.5.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'enum',\n    value: function _enum() {\n      var enumerated = this.schema.enum,\n          address = this.address;\n\n      var conditions = ['value !== undefined'];\n      var block = '';\n\n      if (enumerated) {\n        enumerated.forEach(function (value) {\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'number':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'string':\n              conditions.push('value !== \"' + value + '\"');\n              break;\n\n            case 'object':\n              if (value === null) {\n                conditions.push('value !== null');\n              } else {\n                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n              }\n              break;\n\n            default:\n              throw new Error('Things are not well in the land of enum');\n\n          }\n        });\n\n        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * anyOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against at least one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.4\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'anyOf',\n    value: function anyOf() {\n      var anyOf = this.schema.anyOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(anyOf)) {\n        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\n        anyOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n        });\n\n        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * allOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against all schemas defined by this keyword's\n     * > value.\n     * > JSON Schema Validation Section 5.5.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'allOf',\n    value: function allOf() {\n      var allOf = this.schema.allOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(allOf)) {\n        allOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        ' + validator.compile() + '\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * oneOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against exactly one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.5\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      var oneOf = this.schema.oneOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(oneOf)) {\n        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\n        oneOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n        });\n\n        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * not\n     *\n     * @description\n     * > An instance is valid against this keyword if it fails to validate\n     * > successfully against the schema defined by this keyword.\n     * > JSON Schema Validation Section 5.5.6\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'not',\n    value: function not() {\n      var not = this.schema.not,\n          address = this.address;\n\n      var block = '';\n\n      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n        var subschema = not;\n        var validator = new Validator(subschema, { address: address });\n\n        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     *\n     * @description\n     * Iterate over the `properties` schema property if it is an object. For each\n     * key, initialize a new Validator for the subschema represented by the property\n     * value and invoke compile. Append the result of compiling each subschema to\n     * the block of code being generated.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          address = this.address;\n      var properties = schema.properties,\n          required = schema.required;\n\n      var block = this.push();\n\n      // ensure the value of \"required\" schema property is an array\n      required = Array.isArray(required) ? required : [];\n\n      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var isRequired = required.indexOf(key) !== -1;\n          // TODO\n          // how should we be calculating these things? should be json pointer?\n          // needs a separate function\n          var pointer = [address, key].filter(function (segment) {\n            return !!segment;\n          }).join('.');\n          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\n          // read the value\n          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\n          block += validation.compile();\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Other Properties\n     *\n     * @description\n     * This method is not for a keyword. It wraps validations for\n     * patternProperties and additionalProperties in a single iteration over\n     * an object-type value's properties.\n     *\n     * It should only be invoked once for a given subschema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'otherProperties',\n    value: function otherProperties() {\n      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n    }\n\n    /**\n     * Pattern Validations\n     *\n     * @description\n     * Generate validation code from a subschema for properties matching a\n     * regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternValidations',\n    value: function patternValidations() {\n      var patternProperties = this.schema.patternProperties;\n\n      var block = '';\n\n      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n        Object.keys(patternProperties).forEach(function (pattern) {\n          var subschema = patternProperties[pattern];\n          var validator = new Validator(subschema);\n          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * Additional Validations\n     *\n     * @description\n     * Generate validation code, either from a subschema for properties not\n     * defined in the schema, or to disallow properties not defined in the\n     * schema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalValidations',\n    value: function additionalValidations() {\n      var _schema = this.schema,\n          properties = _schema.properties,\n          additionalProperties = _schema.additionalProperties,\n          address = this.address;\n\n      var validations = '';\n      var block = '';\n\n      // catch additional unmatched properties\n      var conditions = ['matched !== true'];\n\n      // ignore defined properties\n      Object.keys(properties || {}).forEach(function (key) {\n        conditions.push('key !== \\'' + key + '\\'');\n      });\n\n      // validate additional properties\n      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n        var subschema = additionalProperties;\n        var validator = new Validator(subschema, { address: address + '[APKey]' });\n        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n      }\n\n      // error for additional properties\n      if (additionalProperties === false) {\n        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * patternProperties\n     *\n     * @description\n     * Generate validation code for properties matching a pattern\n     * defined by the property name (key), which must be a string\n     * representing a valid regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternProperties',\n    value: function patternProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * additionalProperties\n     *\n     * @description\n     * Generate validation code for additional properties not defined\n     * in the schema, or disallow additional properties if the value of\n     * `additionalProperties` in the schema is `false`.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * minProperties\n     *\n     * @description\n     * > An object instance is valid against \"minProperties\" if its number of\n     * > properties is greater than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minProperties',\n    value: function minProperties() {\n      var minProperties = this.schema.minProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxProperties\n     *\n     * @description\n     * > An object instance is valid against \"maxProperties\" if its number of\n     * > properties is less than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxProperties',\n    value: function maxProperties() {\n      var maxProperties = this.schema.maxProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Dependencies\n     *\n     * @description\n     * > For all (name, schema) pair of schema dependencies, if the instance has\n     * > a property by this name, then it must also validate successfully against\n     * > the schema.\n     * >\n     * > Note that this is the instance itself which must validate successfully,\n     * > not the value associated with the property name.\n     * >\n     * > For each (name, propertyset) pair of property dependencies, if the\n     * > instance has a property by this name, then it must also have properties\n     * > with the same names as propertyset.\n     * > JSON Schema Validation Section 5.4.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'dependencies',\n    value: function dependencies() {\n      var dependencies = this.schema.dependencies,\n          address = this.address;\n\n\n      var block = this.push();\n\n      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n        Object.keys(dependencies).forEach(function (key) {\n          var dependency = dependencies[key];\n          var conditions = [];\n\n          if (Array.isArray(dependency)) {\n            dependency.forEach(function (item) {\n              conditions.push('container[\\'' + item + '\\'] === undefined');\n            });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n            var subschema = dependency;\n            var validator = new Validator(subschema, { address: address });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n          }\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Required\n     *\n     * @description\n     * > An object instance is valid against this keyword if its property set\n     * > contains all elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.4.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'required',\n    value: function required() {\n      var properties = this.schema.properties,\n          address = this.address;\n\n      var block = '';\n\n      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\n      return block;\n    }\n\n    /**\n     * additionalItems\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {\n      var _schema2 = this.schema,\n          items = _schema2.items,\n          additionalItems = _schema2.additionalItems,\n          address = this.address;\n\n      var block = '';\n\n      if (additionalItems === false && Array.isArray(items)) {\n        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n      }\n\n      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n        var subschema = additionalItems;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Items\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * Code to generate\n     *\n     *     // this outer conditional is generated by this.array()\n     *     if (Array.isArray(value) {\n     *       let parent = value\n     *       for (let i = 0; i < parent.length; i++) {\n     *         value = parent[i]\n     *         // other validation code depending on value here\n     *       }\n     *       value = parent\n     *     }\n     *\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var items = this.schema.items,\n          address = this.address;\n\n      var block = '';\n\n      // if items is an array\n      if (Array.isArray(items)) {\n        block += this.push();\n\n        items.forEach(function (item, index) {\n          var subschema = item;\n          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\n          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n        });\n\n        block += this.pop();\n\n        // if items is an object\n      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n        var subschema = items;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minItems\n     *\n     * @description\n     * > An array instance is valid against \"minItems\" if its size is greater\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minItems',\n    value: function minItems() {\n      var minItems = this.schema.minItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxItems\n     *\n     * @description\n     * > An array instance is valid against \"maxItems\" if its size is less\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxItems',\n    value: function maxItems() {\n      var maxItems = this.schema.maxItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * uniqueItems\n     *\n     * @description\n     * > If this keyword has boolean value false, the instance validates\n     * > successfully. If it has boolean value true, the instance validates\n     * > successfully if all of its elements are unique.\n     * > JSON Schema Validation Section 5.3.4\n     *\n     * TODO\n     * optimize\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'uniqueItems',\n    value: function uniqueItems() {\n      var uniqueItems = this.schema.uniqueItems,\n          address = this.address;\n\n      var block = '';\n\n      if (uniqueItems === true) {\n        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is\n     * > greater than, or equal to, the value of this keyword. The length of\n     * > a string instance is defined as the number of its characters as\n     * > defined by RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength() {\n      var minLength = this.schema.minLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is less\n     * > than, or equal to, the value of this keyword. The length of a string\n     * > instance is defined as the number of its characters as defined by\n     * > RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxLength',\n    value: function maxLength() {\n      var maxLength = this.schema.maxLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Pattern\n     *\n     * @description\n     * > A string instance is considered valid if the regular expression\n     * > matches the instance successfully.\n     * > JSON Schema Validation Section 5.2.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      var pattern = this.schema.pattern,\n          address = this.address;\n\n\n      if (pattern) {\n        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n      }\n    }\n\n    /**\n     * Format\n     *\n     * @description\n     * > Structural validation alone may be insufficient to validate that\n     * > an instance meets all the requirements of an application. The\n     * > \"format\" keyword is defined to allow interoperable semantic\n     * > validation for a fixed subset of values which are accurately\n     * > described by authoritative resources, be they RFCs or other\n     * > external specifications.\n     * > JSON Schema Validation Section 7.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'format',\n    value: function format() {\n      var format = this.schema.format,\n          address = this.address;\n\n      var matcher = formats.resolve(format);\n\n      if (matcher) {\n        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n      }\n    }\n\n    /**\n     * Minimum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is greater\n     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n     * > present and has boolean value true, the instance is valid if it is\n     * > strictly greater than the value of \"minimum\".\n     * > JSON Schema Validation Section 5.1.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      var _schema3 = this.schema,\n          minimum = _schema3.minimum,\n          exclusiveMinimum = _schema3.exclusiveMinimum,\n          address = this.address;\n\n      var operator = exclusiveMinimum === true ? '<=' : '<';\n\n      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Maximum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is lower than,\n     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n     * > boolean value true, the instance is valid if it is strictly lower\n     * > than the value of \"maximum\".\n     * > JSON Schema Validation Section 5.1.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      var _schema4 = this.schema,\n          maximum = _schema4.maximum,\n          exclusiveMaximum = _schema4.exclusiveMaximum,\n          address = this.address;\n\n      var operator = exclusiveMaximum === true ? '>=' : '>';\n\n      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * multipleOf\n     *\n     * @description\n     * > A numeric instance is valid against \"multipleOf\" if the result of\n     * > the division of the instance by this keyword's value is an integer.\n     * > JSON Schema Validation Section 5.1.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'multipleOf',\n    value: function multipleOf() {\n      var multipleOf = this.schema.multipleOf;\n\n      var block = '';\n\n      if (typeof multipleOf === 'number') {\n        var length = multipleOf.toString().length;\n        var decimals = length - multipleOf.toFixed(0).length - 1;\n        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n        var condition = void 0;\n\n        if (decimals > 0) {\n          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n        } else {\n          condition = 'value % ' + multipleOf + ' !== 0';\n        }\n\n        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n  }]);\n\n  return Validator;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Validator;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\nvar JWA = __webpack_require__(38);\nvar JWK = __webpack_require__(57);\nvar JWKSet = __webpack_require__(60);\nvar JWT = __webpack_require__(62);\nvar JWS = __webpack_require__(67);\nvar Base64URLSchema = __webpack_require__(64);\nvar JOSEHeaderSchema = __webpack_require__(66);\nvar JWKSchema = __webpack_require__(58);\nvar JWKSetSchema = __webpack_require__(61);\nvar JWTClaimsSetSchema = __webpack_require__(65);\nvar JWTSchema = __webpack_require__(63);\n\n/**\n * Export\n */\nmodule.exports = {\n  JWA: JWA,\n  JWK: JWK,\n  JWKSet: JWKSet,\n  JWT: JWT,\n  JWS: JWS,\n  Base64URLSchema: Base64URLSchema,\n  JOSEHeaderSchema: JOSEHeaderSchema,\n  JWKSchema: JWKSchema,\n  JWKSetSchema: JWKSetSchema,\n  JWTClaimsSetSchema: JWTClaimsSetSchema,\n  JWTSchema: JWTSchema\n};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\nvar base64url = __webpack_require__(39);\nvar supportedAlgorithms = __webpack_require__(46);\n\nvar _require = __webpack_require__(55),\n    NotSupportedError = _require.NotSupportedError;\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\n\n\nvar JWA = function () {\n  function JWA() {\n    _classCallCheck(this, JWA);\n  }\n\n  _createClass(JWA, null, [{\n    key: 'sign',\n\n\n    /**\n     * Sign\n     *\n     * @description\n     * Create a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} key\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n    value: function sign(alg, key, data) {\n      // normalize the algorithm\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg);\n\n      // validate algorithm is supported\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // validate type of key\n      // TODO\n      //  - is the key suitable for the algorithm?\n      //  - does that get validated in webcrypto?\n      //if (key instanceof CryptoKey) {\n      //  return Promise.reject(new InvalidKeyError())\n      //}\n\n      // sign the data\n      return normalizedAlgorithm.sign(key, data);\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} privateKey\n     * @param {string|Buffer} signature\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(alg, key, signature, data) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // TODO\n      // validate publicKey\n\n      // verify the signature\n      return normalizedAlgorithm.verify(key, signature, data);\n    }\n\n    /**\n     * Encrypt\n     */\n\n    /**\n     * Decrypt\n     */\n\n    /**\n     * Import\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg);\n      return normalizedAlgorithm.importKey(key);\n    }\n  }]);\n\n  return JWA;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWA;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(40).default;\nmodule.exports.default = module.exports;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pad_string_1 = __webpack_require__(45);\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return Buffer.from(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nexports.default = base64url;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(42)\nvar ieee754 = __webpack_require__(43)\nvar isArray = __webpack_require__(44)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = Buffer.alloc(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nexports.default = padString;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Local dependencies\n */\nvar None = __webpack_require__(47);\nvar HMAC = __webpack_require__(48);\nvar RSASSA_PKCS1_v1_5 = __webpack_require__(52);\nvar SupportedAlgorithms = __webpack_require__(53);\n\n/**\n * Register Supported Algorithms\n */\nvar supportedAlgorithms = new SupportedAlgorithms();\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n//supportedAlgorithms.define('ES256', 'sign', {})\n//supportedAlgorithms.define('ES384', 'sign', {})\n//supportedAlgorithms.define('ES512', 'sign', {})\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\n\nsupportedAlgorithms.define('none', 'sign', new None({\n  // nothing goes here\n}));\n\n/**\n * Verify\n */\nsupportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n//supportedAlgorithms.define('ES256', 'verify', {})\n//supportedAlgorithms.define('ES384', 'verify', {})\n//supportedAlgorithms.define('ES512', 'verify', {})\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\n\nsupportedAlgorithms.define('none', 'verify', new None({\n  // nothing goes here\n}));\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n/**\n * Export\n */\nmodule.exports = supportedAlgorithms;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * None\n */\nvar None = function () {\n  function None() {\n    _classCallCheck(this, None);\n  }\n\n  _createClass(None, [{\n    key: 'sign',\n\n    /**\n     * sign\n     */\n    value: function sign() {\n      return Promise.resolve('');\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      // this will never get called. but you looked.\n    }\n  }]);\n\n  return None;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = None;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = __webpack_require__(39);\nvar crypto = __webpack_require__(49);\nvar TextEncoder = __webpack_require__(50);\n\n/**\n * HMAC with SHA-2 Functions\n */\n\nvar HMAC = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  function HMAC(params) {\n    _classCallCheck(this, HMAC);\n\n    this.params = params;\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO: validate key length\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {string} signature\n     * @param {string} data\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * Assert Sufficient Key Length\n     *\n     * @description Assert that the key length is sufficient\n     * @param {string} key\n     */\n\n  }, {\n    key: 'assertSufficientKeyLength',\n    value: function assertSufficientKeyLength(key) {\n      if (key.length < this.bitlength) {\n        throw new Error('The key is too short.');\n      }\n    }\n  }]);\n\n  return HMAC;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = HMAC;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"crypto\"]; }());\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar TextEncoder = global.TextEncoder ? global.TextEncoder // browser\n: __webpack_require__(51).TextEncoder; // node shim\nmodule.exports = TextEncoder;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"TextEncoder\"]; }());\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = __webpack_require__(39);\nvar crypto = __webpack_require__(49);\nvar TextEncoder = __webpack_require__(50);\n\n/**\n * RSASSA-PKCS1-v1_5\n */\n\nvar RSASSA_PKCS1_v1_5 = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function RSASSA_PKCS1_v1_5(params) {\n    _classCallCheck(this, RSASSA_PKCS1_v1_5);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(RSASSA_PKCS1_v1_5, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO\n      //if (!this.sufficientKeySize()) {\n      //  return Promise.reject(\n      //    new Error(\n      //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n      //    )\n      //  )\n      //}\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return RSASSA_PKCS1_v1_5;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = RSASSA_PKCS1_v1_5;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar NotSupportedError = __webpack_require__(54);\n\n/**\n * Operations\n */\nvar operations = ['sign', 'verify', 'encrypt', 'decrypt', 'importKey'];\n\n/**\n * SupportedAlgorithms\n */\n\nvar SupportedAlgorithms = function () {\n\n  /**\n   * constructor\n   */\n  function SupportedAlgorithms() {\n    var _this = this;\n\n    _classCallCheck(this, SupportedAlgorithms);\n\n    operations.forEach(function (op) {\n      _this[op] = {};\n    });\n  }\n\n  /**\n   * Supported Operations\n   */\n\n\n  _createClass(SupportedAlgorithms, [{\n    key: 'define',\n\n\n    /**\n     * define\n     *\n     * @description\n     * Register Web Crypto API algorithm parameter for an algorithm\n     * and operation.\n     *\n     * @param {string} alg\n     * @param {string} op\n     * @param {Object} argument\n     */\n    value: function define(alg, op, argument) {\n      var registeredAlgorithms = this[op];\n      registeredAlgorithms[alg] = argument;\n    }\n\n    /**\n     * normalize\n     *\n     * @description\n     * Map JWA alg name to Web Crypto API algorithm parameter\n     *\n     * @param {string} op\n     * @param {Object} alg\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(op, alg) {\n      var registeredAlgorithms = this[op];\n\n      if (!registeredAlgorithms) {\n        return new SyntaxError(); // what kind of error should this be?\n      }\n\n      var argument = registeredAlgorithms[alg];\n\n      if (!argument) {\n        return new NotSupportedError(alg);\n      }\n\n      return argument;\n    }\n  }], [{\n    key: 'operations',\n    get: function get() {\n      return operations;\n    }\n  }]);\n\n  return SupportedAlgorithms;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = SupportedAlgorithms;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * NotSupportedError\n */\nvar NotSupportedError = function (_Error) {\n  _inherits(NotSupportedError, _Error);\n\n  function NotSupportedError(alg) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this.message = alg + \" is not a supported algorithm\";\n    return _this;\n  }\n\n  return NotSupportedError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = NotSupportedError;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  DataError: __webpack_require__(56),\n  NotSupportedError: __webpack_require__(54)\n};\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * DataError\n */\nvar DataError = function (_Error) {\n  _inherits(DataError, _Error);\n\n  function DataError(message) {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message));\n  }\n\n  return DataError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = DataError;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSchema = __webpack_require__(58);\nvar JWA = __webpack_require__(38);\n\n/**\n * JWK Class\n */\n\nvar JWK = function (_JSONDocument) {\n  _inherits(JWK, _JSONDocument);\n\n  function JWK() {\n    _classCallCheck(this, JWK);\n\n    return _possibleConstructorReturn(this, (JWK.__proto__ || Object.getPrototypeOf(JWK)).apply(this, arguments));\n  }\n\n  _createClass(JWK, null, [{\n    key: 'importKey',\n\n\n    /**\n     * importKey\n     *\n     * TODO:\n     * - should this be on JWA?\n     */\n    value: function importKey(jwk) {\n      return JWA.importKey(jwk);\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return JWKSchema;\n    }\n  }]);\n\n  return JWK;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWK;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\nvar _require2 = __webpack_require__(59),\n    BASE64_REGEXP = _require2.BASE64_REGEXP;\n\n/**\n * JWK Schema\n */\n\n\nvar JWKSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    kty: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['RSA', 'EC', 'oct'] // other values MAY be used\n    },\n\n    use: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['sig', 'enc'] // other values MAY be used\n    },\n\n    key_ops: {\n      type: 'array',\n      //format: 'case-sensitive',\n      items: {\n        enum: ['sign', 'verify', 'encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey', 'deriveBits'] // other values MAY be used\n      }\n    },\n\n    alg: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'PS256', 'PS384', 'PS512', 'none'] // other values MAY be used\n    },\n\n    kid: {\n      type: 'string'\n    },\n\n    x5u: {\n      type: 'string'\n      //format: 'url'\n    },\n\n    x5c: {\n      type: 'array'\n      //format: BASE64_REGEXP\n    },\n\n    x5t: {\n      type: 'string'\n      //format: BASE64_REGEXP\n    }\n\n    //'x5t#S256': {\n    //  type: 'string',\n    //  //format: BASE64_REGEXP\n    //}\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSchema;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Package dependencies\n */\nvar _require = __webpack_require__(28),\n    Formats = _require.Formats;\n\n/**\n * Format extensions\n */\n\n\nFormats.register('StringOrURI', new RegExp());\nFormats.register('NumericDate', new RegExp());\nFormats.register('URI', new RegExp());\nFormats.register('url', new RegExp());\nFormats.register('base64', new RegExp());\nFormats.register('base64url', new RegExp());\nFormats.register('MediaType', new RegExp());\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSetSchema = __webpack_require__(61);\nvar JWK = __webpack_require__(57);\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\n\nvar JWKSet = function (_JSONDocument) {\n  _inherits(JWKSet, _JSONDocument);\n\n  function JWKSet() {\n    _classCallCheck(this, JWKSet);\n\n    return _possibleConstructorReturn(this, (JWKSet.__proto__ || Object.getPrototypeOf(JWKSet)).apply(this, arguments));\n  }\n\n  _createClass(JWKSet, null, [{\n    key: 'importKeys',\n\n\n    /**\n     * importKeys\n     */\n    value: function importKeys(jwks) {\n      var validation = this.schema.validate(jwks);\n\n      if (!validation.valid) {\n        return Promise.reject(new Error('Invalid JWKSet: ' + JSON.stringify(validation, null, 2)));\n      }\n\n      if (!jwks.keys) {\n        return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'));\n      }\n\n      var imported = void 0,\n          importing = void 0;\n\n      try {\n        imported = new JWKSet(jwks);\n        importing = jwks.keys.map(function (key) {\n          return JWK.importKey(key);\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n\n      return Promise.all(importing).then(function (keys) {\n        imported.keys = keys;\n        return imported;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWKSetSchema;\n    }\n  }]);\n\n  return JWKSet;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWKSet;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\nvar JWKSchema = __webpack_require__(58);\n\n/**\n * JWKSetSchema\n */\nvar JWKSetSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    keys: {\n      type: 'array',\n      items: JWKSchema\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSetSchema;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(39);\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWTSchema = __webpack_require__(63);\nvar JWS = __webpack_require__(67);\nvar DataError = __webpack_require__(56);\n\n/**\n * JWT\n */\n\nvar JWT = function (_JSONDocument) {\n  _inherits(JWT, _JSONDocument);\n\n  function JWT() {\n    _classCallCheck(this, JWT);\n\n    return _possibleConstructorReturn(this, (JWT.__proto__ || Object.getPrototypeOf(JWT)).apply(this, arguments));\n  }\n\n  _createClass(JWT, [{\n    key: 'isJWE',\n\n\n    /**\n     * isJWE\n     */\n    value: function isJWE() {\n      return !!this.header.enc;\n    }\n\n    /**\n     * resolveKeys\n     */\n\n  }, {\n    key: 'resolveKeys',\n    value: function resolveKeys(jwks) {\n      var kid = this.header.kid;\n      var keys = void 0,\n          match = void 0;\n\n      // treat an array as the \"keys\" property of a JWK Set\n      if (Array.isArray(jwks)) {\n        keys = jwks;\n      }\n\n      // presence of keys indicates object is a JWK Set\n      if (jwks.keys) {\n        keys = jwks.keys;\n      }\n\n      // wrap a plain object they is not a JWK Set in Array\n      if (!jwks.keys && (typeof jwks === 'undefined' ? 'undefined' : _typeof(jwks)) === 'object') {\n        keys = [jwks];\n      }\n\n      // ensure there are keys to search\n      if (!keys) {\n        throw new DataError('Invalid JWK argument');\n      }\n\n      // match by \"kid\" or \"use\" header\n      if (kid) {\n        match = keys.find(function (jwk) {\n          return jwk.kid === kid;\n        });\n      } else {\n        match = keys.find(function (jwk) {\n          return jwk.use === 'sig';\n        });\n      }\n\n      // assign matching key to JWT and return a boolean\n      if (match) {\n        this.key = match.cryptoKey;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      // validate\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      var token = this;\n\n      if (this.isJWE()) {\n        return JWE.encrypt(token);\n      } else {\n        return JWS.sign(token);\n      }\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a decoded JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      return JWS.verify(this);\n    }\n  }], [{\n    key: 'decode',\n\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Token\n     *\n     * @param {string} data\n     * @returns {JWT}\n     */\n    value: function decode(data) {\n      var ExtendedJWT = this;\n      var jwt = void 0;\n\n      if (typeof data !== 'string') {\n        throw new DataError('JWT must be a string');\n      }\n\n      // JSON of Flattened JSON Serialization\n      if (data.startsWith('{')) {\n        try {\n          data = JSON.parse(data, function () {});\n        } catch (error) {\n          throw new DataError('Invalid JWT serialization');\n        }\n\n        if (data.signatures || data.recipients) {\n          data.serialization = 'json';\n        } else {\n          data.serialization = 'flattened';\n        }\n\n        jwt = new ExtendedJWT(data, { filter: false });\n\n        // Compact Serialization\n      } else {\n        try {\n          var serialization = 'compact';\n          var segments = data.split('.');\n          var length = segments.length;\n\n          if (length !== 3 && length !== 5) {\n            throw new Error('Malformed JWT');\n          }\n\n          var header = JSON.parse(base64url.decode(segments[0]));\n\n          // JSON Web Signature\n          if (length === 3) {\n            var type = 'JWS';\n            var payload = JSON.parse(base64url.decode(segments[1]));\n            var signature = segments[2];\n\n            jwt = new ExtendedJWT({ type: type, segments: segments, header: header, payload: payload, signature: signature, serialization: serialization }, { filter: false });\n          }\n\n          // JSON Web Encryption\n          if (length === 5) {\n            //let type = 'JWE'\n            //let [protected, encryption_key, iv, ciphertext, tag] = segments\n\n            //jwt = new ExtendedJWT({\n            //  type,\n            //  protected: base64url.decode(JSON.parse(protected)),\n            //  encryption_key,\n            //  iv,\n            //  ciphertext,\n            //  tag,\n            //  serialization\n            //})\n          }\n        } catch (error) {\n          throw new DataError('Invalid JWT compact serialization');\n        }\n      }\n\n      return jwt;\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token\n     *\n     * @param {Object} header\n     * @param {Object} payload\n     * @param {CryptoKey} key\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode(header, payload, key) {\n      var jwt = new JWT(header, payload);\n      return jwt.encode(key);\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     *\n     * @param {CryptoKey} key\n     * @param {string} token\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, token) {\n      var jwt = JWT.decode(token);\n      jwt.key = key;\n      return jwt.verify().then(function (verified) {\n        return jwt;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWTSchema;\n    }\n  }]);\n\n  return JWT;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWT;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar Base64URLSchema = __webpack_require__(64);\nvar JWTClaimsSetSchema = __webpack_require__(65);\nvar JOSEHeaderSchema = __webpack_require__(66);\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTSchema\n *\n * @description\n * This schema represents all the things a deserialized JWT can be, i.e.,\n * either a JWS or JWE, and any serialization of them. Validation of well-\n * formedness for a given serialization is accomplished at the time of\n * encoding.\n */\n\n\nvar JWTSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * type\n     */\n    type: {\n      type: 'string',\n      enum: ['JWS', 'JWE']\n    },\n\n    /**\n     * segments\n     */\n    segments: {\n      type: 'array'\n    },\n\n    /**\n     * header\n     */\n    header: JOSEHeaderSchema,\n\n    /**\n     * protected\n     */\n    protected: JOSEHeaderSchema,\n\n    /**\n     * unprotected\n     */\n    unprotected: JOSEHeaderSchema,\n\n    /**\n     * iv\n     */\n    iv: Base64URLSchema,\n\n    /**\n     * aad\n     */\n    aad: Base64URLSchema,\n\n    /**\n     * ciphertext\n     */\n    ciphertext: Base64URLSchema,\n\n    /**\n     * tag\n     */\n    tag: Base64URLSchema,\n\n    /**\n     * recipients\n     */\n    recipients: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          header: JOSEHeaderSchema,\n          encrypted_key: Base64URLSchema\n        }\n      }\n    },\n\n    /**\n     * payload\n     */\n    payload: JWTClaimsSetSchema,\n\n    /**\n     * signatures\n     */\n    signatures: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          protected: JOSEHeaderSchema,\n          header: JOSEHeaderSchema,\n          signature: Base64URLSchema,\n          key: { type: 'object' }\n        }\n      }\n    },\n\n    /**\n     * signature\n     */\n    signature: Base64URLSchema,\n\n    /**\n     * verified\n     */\n    verified: {\n      type: 'boolean',\n      default: false\n    },\n\n    /**\n     * key\n     */\n    key: {\n      type: 'object'\n    },\n\n    /**\n     * serialization\n     */\n    serialization: {\n      type: 'string',\n      enum: ['compact', 'json', 'flattened'],\n      default: 'compact'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTSchema;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * Base64URLSchema\n */\n\n\nvar Base64URLSchema = new JSONSchema({\n  type: 'string',\n  format: 'base64url'\n});\n\n/**\n * Export\n */\nmodule.exports = Base64URLSchema;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTClaimsSetSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-4\n *\n * 4.  JWT Claims\n *\n *   The JWT Claims Set represents a JSON object whose members are the\n *   claims conveyed by the JWT.  The Claim Names within a JWT Claims Set\n *   MUST be unique; JWT parsers MUST either reject JWTs with duplicate\n *   Claim Names or use a JSON parser that returns only the lexically last\n *   duplicate member name, as specified in Section 15.12 (\"The JSON\n *   Object\") of ECMAScript 5.1 [ECMAScript].\n *\n *   The set of claims that a JWT must contain to be considered valid is\n *   context dependent and is outside the scope of this specification.\n *   Specific applications of JWTs will require implementations to\n *   understand and process some claims in particular ways.  However, in\n *   the absence of such requirements, all claims that are not understood\n *   by implementations MUST be ignored.\n *\n *   There are three classes of JWT Claim Names: Registered Claim Names,\n *   Public Claim Names, and Private Claim Names.\n */\n\n\nvar JWTClaimsSetSchema = new JSONSchema({\n  properties: {\n\n    /**\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1\n     *\n     * 4.1.  Registered Claim Names\n     *\n     *   The following Claim Names are registered in the IANA \"JSON Web Token\n     *   Claims\" registry established by Section 10.1.  None of the claims\n     *   defined below are intended to be mandatory to use or implement in all\n     *   cases, but rather they provide a starting point for a set of useful,\n     *   interoperable claims.  Applications using JWTs should define which\n     *   specific claims they use and when they are required or optional.  All\n     *   the names are short because a core goal of JWTs is for the\n     *   representation to be compact.\n     */\n\n    /**\n     * iss\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.1\n     *\n     * 4.1.1.  \"iss\" (Issuer) Claim\n     *\n     *   The \"iss\" (issuer) claim identifies the principal that issued the\n     *   JWT.  The processing of this claim is generally application specific.\n     *   The \"iss\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    iss: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * sub\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.2\n     *\n     * 4.1.2.  \"sub\" (Subject) Claim\n     *\n     *   The \"sub\" (subject) claim identifies the principal that is the\n     *   subject of the JWT.  The claims in a JWT are normally statements\n     *   about the subject.  The subject value MUST either be scoped to be\n     *   locally unique in the context of the issuer or be globally unique.\n     *   The processing of this claim is generally application specific.  The\n     *   \"sub\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    sub: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * aud\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.3\n     *\n     * 4.1.3.  \"aud\" (Audience) Claim\n     *\n     *   The \"aud\" (audience) claim identifies the recipients that the JWT is\n     *   intended for.  Each principal intended to process the JWT MUST\n     *   identify itself with a value in the audience claim.  If the principal\n     *   processing the claim does not identify itself with a value in the\n     *   \"aud\" claim when this claim is present, then the JWT MUST be\n     *   rejected.  In the general case, the \"aud\" value is an array of case-\n     *   sensitive strings, each containing a StringOrURI value.  In the\n     *   special case when the JWT has one audience, the \"aud\" value MAY be a\n     *   single case-sensitive string containing a StringOrURI value.  The\n     *   interpretation of audience values is generally application specific.\n     *   Use of this claim is OPTIONAL.\n     */\n    aud: {\n      type: ['array', 'string'],\n      format: 'StringOrURI',\n      items: {\n        format: 'StringOrURI'\n      }\n    },\n\n    /**\n     * exp\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.4\n     *\n     * 4.1.4.  \"exp\" (Expiration Time) Claim\n     *\n     *   The \"exp\" (expiration time) claim identifies the expiration time on\n     *   or after which the JWT MUST NOT be accepted for processing.  The\n     *   processing of the \"exp\" claim requires that the current date/time\n     *   MUST be before the expiration date/time listed in the \"exp\" claim.\n     *\n     *   Implementers MAY provide for some small leeway, usually no more than\n     *   a few minutes, to account for clock skew.  Its value MUST be a number\n     *   containing a NumericDate value.  Use of this claim is OPTIONAL.\n     *\n     */\n    exp: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * nbf\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.5\n     *\n     * 4.1.5.  \"nbf\" (Not Before) Claim\n     *\n     *   The \"nbf\" (not before) claim identifies the time before which the JWT\n     *   MUST NOT be accepted for processing.  The processing of the \"nbf\"\n     *   claim requires that the current date/time MUST be after or equal to\n     *   the not-before date/time listed in the \"nbf\" claim.  Implementers MAY\n     *   provide for some small leeway, usually no more than a few minutes, to\n     *   account for clock skew.  Its value MUST be a number containing a\n     *   NumericDate value.  Use of this claim is OPTIONAL.\n     */\n    nbf: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * iat\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.6\n     *\n     * 4.1.6.  \"iat\" (Issued At) Claim\n     *\n     *   The \"iat\" (issued at) claim identifies the time at which the JWT was\n     *   issued.  This claim can be used to determine the age of the JWT.  Its\n     *   value MUST be a number containing a NumericDate value.  Use of this\n     *   claim is OPTIONAL.\n     */\n    iat: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * jti\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.7\n     *\n     * 4.1.7.  \"jti\" (JWT ID) Claim\n     *\n     *   The \"jti\" (JWT ID) claim provides a unique identifier for the JWT.\n     *   The identifier value MUST be assigned in a manner that ensures that\n     *   there is a negligible probability that the same value will be\n     *   accidentally assigned to a different data object; if the application\n     *   uses multiple issuers, collisions MUST be prevented among values\n     *   produced by different issuers as well.  The \"jti\" claim can be used\n     *   to prevent the JWT from being replayed.  The \"jti\" value is a case-\n     *   sensitive string.  Use of this claim is OPTIONAL.\n     */\n    jti: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTClaimsSetSchema;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar JWKSchema = __webpack_require__(58);\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JOSEHeaderSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-5\n *\n * 5.  JOSE Header\n *\n *   For a JWT object, the members of the JSON object represented by the\n *   JOSE Header describe the cryptographic operations applied to the JWT\n *   and optionally, additional properties of the JWT.  Depending upon\n *   whether the JWT is a JWS or JWE, the corresponding rules for the JOSE\n *   Header values apply.\n */\n\n\nvar JOSEHeaderSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * typ\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.1\n     *\n     * 5.1.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter defined by [JWS] and [JWE] is used\n     *   by JWT applications to declare the media type [IANA.MediaTypes] of\n     *   this complete JWT.  This is intended for use by the JWT application\n     *   when values that are not JWTs could also be present in an application\n     *   data structure that can contain a JWT object; the application can use\n     *   this value to disambiguate among the different kinds of objects that\n     *   might be present.  It will typically not be used by applications when\n     *   it is already known that the object is a JWT.  This parameter is\n     *   ignored by JWT implementations; any processing of this parameter is\n     *   performed by the JWT application.  If present, it is RECOMMENDED that\n     *   its value be \"JWT\" to indicate that this object is a JWT.  While\n     *   media type names are not case sensitive, it is RECOMMENDED that \"JWT\"\n     *   always be spelled using uppercase characters for compatibility with\n     *   legacy implementations.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.9\n     *\n     * 4.1.9.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter is used by JWS applications to\n     *   declare the media type [IANA.MediaTypes] of this complete JWS.  This\n     *   is intended for use by the application when more than one kind of\n     *   object could be present in an application data structure that can\n     *   contain a JWS; the application can use this value to disambiguate\n     *   among the different kinds of objects that might be present.  It will\n     *   typically not be used by applications when the kind of object is\n     *   already known.  This parameter is ignored by JWS implementations; any\n     *   processing of this parameter is performed by the JWS application.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"typ\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"typ\" value not containing a\n     *   '/'.  For instance, a \"typ\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     *   The \"typ\" value \"JOSE\" can be used by applications to indicate that\n     *   this object is a JWS or JWE using the JWS Compact Serialization or\n     *   the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be\n     *   used by applications to indicate that this object is a JWS or JWE\n     *   using the JWS JSON Serialization or the JWE JSON Serialization.\n     *   Other type values can also be used by applications.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.11\n     *\n     * 4.1.11.  \"typ\" (Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"typ\" Header Parameter defined in Section 4.1.9 of [JWS], except\n     *   that the type is that of this complete JWE.\n     */\n    typ: {\n      type: 'string'\n    },\n\n    /**\n     * cty\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.2\n     *\n     * 5.2.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter defined by [JWS] and [JWE]\n     *   is used by this specification to convey structural information about\n     *   the JWT.\n     *\n     *   In the normal case in which nested signing or encryption operations\n     *   are not employed, the use of this Header Parameter is NOT\n     *   RECOMMENDED.  In the case that nested signing or encryption is\n     *   employed, this Header Parameter MUST be present; in this case, the\n     *   value MUST be \"JWT\", to indicate that a Nested JWT is carried in this\n     *   JWT.  While media type names are not case sensitive, it is\n     *   RECOMMENDED that \"JWT\" always be spelled using uppercase characters\n     *   for compatibility with legacy implementations.  See Appendix A.2 for\n     *   an example of a Nested JWT.\n     *\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.10\n     *\n     * 4.1.10.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter is used by JWS applications\n     *   to declare the media type [IANA.MediaTypes] of the secured content\n     *   (the payload).  This is intended for use by the application when more\n     *   than one kind of object could be present in the JWS Payload; the\n     *   application can use this value to disambiguate among the different\n     *   kinds of objects that might be present.  It will typically not be\n     *   used by applications when the kind of object is already known.  This\n     *   parameter is ignored by JWS implementations; any processing of this\n     *   parameter is performed by the JWS application.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"cty\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"cty\" value not containing a\n     *   '/'.  For instance, a \"cty\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.12\n     *\n     * 4.1.12.  \"cty\" (Content Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"cty\" Header Parameter defined in Section 4.1.10 of [JWS], except\n     *   that the type is that of the secured content (the plaintext).\n     */\n    cty: {\n      type: 'string',\n      enum: ['JWT']\n    },\n\n    /**\n     * alg\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   The \"alg\" (algorithm) Header Parameter identifies the cryptographic\n     *   algorithm used to secure the JWS.  The JWS Signature value is not\n     *   valid if the \"alg\" value does not represent a supported algorithm or\n     *   if there is not a key for use with that algorithm associated with the\n     *   party that digitally signed or MACed the content.  \"alg\" values\n     *   should either be registered in the IANA \"JSON Web Signature and\n     *   Encryption Algorithms\" registry established by [JWA] or be a value\n     *   that contains a Collision-Resistant Name.  The \"alg\" value is a case-\n     *   sensitive ASCII string containing a StringOrURI value.  This Header\n     *   Parameter MUST be present and MUST be understood and processed by\n     *   implementations.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 3.1 of [JWA].\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"alg\" Header Parameter defined in Section 4.1.1 of [JWS], except\n     *   that the Header Parameter identifies the cryptographic algorithm used\n     *   to encrypt or determine the value of the CEK.  The encrypted content\n     *   is not usable if the \"alg\" value does not represent a supported\n     *   algorithm, or if the recipient does not have a key that can be used\n     *   with that algorithm.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 4.1 of [JWA].\n     */\n    alg: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * jku\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.2\n     *\n     * 4.1.2.  \"jku\" (JWK Set URL) Header Parameter (JWS)\n     *\n     *   The \"jku\" (JWK Set URL) Header Parameter is a URI [RFC3986] that\n     *   refers to a resource for a set of JSON-encoded public keys, one of\n     *   which corresponds to the key used to digitally sign the JWS.  The\n     *   keys MUST be encoded as a JWK Set [JWK].  The protocol used to\n     *   acquire the resource MUST provide integrity protection; an HTTP GET\n     *   request to retrieve the JWK Set MUST use Transport Layer Security\n     *   (TLS) [RFC2818] [RFC5246]; and the identity of the server MUST be\n     *   validated, as per Section 6 of RFC 6125 [RFC6125].  Also, see\n     *   Section 8 on TLS requirements.  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.4\n     *\n     * 4.1.4.  \"jku\" (JWK Set URL) Header Parameter (JWE)\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jku\" Header Parameter defined in Section 4.1.2 of [JWS], except\n     *   that the JWK Set resource contains the public key to which the JWE\n     *   was encrypted; this can be used to determine the private key needed\n     *   to decrypt the JWE.\n     */\n    jku: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * jwk\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.3\n     *\n     * 4.1.3.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   The \"jwk\" (JSON Web Key) Header Parameter is the public key that\n     *   corresponds to the key used to digitally sign the JWS.  This key is\n     *   represented as a JSON Web Key [JWK].  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.5\n     *\n     * 4.1.5.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jwk\" Header Parameter defined in Section 4.1.3 of [JWS], except\n     *   that the key is the public key to which the JWE was encrypted; this\n     *   can be used to determine the private key needed to decrypt the JWE.\n     */\n    //jwk: JWKSchema,\n\n    /**\n     * kid\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.4\n     *\n     * 4.1.4.  \"kid\" (Key ID) Header Parameter\n     *\n     *   The \"kid\" (key ID) Header Parameter is a hint indicating which key\n     *   was used to secure the JWS.  This parameter allows originators to\n     *   explicitly signal a change of key to recipients.  The structure of\n     *   the \"kid\" value is unspecified.  Its value MUST be a case-sensitive\n     *   string.  Use of this Header Parameter is OPTIONAL.\n     *\n     *   When used with a JWK, the \"kid\" value is used to match a JWK \"kid\"\n     *   parameter value.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.6\n     *\n     * 4.1.6.  \"kid\" (Key ID) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"kid\" Header Parameter defined in Section 4.1.4 of [JWS], except\n     *   that the key hint references the public key to which the JWE was\n     *   encrypted; this can be used to determine the private key needed to\n     *   decrypt the JWE.  This parameter allows originators to explicitly\n     *   signal a change of key to JWE recipients.\n     */\n    kid: {\n      type: 'string'\n    },\n\n    /**\n     * x5u\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.5\n     *\n     * 4.1.5.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   The \"x5u\" (X.509 URL) Header Parameter is a URI [RFC3986] that refers\n     *   to a resource for the X.509 public key certificate or certificate\n     *   chain [RFC5280] corresponding to the key used to digitally sign the\n     *   JWS.  The identified resource MUST provide a representation of the\n     *   certificate or certificate chain that conforms to RFC 5280 [RFC5280]\n     *   in PEM-encoded form, with each certificate delimited as specified in\n     *   Section 6.1 of RFC 4945 [RFC4945].  The certificate containing the\n     *   public key corresponding to the key used to digitally sign the JWS\n     *   MUST be the first certificate.  This MAY be followed by additional\n     *   certificates, with each subsequent certificate being the one used to\n     *   certify the previous one.  The protocol used to acquire the resource\n     *   MUST provide integrity protection; an HTTP GET request to retrieve\n     *   the certificate MUST use TLS [RFC2818] [RFC5246]; and the identity of\n     *   the server MUST be validated, as per Section 6 of RFC 6125 [RFC6125].\n     *   Also, see Section 8 on TLS requirements.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.7\n     *\n     * 4.1.7.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5u\" Header Parameter defined in Section 4.1.5 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5u: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * x5c\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.6\n     *\n     * 4.1.6.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   The \"x5c\" (X.509 certificate chain) Header Parameter contains the\n     *   X.509 public key certificate or certificate chain [RFC5280]\n     *   corresponding to the key used to digitally sign the JWS.  The\n     *   certificate or certificate chain is represented as a JSON array of\n     *   certificate value strings.  Each string in the array is a\n     *   base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER\n     *   [ITU.X690.2008] PKIX certificate value.  The certificate containing\n     *   the public key corresponding to the key used to digitally sign the\n     *   JWS MUST be the first certificate.  This MAY be followed by\n     *   additional certificates, with each subsequent certificate being the\n     *   one used to certify the previous one.  The recipient MUST validate\n     *   the certificate chain according to RFC 5280 [RFC5280] and consider\n     *   the certificate or certificate chain to be invalid if any validation\n     *   failure occurs.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.8\n     *\n     * 4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5c\" Header Parameter defined in Section 4.1.6 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5c: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'base64'\n      }\n    },\n\n    /**\n     * x5t\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.7\n     *\n     * 4.1.7.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   The \"x5t\" (X.509 certificate SHA-1 thumbprint) Header Parameter is a\n     *   base64url-encoded SHA-1 thumbprint (a.k.a. digest) of the DER\n     *   encoding of the X.509 certificate [RFC5280] corresponding to the key\n     *   used to digitally sign the JWS.  Note that certificate thumbprints\n     *   are also sometimes known as certificate fingerprints.  Use of this\n     *   Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.9\n     *\n     * 4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t\" Header Parameter defined in Section 4.1.7 of [JWS], except\n     *   that the certificate referenced by the thumbprint contains the public\n     *   key to which the JWE was encrypted; this can be used to determine the\n     *   private key needed to decrypt the JWE.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     */\n    x5t: {\n      type: 'string',\n      format: 'base64url'\n    },\n\n    /**\n     * x5t#S256\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.8\n     *\n     * 4.1.8.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *         Parameter\n     *\n     *   The \"x5t#S256\" (X.509 certificate SHA-256 thumbprint) Header\n     *   Parameter is a base64url-encoded SHA-256 thumbprint (a.k.a. digest)\n     *   of the DER encoding of the X.509 certificate [RFC5280] corresponding\n     *   to the key used to digitally sign the JWS.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.10\n     *\n     * 4.1.10.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *          Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t#S256\" Header Parameter defined in Section 4.1.8 of [JWS],\n     *   except that the certificate referenced by the thumbprint contains the\n     *   public key to which the JWE was encrypted; this can be used to\n     *   determine the private key needed to decrypt the JWE.  Note that\n     *   certificate thumbprints are also sometimes known as certificate\n     *   fingerprints.\n     */\n    //'x5t#S256': {\n    //  type: 'string',\n    //  format: 'base64url'\n    //},\n\n    /**\n     * crit\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.11\n     *\n     * 4.1.11.  \"crit\" (Critical) Header Parameter\n     *\n     *   The \"crit\" (critical) Header Parameter indicates that extensions to\n     *   this specification and/or [JWA] are being used that MUST be\n     *   understood and processed.  Its value is an array listing the Header\n     *   Parameter names present in the JOSE Header that use those extensions.\n     *   If any of the listed extension Header Parameters are not understood\n     *   and supported by the recipient, then the JWS is invalid.  Producers\n     *   MUST NOT include Header Parameter names defined by this specification\n     *   or [JWA] for use with JWS, duplicate names, or names that do not\n     *   occur as Header Parameter names within the JOSE Header in the \"crit\"\n     *   list.  Producers MUST NOT use the empty list \"[]\" as the \"crit\"\n     *   value.  Recipients MAY consider the JWS to be invalid if the critical\n     *   list contains any Header Parameter names defined by this\n     *   specification or [JWA] for use with JWS or if any other constraints\n     *   on its use are violated.  When used, this Header Parameter MUST be\n     *   integrity protected; therefore, it MUST occur only within the JWS\n     *   Protected Header.  Use of this Header Parameter is OPTIONAL.  This\n     *   Header Parameter MUST be understood and processed by implementations.\n     *\n     *   An example use, along with a hypothetical \"exp\" (expiration time)\n     *   field is:\n     *\n     *     {\"alg\":\"ES256\",\n     *     \"crit\":[\"exp\"],\n     *     \"exp\":1363284000\n     *     }\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.13\n     *\n     *   4.1.13.  \"crit\" (Critical) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"crit\" Header Parameter defined in Section 4.1.11 of [JWS],\n     *   except that Header Parameters for a JWE are being referred to, rather\n     *   than Header Parameters for a JWS.\n     */\n    crit: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      minItems: 1\n    },\n\n    /**\n     * enc\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.2\n     *\n     * 4.1.2.  \"enc\" (Encryption Algorithm) Header Parameter\n     *\n     *   The \"enc\" (encryption algorithm) Header Parameter identifies the\n     *   content encryption algorithm used to perform authenticated encryption\n     *   on the plaintext to produce the ciphertext and the Authentication\n     *   Tag.  This algorithm MUST be an AEAD algorithm with a specified key\n     *   length.  The encrypted content is not usable if the \"enc\" value does\n     *   not represent a supported algorithm.  \"enc\" values should either be\n     *   registered in the IANA \"JSON Web Signature and Encryption Algorithms\"\n     *   registry established by [JWA] or be a value that contains a\n     *   Collision-Resistant Name.  The \"enc\" value is a case-sensitive ASCII\n     *   string containing a StringOrURI value.  This Header Parameter MUST be\n     *   present and MUST be understood and processed by implementations.\n     *\n     *   A list of defined \"enc\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 5.1 of [JWA].\n     */\n    enc: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * zip\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.3\n     *\n     * 4.1.3.  \"zip\" (Compression Algorithm) Header Parameter\n     *\n     *   The \"zip\" (compression algorithm) applied to the plaintext before\n     *   encryption, if any.  The \"zip\" value defined by this specification\n     *   is:\n     *\n     *   o  \"DEF\" - Compression with the DEFLATE [RFC1951] algorithm\n     *\n     *   Other values MAY be used.  Compression algorithm values can be\n     *   registered in the IANA \"JSON Web Encryption Compression Algorithms\"\n     *   registry established by [JWA].  The \"zip\" value is a case-sensitive\n     *   string.  If no \"zip\" parameter is present, no compression is applied\n     *   to the plaintext before encryption.  When used, this Header Parameter\n     *   MUST be integrity protected; therefore, it MUST occur only within the\n     *   JWE Protected Header.  Use of this Header Parameter is OPTIONAL.\n     *   This Header Parameter MUST be understood and processed by\n     *   implementations.\n     */\n    zip: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JOSEHeaderSchema;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(39);\nvar JWA = __webpack_require__(38);\n\nvar _require = __webpack_require__(55),\n    DataError = _require.DataError;\n\n/**\n * JWS\n */\n\n\nvar JWS = function () {\n  function JWS() {\n    _classCallCheck(this, JWS);\n  }\n\n  _createClass(JWS, null, [{\n    key: 'sign',\n\n\n    /**\n     * sign\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @param {Object} token\n     * @returns {Promise}\n     */\n    value: function sign(token) {\n      var payload = base64url(JSON.stringify(token.payload));\n\n      // compact serialization\n      if (token.serialization === 'compact') {\n        var key = token.key,\n            alg = token.header.alg;\n\n        var header = base64url(JSON.stringify(token.header));\n        var data = header + '.' + payload;\n\n        return JWA.sign(alg, key, data).then(function (signature) {\n          return data + '.' + signature;\n        });\n      }\n\n      // JSON serialization\n      if (token.serialization === 'json') {}\n\n      // Flattened serialization\n      if (token.serialization === 'flattened') {}\n\n      return Promise.reject(new DataError('Unsupported serialization'));\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(jwt) {\n      // multiple signatures\n      if (jwt.signatures) {\n        // ...\n      }\n\n      var key = jwt.key,\n          signature = jwt.signature,\n          alg = jwt.header.alg;\n\n      // one signature\n\n      if (jwt.signature) {\n        var _jwt$segments = _slicedToArray(jwt.segments, 2),\n            header = _jwt$segments[0],\n            payload = _jwt$segments[1];\n\n        var data = header + '.' + payload;\n\n        if (alg === 'none') {\n          return Promise.reject(new DataError('Signature provided to verify with alg: none'));\n        }\n\n        return JWA.verify(alg, key, signature, data).then(function (verified) {\n          jwt.verified = verified;\n          return verified;\n        });\n      }\n\n      if (alg === 'none') {\n        if (!key && !signature) {\n          jwt.verified = true;\n\n          return Promise.resolve(true);\n        }\n\n        if (key) {\n          return Promise.reject(new DataError('Key provided to verify signature with alg: none'));\n        }\n      }\n\n      // no signatures to verify\n      return Promise.reject(new DataError('Missing signature(s)'));\n    }\n  }]);\n\n  return JWS;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWS;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Buffer) {/**\n * Dependencies\n */\nconst assert = __webpack_require__(21);\n\nconst base64url = __webpack_require__(39);\n\nconst crypto = __webpack_require__(49);\n\nconst {\n  JWT\n} = __webpack_require__(37);\n\nconst FormUrlEncoded = __webpack_require__(69);\n\nconst {\n  URL\n} = __webpack_require__(27);\n/**\n * Authentication Request\n */\n\n\nclass AuthenticationRequest {\n  /**\n   * create\n   *\n   * @description\n   * Create a new authentication request with generated state and nonce,\n   * validate presence of required parameters, serialize the request data and\n   * persist it to the session, and return a promise for an authentication\n   * request URI.\n   *\n   * @param {RelyingParty} rp  instance of RelyingParty\n   * @param {Object} options - optional request parameters\n   * @param {Object} session  reference to localStorage or other session object\n   *\n   * @returns {Promise}\n   */\n  static create(rp, options, session) {\n    const {\n      provider,\n      defaults,\n      registration\n    } = rp;\n    let issuer, endpoint, client, params;\n    return Promise.resolve().then(() => {\n      // validate presence of OP configuration, RP client registration,\n      // and default parameters\n      assert(provider.configuration, 'RelyingParty provider OpenID Configuration is missing');\n      assert(defaults.authenticate, 'RelyingParty default authentication parameters are missing');\n      assert(registration, 'RelyingParty client registration is missing'); // define basic elements of the request\n\n      issuer = provider.configuration.issuer;\n      endpoint = provider.configuration.authorization_endpoint;\n      client = {\n        client_id: registration.client_id\n      };\n      params = Object.assign(defaults.authenticate, client, options); // validate presence of required configuration and parameters\n\n      assert(issuer, 'Missing issuer in provider OpenID Configuration');\n      assert(endpoint, 'Missing authorization_endpoint in provider OpenID Configuration');\n      assert(params.scope, 'Missing scope parameter in authentication request');\n      assert(params.response_type, 'Missing response_type parameter in authentication request');\n      assert(params.client_id, 'Missing client_id parameter in authentication request');\n      assert(params.redirect_uri, 'Missing redirect_uri parameter in authentication request'); // generate state and nonce random octets\n\n      params.state = Array.from(crypto.getRandomValues(new Uint8Array(16)));\n      params.nonce = Array.from(crypto.getRandomValues(new Uint8Array(16))); // hash the state and nonce parameter values\n\n      return Promise.all([crypto.subtle.digest({\n        name: 'SHA-256'\n      }, new Uint8Array(params.state)), crypto.subtle.digest({\n        name: 'SHA-256'\n      }, new Uint8Array(params.nonce))]);\n    }) // serialize the request with original values, store in session by\n    // encoded state param, and replace state/nonce octets with encoded\n    // digests\n    .then(digests => {\n      let state = base64url(Buffer.from(digests[0]));\n      let nonce = base64url(Buffer.from(digests[1]));\n      let key = `${issuer}/requestHistory/${state}`; // store the request params for response validation\n      // with serialized octet values for state and nonce\n\n      session[key] = JSON.stringify(params); // replace state and nonce octets with base64url encoded digests\n\n      params.state = state;\n      params.nonce = nonce;\n    }).then(() => AuthenticationRequest.generateSessionKeys()).then(sessionKeys => {\n      AuthenticationRequest.storeSessionKeys(sessionKeys, params, session);\n    }) // optionally encode a JWT with the request parameters\n    // and replace params with `{ request: <jwt> }\n    .then(() => {\n      if (provider.configuration.request_parameter_supported) {\n        return AuthenticationRequest.encodeRequestParams(params).then(encodedParams => {\n          params = encodedParams;\n        });\n      }\n    }) // render the request URI and terminate the algorithm\n    .then(() => {\n      let url = new URL(endpoint);\n      url.search = FormUrlEncoded.encode(params);\n      return url.href;\n    });\n  }\n\n  static generateSessionKeys() {\n    return crypto.subtle.generateKey({\n      name: \"RSASSA-PKCS1-v1_5\",\n      modulusLength: 2048,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: {\n        name: \"SHA-256\"\n      }\n    }, true, [\"sign\", \"verify\"]).then(keyPair => {\n      // returns a keypair object\n      return Promise.all([crypto.subtle.exportKey('jwk', keyPair.publicKey), crypto.subtle.exportKey('jwk', keyPair.privateKey)]);\n    }).then(jwkPair => {\n      let [publicJwk, privateJwk] = jwkPair;\n      return {\n        public: publicJwk,\n        private: privateJwk\n      };\n    });\n  }\n\n  static storeSessionKeys(sessionKeys, params, session) {\n    // store the private one in session, public one goes into params\n    session['oidc.session.privateKey'] = JSON.stringify(sessionKeys.private);\n    params.key = sessionKeys.public;\n  }\n\n  static encodeRequestParams(params) {\n    const excludeParams = ['scope', 'client_id', 'response_type', 'state'];\n    const keysToEncode = Object.keys(params).filter(key => !excludeParams.includes(key));\n    let payload = {};\n    keysToEncode.forEach(key => {\n      payload[key] = params[key];\n    });\n    let requestParamJwt = new JWT({\n      header: {\n        alg: 'none'\n      },\n      payload\n    }, {\n      filter: false\n    });\n    return requestParamJwt.encode().then(requestParamCompact => {\n      let newParams = {\n        scope: params['scope'],\n        client_id: params['client_id'],\n        response_type: params['response_type'],\n        request: requestParamCompact,\n        state: params['state']\n      };\n      return newParams;\n    });\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = AuthenticationRequest;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports) {\n\n/**\n * Dependencies\n */\n\n/**\n * FormUrlEncoded\n */\nclass FormUrlEncoded {\n  /**\n   * Encode\n   *\n   * @description\n   * Represent an object as x-www-form-urlencoded string.\n   *\n   * @param {Object} data\n   * @returns {string}\n   */\n  static encode(data) {\n    let pairs = [];\n    Object.keys(data).forEach(function (key) {\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));\n    });\n    return pairs.join('&');\n  }\n  /**\n   * Decode\n   *\n   * @description\n   * Parse a x-www-form-urlencoded into an object.\n   *\n   * @param {string} data\n   * @returns {Object}\n   */\n\n\n  static decode(data) {\n    let obj = {};\n    data.split('&').forEach(function (property) {\n      let pair = property.split('=');\n      let key = decodeURIComponent(pair[0]);\n      let val = decodeURIComponent(pair[1]);\n      obj[key] = val;\n    });\n    return obj;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = FormUrlEncoded;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, Buffer) {/**\n * Dependencies\n */\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst assert = __webpack_require__(21);\n\nconst crypto = __webpack_require__(49);\n\nconst base64url = __webpack_require__(39);\n\nconst fetch = __webpack_require__(5);\n\nconst Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nconst FormUrlEncoded = __webpack_require__(69);\n\nconst IDToken = __webpack_require__(71);\n\nconst Session = __webpack_require__(73);\n\nconst onHttpError = __webpack_require__(74);\n\nconst HttpError = __webpack_require__(76);\n/**\n * AuthenticationResponse\n */\n\n\nclass AuthenticationResponse {\n  /**\n   * @param rp {RelyingParty}\n   * @param [redirect] {string} req.query\n   * @param [body] {string} req.body.text\n   * @param session {Session|Storage} req.session or localStorage or similar\n   * @param params {object} hashmap\n   * @param mode {string} 'query'/'fragment'/'form_post',\n   *   determined in `parseResponse()`\n   */\n  constructor({\n    rp,\n    redirect,\n    body,\n    session,\n    mode,\n    params = {}\n  }) {\n    this.rp = rp;\n    this.redirect = redirect;\n    this.body = body;\n    this.session = session;\n    this.mode = mode;\n    this.params = params;\n  }\n  /**\n   * validateResponse\n   *\n   * @description\n   * Authentication response validation.\n   *\n   * @param {string|Object} response\n   *\n   * @returns {Promise<Session>}\n   */\n\n\n  static validateResponse(response) {\n    return Promise.resolve(response).then(this.parseResponse).then(this.errorResponse).then(this.matchRequest).then(this.validateStateParam).then(this.validateResponseMode).then(this.validateResponseParams).then(this.exchangeAuthorizationCode).then(this.validateIDToken).then(Session.fromAuthResponse);\n  }\n  /**\n   * parseResponse\n   *\n   * @param {object} response\n   *\n   * @returns {object}\n   */\n\n\n  static parseResponse(response) {\n    let {\n      redirect,\n      body\n    } = response; // response must be either a redirect uri or request body, but not both\n\n    if (redirect && body || !redirect && !body) {\n      throw new HttpError(400, 'Invalid response mode');\n    } // parse redirect uri\n\n\n    if (redirect) {\n      let url = new URL(redirect);\n      let {\n        search,\n        hash\n      } = url;\n\n      if (search && hash || !search && !hash) {\n        throw new HttpError(400, 'Invalid response mode');\n      }\n\n      if (search) {\n        response.params = FormUrlEncoded.decode(search.substring(1));\n        response.mode = 'query';\n      }\n\n      if (hash) {\n        response.params = FormUrlEncoded.decode(hash.substring(1));\n        response.mode = 'fragment';\n      }\n    } // parse request form body\n\n\n    if (body) {\n      response.params = FormUrlEncoded.decode(body);\n      response.mode = 'form_post';\n    }\n\n    return response;\n  }\n  /**\n   * errorResponse\n   *\n   * @param {AuthenticationResponse} response\n   *\n   * @throws {Error} If response params include the OAuth2 'error' param,\n   *   throws an error based on it.\n   *\n   * @returns {AuthenticationResponse} Chainable\n   *\n   * @todo Figure out HTTP status code (typically 400, 401 or 403)\n   *   based on the OAuth2/OIDC `error` code, probably using an external library\n   */\n\n\n  static errorResponse(response) {\n    const errorCode = response.params.error;\n\n    if (errorCode) {\n      const errorParams = {};\n      errorParams['error'] = errorCode;\n      errorParams['error_description'] = response.params['error_description'];\n      errorParams['error_uri'] = response.params['error_uri'];\n      errorParams['state'] = response.params['state'];\n      const error = new Error(`AuthenticationResponse error: ${errorCode}`);\n      error.info = errorParams;\n      throw error;\n    }\n\n    return response;\n  }\n  /**\n   * matchRequest\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static matchRequest(response) {\n    let {\n      rp,\n      params,\n      session\n    } = response;\n    let state = params.state;\n    let issuer = rp.provider.configuration.issuer;\n\n    if (!state) {\n      throw new Error('Missing state parameter in authentication response');\n    }\n\n    let key = `${issuer}/requestHistory/${state}`;\n    let request = session[key];\n\n    if (!request) {\n      throw new Error('Mismatching state parameter in authentication response');\n    }\n\n    response.request = JSON.parse(request);\n    return response;\n  }\n  /**\n   * validateStateParam\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateStateParam(response) {\n    let octets = new Uint8Array(response.request.state);\n    let encoded = response.params.state;\n    return crypto.subtle.digest({\n      name: 'SHA-256'\n    }, octets).then(digest => {\n      if (encoded !== base64url(Buffer.from(digest))) {\n        throw new Error('Mismatching state parameter in authentication response');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateResponseMode\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateResponseMode(response) {\n    if (response.request.response_type !== 'code' && response.mode === 'query') {\n      throw new Error('Invalid response mode');\n    }\n\n    return response;\n  }\n  /**\n   * validateResponseParams\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateResponseParams(response) {\n    let {\n      request,\n      params\n    } = response;\n    let expectedParams = request.response_type.split(' ');\n\n    if (expectedParams.includes('code')) {\n      assert(params.code, 'Missing authorization code in authentication response'); // TODO assert novelty of code\n    }\n\n    if (expectedParams.includes('id_token')) {\n      assert(params.id_token, 'Missing id_token in authentication response');\n    }\n\n    if (expectedParams.includes('token')) {\n      assert(params.access_token, 'Missing access_token in authentication response');\n      assert(params.token_type, 'Missing token_type in authentication response');\n    }\n\n    return response;\n  }\n  /**\n   * exchangeAuthorizationCode\n   *\n   * @param {Object} response\n   * @returns {Promise} response object\n   */\n\n\n  static exchangeAuthorizationCode(response) {\n    let {\n      rp,\n      params,\n      request\n    } = response;\n    let code = params.code; // only exchange the authorization code when the response type is \"code\"\n\n    if (!code || request['response_type'] !== 'code') {\n      return Promise.resolve(response);\n    }\n\n    let {\n      provider,\n      registration\n    } = rp;\n    let id = registration['client_id'];\n    let secret = registration['client_secret']; // verify the client is not public\n\n    if (!secret) {\n      return Promise.reject(new Error('Client cannot exchange authorization code because ' + 'it is not a confidential client'));\n    } // initialize token request arguments\n\n\n    let endpoint = provider.configuration.token_endpoint;\n    let method = 'POST'; // initialize headers\n\n    let headers = new Headers({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }); // initialize the token request parameters\n\n    let bodyContents = {\n      'grant_type': 'authorization_code',\n      'code': code,\n      'redirect_uri': request['redirect_uri'] // determine client authentication method\n\n    };\n    let authMethod = registration['token_endpoint_auth_method'] || 'client_secret_basic'; // client secret basic authentication\n\n    if (authMethod === 'client_secret_basic') {\n      let credentials = new Buffer(`${id}:${secret}`).toString('base64');\n      headers.set('Authorization', `Basic ${credentials}`);\n    } // client secret post authentication\n\n\n    if (authMethod === 'client_secret_post') {\n      bodyContents['client_id'] = id;\n      bodyContents['client_secret'] = secret;\n    }\n\n    let body = FormUrlEncoded.encode(bodyContents); // TODO\n    // client_secret_jwt authentication\n    // private_key_jwt\n    // make the token request\n\n    return fetch(endpoint, {\n      method,\n      headers,\n      body\n    }).then(onHttpError('Error exchanging authorization code')).then(tokenResponse => tokenResponse.json()).then(tokenResponse => {\n      assert(tokenResponse['access_token'], 'Missing access_token in token response');\n      assert(tokenResponse['token_type'], 'Missing token_type in token response');\n      assert(tokenResponse['id_token'], 'Missing id_token in token response'); // anything else?\n      // IS THIS THE RIGHT THING TO DO HERE?\n\n      response.params = Object.assign(response.params, tokenResponse);\n      return response;\n    });\n  }\n  /**\n   * validateIDToken\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateIDToken(response) {\n    // only validate the ID Token if present in the response\n    if (!response.params.id_token) {\n      return Promise.resolve(response);\n    }\n\n    return Promise.resolve(response).then(AuthenticationResponse.decryptIDToken).then(AuthenticationResponse.decodeIDToken).then(AuthenticationResponse.validateIssuer).then(AuthenticationResponse.validateAudience).then(AuthenticationResponse.resolveKeys).then(AuthenticationResponse.verifySignature).then(AuthenticationResponse.validateExpires).then(AuthenticationResponse.verifyNonce).then(AuthenticationResponse.validateAcr).then(AuthenticationResponse.validateAuthTime).then(AuthenticationResponse.validateAccessTokenHash).then(AuthenticationResponse.validateAuthorizationCodeHash);\n  }\n  /**\n   * decryptIDToken\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static decryptIDToken(response) {\n    // TODO\n    return Promise.resolve(response);\n  }\n  /**\n   * decodeIDToken\n   *\n   * Note: If the `id_token` is not present in params, this method does not\n   * get called (short-circuited in `validateIDToken()`).\n   *\n   * @param response {AuthenticationResponse}\n   * @param response.params {object}\n   * @param [response.params.id_token] {string} IDToken encoded as a JWT\n   *\n   * @returns {AuthenticationResponse} Chainable\n   */\n\n\n  static decodeIDToken(response) {\n    let jwt = response.params.id_token;\n\n    try {\n      response.decoded = IDToken.decode(jwt);\n    } catch (decodeError) {\n      const error = new HttpError(400, 'Error decoding ID Token');\n      error.cause = decodeError;\n      error.info = {\n        id_token: jwt\n      };\n      throw error;\n    }\n\n    return response;\n  }\n  /**\n   * validateIssuer\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateIssuer(response) {\n    let configuration = response.rp.provider.configuration;\n    let payload = response.decoded.payload; // validate issuer of token matches this relying party's provider\n\n    if (payload.iss !== configuration.issuer) {\n      throw new Error('Mismatching issuer in ID Token');\n    }\n\n    return response;\n  }\n  /**\n   * validateAudience\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAudience(response) {\n    let registration = response.rp.registration;\n    let {\n      aud,\n      azp\n    } = response.decoded.payload; // validate audience includes this relying party\n\n    if (typeof aud === 'string' && aud !== registration['client_id']) {\n      throw new Error('Mismatching audience in id_token');\n    } // validate audience includes this relying party\n\n\n    if (Array.isArray(aud) && !aud.includes(registration['client_id'])) {\n      throw new Error('Mismatching audience in id_token');\n    } // validate authorized party is present if required\n\n\n    if (Array.isArray(aud) && !azp) {\n      throw new Error('Missing azp claim in id_token');\n    } // validate authorized party is this relying party\n\n\n    if (azp && azp !== registration['client_id']) {\n      throw new Error('Mismatching azp claim in id_token');\n    }\n\n    return response;\n  }\n  /**\n   * resolveKeys\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static resolveKeys(response) {\n    let rp = response.rp;\n    let provider = rp.provider;\n    let decoded = response.decoded;\n    return Promise.resolve(provider.jwks).then(jwks => jwks ? jwks : rp.jwks()).then(jwks => {\n      if (decoded.resolveKeys(jwks)) {\n        return Promise.resolve(response);\n      } else {\n        throw new Error('Cannot resolve signing key for ID Token');\n      }\n    });\n  }\n  /**\n   * verifySignature\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static verifySignature(response) {\n    let alg = response.decoded.header.alg;\n    let registration = response.rp.registration;\n    let expectedAlgorithm = registration['id_token_signed_response_alg'] || 'RS256'; // validate signing algorithm matches expectation\n\n    if (alg !== expectedAlgorithm) {\n      throw new Error(`Expected ID Token to be signed with ${expectedAlgorithm}`);\n    }\n\n    return response.decoded.verify().then(verified => {\n      if (!verified) {\n        throw new Error('Invalid ID Token signature');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateExpires\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateExpires(response) {\n    let exp = response.decoded.payload.exp; // validate expiration of token\n\n    if (exp <= Math.floor(Date.now() / 1000)) {\n      throw new Error('Expired ID Token');\n    }\n\n    return response;\n  }\n  /**\n   * verifyNonce\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static verifyNonce(response) {\n    let octets = new Uint8Array(response.request.nonce);\n    let nonce = response.decoded.payload.nonce;\n\n    if (!nonce) {\n      throw new Error('Missing nonce in ID Token');\n    }\n\n    return crypto.subtle.digest({\n      name: 'SHA-256'\n    }, octets).then(digest => {\n      if (nonce !== base64url(Buffer.from(digest))) {\n        throw new Error('Mismatching nonce in ID Token');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateAcr\n   *\n   * @param {Object} response\n   * @returns {Object}\n   */\n\n\n  static validateAcr(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAuthTime\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAuthTime(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAccessTokenHash\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAccessTokenHash(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAuthorizationCodeHash\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAuthorizationCodeHash(response) {\n    // TODO\n    return response;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = AuthenticationResponse;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20), __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Local dependencies\n */\nconst {\n  JWT\n} = __webpack_require__(37);\n\nconst IDTokenSchema = __webpack_require__(72);\n/**\n * IDToken\n */\n\n\nclass IDToken extends JWT {\n  /**\n   * Schema\n   */\n  static get schema() {\n    return IDTokenSchema;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = IDToken;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Local dependencies\n */\nconst {\n  JWTSchema\n} = __webpack_require__(37);\n/**\n * IDToken Schema\n */\n\n\nconst IDTokenSchema = JWTSchema.extend({\n  properties: {\n    /**\n     * header\n     * http://openid.net/specs/openid-connect-core-1_0.html#IDToken\n     * ID Tokens SHOULD NOT use the JWS or JWE x5u, x5c, jku, or jwk Header\n     * Parameter fields. Instead, references to keys used are communicated in\n     * advance using Discovery and Registration parameters, per Section 10.\n     */\n    header: {//not: { required: ['x5u', 'x5c', 'jku', 'jwk'] }\n    },\n\n    /**\n     * payload\n     */\n    payload: {\n      properties: {\n        /**\n         * iss\n         *\n         * REQUIRED. Issuer Identifier for the Issuer of the response.\n         * The iss value is a case sensitive URL using the https scheme\n         * that contains scheme, host, and optionally, port number and\n         * path components and no query or fragment components.\n         */\n        iss: {\n          type: 'string',\n          format: 'url'\n        },\n\n        /**\n         * sub\n         *\n         * REQUIRED. Subject Identifier. A locally unique and never\n         * reassigned identifier within the Issuer for the End-User, which\n         * is intended to be consumed by the Client, e.g., 24400320 or\n         * AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed 255\n         * ASCII characters in length. The sub value is a case sensitive\n         * string.\n         */\n        sub: {\n          type: 'string',\n          maxLength: 255\n        },\n\n        /**\n         * aud\n         *\n         * REQUIRED. Audience(s) that this ID Token is intended for. It\n         * MUST contain the OAuth 2.0 client_id of the Relying Party as an\n         * audience value. It MAY also contain identifiers for other audiences.\n         * In the general case, the aud value is an array of case sensitive\n         * strings. In the common special case when there is one audience,\n         * the aud value MAY be a single case sensitive string.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * exp\n         *\n         * REQUIRED. Expiration time on or after which the ID Token MUST NOT\n         * be accepted for processing. The processing of this parameter\n         * requires that the current date/time MUST be before the expiration\n         * date/time listed in the value. Implementers MAY provide for some\n         * small leeway, usually no more than a few minutes, to account for\n         * clock skew. Its value is a JSON number representing the number of\n         * seconds from 1970-01-01T0:0:0Z as measured in UTC until the\n         * date/time. See RFC 3339 [RFC3339] for details regarding date/times\n         * in general and UTC in particular.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * iat\n         *\n         * REQUIRED. Time at which the JWT was issued. Its value is a\n         * JSON number representing the number of seconds from\n         * 1970-01-01T0:0:0Z as measured in UTC until the date/time.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * auth_time\n         *\n         * Time when the End-User authentication occurred. Its value is a\n         * JSON number representing the number of seconds from\n         * 1970-01-01T0:0:0Z as measured in UTC until the date/time. When a\n         * max_age request is made or when auth_time is requested as an\n         * Essential Claim, then this Claim is REQUIRED; otherwise, its\n         * inclusion is OPTIONAL. (The auth_time Claim semantically\n         * corresponds to the OpenID 2.0 PAPE [OpenID.PAPE] auth_time\n         * response parameter.)\n         */\n        auth_time: {\n          type: 'integer',\n          format: 'NumericDate'\n        },\n\n        /**\n         * nonce\n         *\n         * String value used to associate a Client session with an ID Token,\n         * and to mitigate replay attacks. The value is passed through\n         * unmodified from the Authentication Request to the ID Token. If\n         * present in the ID Token, Clients MUST verify that the nonce Claim\n         * Value is equal to the value of the nonce parameter sent in the\n         * Authentication Request. If present in the Authentication Request,\n         * Authorization Servers MUST include a nonce Claim in the ID Token\n         * with the Claim Value being the nonce value sent in the\n         * Authentication Request. Authorization Servers SHOULD perform no\n         * other processing on nonce values used. The nonce value is a case\n         * sensitive string.\n         */\n        nonce: {\n          type: 'string'\n        },\n\n        /**\n         * acr\n         *\n         * OPTIONAL. Authentication Context Class Reference. String\n         * specifying an Authentication Context Class Reference value that\n         * identifies the Authentication Context Class that the authentication\n         * performed satisfied. The value \"0\" indicates the End-User\n         * authentication did not meet the requirements of ISO/IEC 29115\n         * [ISO29115] level 1. Authentication using a long-lived browser\n         * cookie, for instance, is one example where the use of \"level 0\" is\n         * appropriate. Authentications with level 0 SHOULD NOT be used to\n         * authorize access to any resource of any monetary value. (This\n         * corresponds to the OpenID 2.0 PAPE [OpenID.PAPE] nist_auth_level\n         * 0.) An absolute URI or an RFC 6711 [RFC6711] registered name\n         * SHOULD be used as the acr value; registered names MUST NOT be used\n         * with a different meaning than that which is registered. Parties\n         * using this claim will need to agree upon the meanings of the\n         * values used, which may be context-specific. The acr value is a\n         * case sensitive string.\n         */\n        acr: {\n          type: 'string'\n        },\n\n        /**\n         * amr\n         * OPTIONAL. Authentication Methods References. JSON array of strings\n         * that are identifiers for authentication methods used in the\n         * authentication. For instance, values might indicate that both\n         * password and OTP authentication methods were used. The definition\n         * of particular values to be used in the amr Claim is beyond the\n         * scope of this specification. Parties using this claim will need to\n         * agree upon the meanings of the values used, which may be context-\n         * specific. The amr value is an array of case sensitive strings.\n         */\n        amr: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n\n        /**\n         * azp\n         * OPTIONAL. Authorized party - the party to which the ID Token was\n         * issued. If present, it MUST contain the OAuth 2.0 Client ID of this\n         * party. This Claim is only needed when the ID Token has a single\n         * audience value and that audience is different than the authorized\n         * party. It MAY be included even when the authorized party is the\n         * same as the sole audience. The azp value is a case sensitive string\n         * containing a StringOrURI value.\n         */\n        azp: {\n          type: 'string',\n          format: 'StringOrURI'\n        }\n      },\n\n      /**\n       * Required Claims\n       */\n      required: ['iss', 'sub', 'aud', 'exp', 'iat']\n    }\n  }\n});\n/**\n * Export\n */\n\nmodule.exports = IDTokenSchema;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nconst fetch = __webpack_require__(5);\n\nconst onHttpError = __webpack_require__(74);\n\nconst PoPToken = __webpack_require__(75);\n\nclass Session {\n  /**\n   * @param options {Object}\n   *\n   * @param options.credentialType {string} 'access_token' or 'pop_token'\n   *\n   * @param options.issuer {string} Identity provider (issuer of ID/Access Token)\n   *\n   * @param options.authorization {object}\n   * @param options.authorization.client_id {string} OIDC/OAuth2 client id\n   * @param [options.authorization.id_token] {string} Compact-serialized id_token param\n   * @param [options.authorization.access_token] {string} Compact-serialized access_token param\n   * @param [options.authorization.refresh_token] {string} Compact-serialized refresh_token\n   *\n   * @param [options.sessionKey] {string} Serialized client session key generated\n   *   during the Authentication Request, used to issue PoPTokens\n   *\n   * @param [options.idClaims] {object} Decoded/verified ID Token JWT payload\n   *\n   * @param [options.accessClaims] {object} Decoded/verified Access Token JWT payload\n   */\n  constructor(options) {\n    this.credentialType = options.credentialType || 'access_token';\n    this.issuer = options.issuer;\n    this.authorization = options.authorization || {};\n    this.sessionKey = options.sessionKey;\n    this.idClaims = options.idClaims;\n    this.accessClaims = options.accessClaims;\n  }\n\n  static from(options) {\n    return new Session(options);\n  }\n  /**\n   * @param response {AuthenticationResponse}\n   *\n   * @returns {Session} RelyingParty Session object\n   */\n\n\n  static fromAuthResponse(response) {\n    const RelyingParty = __webpack_require__(19); // import here due to circular dep\n\n\n    let idClaims = response.decoded && response.decoded.payload || {};\n    let {\n      rp\n    } = response;\n    let registration = rp.registration;\n    let rpAuthOptions = rp.defaults.authenticate || {};\n    let credentialType = rpAuthOptions['credential_type'] || rp.defaults.popToken ? 'pop_token' : 'access_token';\n    let sessionKey = response.session[RelyingParty.SESSION_PRIVATE_KEY];\n    let options = {\n      credentialType,\n      sessionKey,\n      issuer: idClaims.iss,\n      idClaims,\n      authorization: {\n        client_id: registration['client_id'],\n        access_token: response.params['access_token'],\n        id_token: response.params['id_token'],\n        refresh_token: response.params['refresh_token']\n      }\n    };\n    return Session.from(options);\n  }\n  /**\n   * Authenticated fetch() getter\n   *\n   * @returns {function}\n   */\n\n\n  get fetch() {\n    /**\n     * fetch() function signature\n     *\n     * @param url {RequestInfo|string}\n     * @param options {object}\n     *\n     * @returns {Function<Promise<Response>>}\n     */\n    return (url, options) => {\n      return Promise.resolve().then(() => {\n        if (this.hasCredentials()) {\n          return this.fetchWithCredentials(url, options);\n        } else {\n          return fetch(url, options);\n        }\n      }).then(onHttpError('Error while fetching resource'));\n    };\n  }\n  /**\n   * bearerTokenFor\n   *\n   * @param url {string}\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  bearerTokenFor(url) {\n    switch (this.credentialType) {\n      case 'pop_token':\n        return PoPToken.issueFor(url, this);\n\n      default:\n        // 'access_token' etc\n        return Promise.resolve(this.authorization[this.credentialType]);\n    }\n  }\n  /**\n   * hasCredentials\n   *\n   * @returns {boolean}\n   */\n\n\n  hasCredentials() {\n    switch (this.credentialType) {\n      case 'pop_token':\n        return !!this.authorization['id_token'];\n\n      default:\n        // 'access_token' etc\n        return !!this.authorization[this.credentialType];\n    }\n  }\n  /**\n   * fetchWithCredentials\n   *\n   * @param url {RequestInfo|string}\n   * @param options {object}\n   *\n   * @returns {Promise<Response>}\n   */\n\n\n  fetchWithCredentials(url, options = {}) {\n    options.headers = options.headers || {};\n    return this.bearerTokenFor(url).then(token => {\n      options.headers.authorization = `Bearer ${token}`;\n      return fetch(url, options);\n    });\n  }\n\n}\n\nmodule.exports = Session;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Throws an error when a fetch response status code indicates a 400 or 500\n * HTTP error. (The whatwg fetch api does not normally reject on http error\n * responses).\n *\n * Usage:\n *\n * ```\n * return fetch(url)\n *   .then(onHttpError('Error while fetching resource')\n *   .catch(err => console.log(err))\n *\n * // -> 'Error while fetching resource: 404 Not Found' error\n * // if a 404 response is encountered\n * ```\n *\n * @param [message] {string} Optional error message to clarify context\n *\n * @throws {Error} For http status codes > 300\n *\n * @return {Object} fetch response object (passed through if no error)\n */\n\nfunction onHttpError(message = 'fetch error') {\n  return response => {\n    if (response.status >= 200 && response.status < 300) {\n      return response;\n    }\n\n    let errorMessage = `${message}: ${response.status} ${response.statusText}`;\n    let error = new Error(errorMessage);\n    error.response = response;\n    error.statusCode = response.status;\n    throw error;\n  };\n}\n\nmodule.exports = onHttpError;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst {\n  JWT,\n  JWK\n} = __webpack_require__(37);\n\nconst DEFAULT_MAX_AGE = 3600; // Default token expiration, in seconds\n\nclass PoPToken extends JWT {\n  /**\n   * @param resourceServerUri {string} RS URI for which this token is intended\n   *\n   * @param session {Session}\n   * @param session.sessionKey {string}\n   * @param session.authorization.client_id {string}\n   * @param session.authorization.id_token {string}\n   *\n   * @returns {Promise<string>} PoPToken, encoded as compact JWT\n   */\n  static issueFor(resourceServerUri, session) {\n    if (!resourceServerUri) {\n      throw new Error('Cannot issue PoPToken - missing resource server URI');\n    }\n\n    if (!session.sessionKey) {\n      throw new Error('Cannot issue PoPToken - missing session key');\n    }\n\n    if (!session.authorization.id_token) {\n      throw new Error('Cannot issue PoPToken - missing id token');\n    }\n\n    let jwk = JSON.parse(session.sessionKey);\n    return JWK.importKey(jwk).then(importedSessionJwk => {\n      let options = {\n        aud: new URL(resourceServerUri).origin,\n        key: importedSessionJwk,\n        iss: session.authorization.client_id,\n        id_token: session.authorization.id_token\n      };\n      return PoPToken.issue(options);\n    }).then(jwt => {\n      return jwt.encode();\n    });\n  }\n  /**\n   * issue\n   *\n   * @param options {Object}\n   * @param options.iss {string} Token issuer (RP client_id)\n   * @param options.aud {string|Array<string>} Audience for the token\n   *   (such as the Resource Server url)\n   * @param options.key {JWK} Proof of Possession (private) signing key, see\n   *   https://tools.ietf.org/html/rfc7800#section-3.1\n   *\n   * @param options.id_token {string} JWT compact encoded ID Token\n   *\n   * Optional:\n   * @param [options.iat] {number} Issued at timestamp (in seconds)\n   * @param [options.max] {number} Max token lifetime in seconds\n   *\n   * @returns {PoPToken} Proof of Possession Token (JWT instance)\n   */\n\n\n  static issue(options) {\n    let {\n      aud,\n      iss,\n      key\n    } = options;\n    let alg = key.alg;\n    let iat = options.iat || Math.floor(Date.now() / 1000);\n    let max = options.max || DEFAULT_MAX_AGE;\n    let exp = iat + max; // token expiration\n\n    let header = {\n      alg\n    };\n    let payload = {\n      iss,\n      aud,\n      exp,\n      iat,\n      id_token: options.id_token,\n      token_type: 'pop'\n    };\n    let jwt = new PoPToken({\n      header,\n      payload,\n      key: key.cryptoKey\n    }, {\n      filter: false\n    });\n    return jwt;\n  }\n\n}\n\nmodule.exports = PoPToken;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = HttpError\nvar StandardError = __webpack_require__(77)\nvar STATUS_CODE_TO_NAME = __webpack_require__(78)\nvar STATUS_NAME_TO_CODE = exports\n\nfunction HttpError(code, msg, props) {\n  if (typeof code == \"string\") code = STATUS_NAME_TO_CODE[code]\n  if (typeof code != \"number\") throw new TypeError(\"Non-numeric HTTP code\")\n  if (typeof msg == \"object\" && msg != null) { props = msg; msg = null }\n  StandardError.call(this, msg || STATUS_CODE_TO_NAME[code], props)\n  this.code = code\n}\n\nHttpError.prototype = Object.create(StandardError.prototype, {\n  constructor: {value: HttpError, configurable: true, writable: true}\n})\n\n// Set name explicitly for when the code gets minified.\nHttpError.prototype.name = \"HttpError\"\n\nObject.defineProperties(HttpError.prototype, {\n  statusCode: alias(\"code\"),\n  statusMessage: alias(\"message\"),\n\n  status: {\n    configurable: true,\n    get: function() { return this.code },\n    set: function(value) {\n      Object.defineProperty(this, \"status\", {\n        value: value, configurable: true, enumerable: true, writable: true\n      })\n    }\n  }\n})\n\nHttpError.prototype.toString = function() {\n  return this.name + \": \" + this.code + \" \" + this.message\n}\n\nfor (var code in STATUS_CODE_TO_NAME) {\n  var name = STATUS_CODE_TO_NAME[code]\n  exports[name.replace(\"'\", \"\").replace(/[- ]/g, \"_\").toUpperCase()] = +code\n}\n\nfunction alias(name) {\n  return {\n    configurable: true,\n    get: function() { return this[name] },\n    set: function(value) { return this[name] = value }\n  }\n}\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports) {\n\nvar has = Object.hasOwnProperty\nvar proto = Object.getPrototypeOf\nvar trace = Error.captureStackTrace\nmodule.exports = StandardError\n\nfunction StandardError(msg, props) {\n  // Let all properties be enumerable for easier serialization.\n  if (msg && typeof msg == \"object\") props = msg, msg = undefined\n  else this.message = msg\n\n  // Name has to be an own property (or on the prototype a single step up) for\n  // the stack to be printed with the correct name.\n  if (props) for (var key in props) this[key] = props[key]\n  if (!has.call(this, \"name\"))\n    this.name = has.call(proto(this), \"name\")? this.name : this.constructor.name\n\n  if (trace && !(\"stack\" in this)) trace(this, this.constructor)\n}\n\nStandardError.prototype = Object.create(Error.prototype, {\n  constructor: {value: StandardError, configurable: true, writable: true}\n})\n\n// Set name explicitly for when the code gets minified.\nStandardError.prototype.name = \"StandardError\"\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"100\\\":\\\"Continue\\\",\\\"101\\\":\\\"Switching Protocols\\\",\\\"102\\\":\\\"Processing\\\",\\\"200\\\":\\\"OK\\\",\\\"201\\\":\\\"Created\\\",\\\"202\\\":\\\"Accepted\\\",\\\"203\\\":\\\"Non-Authoritative Information\\\",\\\"204\\\":\\\"No Content\\\",\\\"205\\\":\\\"Reset Content\\\",\\\"206\\\":\\\"Partial Content\\\",\\\"207\\\":\\\"Multi-Status\\\",\\\"208\\\":\\\"Already Reported\\\",\\\"226\\\":\\\"IM Used\\\",\\\"300\\\":\\\"Multiple Choices\\\",\\\"301\\\":\\\"Moved Permanently\\\",\\\"302\\\":\\\"Found\\\",\\\"303\\\":\\\"See Other\\\",\\\"304\\\":\\\"Not Modified\\\",\\\"305\\\":\\\"Use Proxy\\\",\\\"307\\\":\\\"Temporary Redirect\\\",\\\"308\\\":\\\"Permanent Redirect\\\",\\\"400\\\":\\\"Bad Request\\\",\\\"401\\\":\\\"Unauthorized\\\",\\\"402\\\":\\\"Payment Required\\\",\\\"403\\\":\\\"Forbidden\\\",\\\"404\\\":\\\"Not Found\\\",\\\"405\\\":\\\"Method Not Allowed\\\",\\\"406\\\":\\\"Not Acceptable\\\",\\\"407\\\":\\\"Proxy Authentication Required\\\",\\\"408\\\":\\\"Request Timeout\\\",\\\"409\\\":\\\"Conflict\\\",\\\"410\\\":\\\"Gone\\\",\\\"411\\\":\\\"Length Required\\\",\\\"412\\\":\\\"Precondition Failed\\\",\\\"413\\\":\\\"Payload Too Large\\\",\\\"414\\\":\\\"URI Too Long\\\",\\\"415\\\":\\\"Unsupported Media Type\\\",\\\"416\\\":\\\"Range Not Satisfiable\\\",\\\"417\\\":\\\"Expectation Failed\\\",\\\"418\\\":\\\"I'm a teapot\\\",\\\"421\\\":\\\"Misdirected Request\\\",\\\"422\\\":\\\"Unprocessable Entity\\\",\\\"423\\\":\\\"Locked\\\",\\\"424\\\":\\\"Failed Dependency\\\",\\\"425\\\":\\\"Unordered Collection\\\",\\\"426\\\":\\\"Upgrade Required\\\",\\\"428\\\":\\\"Precondition Required\\\",\\\"429\\\":\\\"Too Many Requests\\\",\\\"431\\\":\\\"Request Header Fields Too Large\\\",\\\"500\\\":\\\"Internal Server Error\\\",\\\"501\\\":\\\"Not Implemented\\\",\\\"502\\\":\\\"Bad Gateway\\\",\\\"503\\\":\\\"Service Unavailable\\\",\\\"504\\\":\\\"Gateway Timeout\\\",\\\"505\\\":\\\"HTTP Version Not Supported\\\",\\\"506\\\":\\\"Variant Also Negotiates\\\",\\\"507\\\":\\\"Insufficient Storage\\\",\\\"508\\\":\\\"Loop Detected\\\",\\\"509\\\":\\\"Bandwidth Limit Exceeded\\\",\\\"510\\\":\\\"Not Extended\\\",\\\"511\\\":\\\"Network Authentication Required\\\"}\");\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Dependencies\n */\nconst {\n  JSONSchema\n} = __webpack_require__(28);\n/**\n * RelyingParty Schema\n *\n * This schema initializes and verifies Relying Party client configuration.\n * RelyingParty objects can be persisted and rehydrated. By encapsulating this data in\n * it's own class, it's possible to have multiple RP configurations running\n * simultaneously.\n */\n\n\nconst RelyingPartySchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    /**\n     * provider\n     *\n     * Information about the provider, including issuer URL, human readable name,\n     * and any configuration or provider metadata retrieved from the OP.\n     */\n    provider: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string'\n        },\n        url: {\n          type: 'string',\n          format: 'uri'\n        },\n        // NOTE:\n        // OpenID Configuration (discovery response) and JSON Web Keys Set for an\n        // issuer can be cached here. However the cache should not be persisted or\n        // relied upon.\n        //\n        configuration: {},\n        // .well-known/openid-configuration\n        jwks: {} // /jwks\n\n      },\n      required: ['url']\n    },\n\n    /**\n     * defaults\n     *\n     * Default request parameters for authentication and dynamic registration requests.\n     * These values can be extended or overridden via arguments to the respective\n     * request methods.\n     *\n     * These are part of the relying party client configuration and can be serialized\n     * and persisted.\n     */\n    defaults: {\n      type: 'object',\n      properties: {\n        /**\n         * Use Proof of Possession token semantics for the ID Token\n         */\n        popToken: {\n          type: 'boolean',\n          default: false\n        },\n\n        /**\n         * Default authentication request parameters\n         */\n        authenticate: {\n          type: 'object',\n          properties: {\n            redirect_uri: {\n              type: 'string',\n              format: 'uri'\n            },\n            response_type: {\n              type: 'string',\n              default: 'id_token token',\n              // browser detection\n              enum: ['code', 'token', 'id_token token', 'id_token token code']\n            },\n            display: {\n              type: 'string',\n              default: 'page',\n              enum: ['page', 'popup']\n            },\n            scope: {\n              type: ['string', 'array'],\n              default: ['openid']\n            }\n          }\n        },\n\n        /**\n         * Default client registration parameters\n         */\n        register: {}\n      }\n    },\n\n    /**\n     * registration\n     *\n     * This is the client registration response from dynamic registration. It should\n     * always reflect the client configuration on the openid provider. A client access\n     * token is stored here\n     */\n    registration: {},\n    // ClientMetadataSchema\n\n    /**\n     * store\n     */\n    store: {\n      type: 'object',\n      default: {}\n    }\n  }\n});\n/**\n * Export\n */\n\nmodule.exports = RelyingPartySchema;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _require = __webpack_require__(27),\n    URL = _require.URL;\n\nvar _require2 = __webpack_require__(37),\n    JWT = _require2.JWT,\n    JWK = _require2.JWK;\n\nvar DEFAULT_MAX_AGE = 3600; // Default token expiration, in seconds\n\nvar PoPToken = function (_JWT) {\n  _inherits(PoPToken, _JWT);\n\n  function PoPToken() {\n    _classCallCheck(this, PoPToken);\n\n    return _possibleConstructorReturn(this, (PoPToken.__proto__ || Object.getPrototypeOf(PoPToken)).apply(this, arguments));\n  }\n\n  _createClass(PoPToken, null, [{\n    key: 'issueFor',\n\n    /**\n     * @param resourceServerUri {string} RS URI for which this token is intended\n     *\n     * @param session {Session}\n     * @param session.sessionKey {string}\n     * @param session.authorization.client_id {string}\n     * @param session.authorization.id_token {string}\n     *\n     * @returns {Promise<string>} PoPToken, encoded as compact JWT\n     */\n    value: function issueFor(resourceServerUri, session) {\n      if (!resourceServerUri) {\n        throw new Error('Cannot issue PoPToken - missing resource server URI');\n      }\n\n      if (!session.sessionKey) {\n        throw new Error('Cannot issue PoPToken - missing session key');\n      }\n\n      if (!session.authorization.id_token) {\n        throw new Error('Cannot issue PoPToken - missing id token');\n      }\n\n      var jwk = JSON.parse(session.sessionKey);\n      return JWK.importKey(jwk).then(function (importedSessionJwk) {\n        var options = {\n          aud: new URL(resourceServerUri).origin,\n          key: importedSessionJwk,\n          iss: session.authorization.client_id,\n          id_token: session.authorization.id_token\n        };\n        return PoPToken.issue(options);\n      }).then(function (jwt) {\n        return jwt.encode();\n      });\n    }\n    /**\n     * issue\n     *\n     * @param options {Object}\n     * @param options.iss {string} Token issuer (RP client_id)\n     * @param options.aud {string|Array<string>} Audience for the token\n     *   (such as the Resource Server url)\n     * @param options.key {JWK} Proof of Possession (private) signing key, see\n     *   https://tools.ietf.org/html/rfc7800#section-3.1\n     *\n     * @param options.id_token {string} JWT compact encoded ID Token\n     *\n     * Optional:\n     * @param [options.iat] {number} Issued at timestamp (in seconds)\n     * @param [options.max] {number} Max token lifetime in seconds\n     *\n     * @returns {PoPToken} Proof of Possession Token (JWT instance)\n     */\n\n  }, {\n    key: 'issue',\n    value: function issue(options) {\n      var aud = options.aud,\n          iss = options.iss,\n          key = options.key;\n      var alg = key.alg;\n      var iat = options.iat || Math.floor(Date.now() / 1000);\n      var max = options.max || DEFAULT_MAX_AGE;\n      var exp = iat + max; // token expiration\n\n      var header = {\n        alg: alg\n      };\n      var payload = {\n        iss: iss,\n        aud: aud,\n        exp: exp,\n        iat: iat,\n        id_token: options.id_token,\n        token_type: 'pop'\n      };\n      var jwt = new PoPToken({\n        header: header,\n        payload: payload,\n        key: key.cryptoKey\n      }, {\n        filter: false\n      });\n      return jwt;\n    }\n  }]);\n\n  return PoPToken;\n}(JWT);\n\nmodule.exports = PoPToken;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openIdpPopup\", function() { return openIdpPopup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"obtainSession\", function() { return obtainSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"popupHandler\", function() { return popupHandler; });\n/* harmony import */ var _ipc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n\n\nfunction openIdpPopup(popupUri) {\n  const width = 650;\n  const height = 400;\n  const left = window.screenX + (window.innerWidth - width) / 2;\n  const top = window.screenY + (window.innerHeight - height) / 2;\n  const settings = \"width=\".concat(width, \",height=\").concat(height, \",left=\").concat(left, \",top=\").concat(top);\n  return window.open(popupUri, 'solid-auth-client', settings);\n}\nfunction obtainSession(store, popup, options) {\n  return new Promise((resolve, reject) => {\n    const popupServer = new _ipc__WEBPACK_IMPORTED_MODULE_0__[\"Server\"](popup, Object(_url_util__WEBPACK_IMPORTED_MODULE_1__[\"originOf\"])(options.popupUri || ''), popupHandler(store, options, session => {\n      popupServer.stop();\n      resolve(session);\n    }));\n    popupServer.start();\n  });\n}\nfunction popupHandler(store, _ref, foundSessionCb) {\n  let {\n    popupUri,\n    callbackUri\n  } = _ref;\n  return async function (method) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    switch (method) {\n      // Origin\n      case 'getAppOrigin':\n        return window.location.origin;\n      // Storage\n\n      case 'storage/getItem':\n        return store.getItem(...args);\n\n      case 'storage/setItem':\n        return store.setItem(...args);\n\n      case 'storage/removeItem':\n        return store.removeItem(...args);\n      // Login\n\n      case 'getLoginOptions':\n        return {\n          popupUri,\n          callbackUri\n        };\n\n      case 'foundSession':\n        foundSessionCb(...args);\n    }\n  };\n}\n\n/***/ })\n/******/ ])[\"default\"];\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29saWQtYXV0aC1jbGllbnQvYnJvd3Nlci9pbmRleC5qcz8wMGU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyx3QkFBd0IsRUFBRTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMENBQTBDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxnRUFBZ0UsRUFBRSxFQUFFLGdDQUFnQyxFQUFFLGFBQWE7O0FBRW5WLGdDQUFnQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsK0NBQStDLHdHQUF3RyxFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyx5Q0FBeUMsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFamtCOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixpR0FBaUc7QUFDL0g7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwyQkFBMkI7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDs7QUFFdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlFQUF5RTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msb0JBQW9COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsS0FBSzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsT0FBTztBQUNQ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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtB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Q0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQyw2QkFBNkIsT0FBTztBQUNwQztBQUNBLGlCQUFpQixTQUFTO0FBQzFCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzR0FBc0cscUJBQXFCLEVBQUU7QUFDN0gsdUdBQXVHLHNCQUFzQixFQUFFO0FBQy9ILHNHQUFzRyxxQkFBcUIsRUFBRTtBQUM3SDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc29saWRfYXV0aF9jbGllbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gLy8gRXhwb3J0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFNvbGlkQXV0aENsaWVudFxuXG5jb25zdCBhdXRoID0gbmV3IF9zb2xpZF9hdXRoX2NsaWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChhdXRoKTsgLy8gQmluZCBtZXRob2RzIHRvIGluc3RhbmNlLCBzbyB0aGV5IGNhbiBiZSBpbnZva2VkIGFzIHJlZ3VsYXIgZnVuY3Rpb25zXG4vLyAoZS5nLiwgdG8gcGFzcyBhcm91bmQgdGhlIGZldGNoIGZ1bmN0aW9uKVxuXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhfc29saWRfYXV0aF9jbGllbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0ucHJvdG90eXBlKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgY29uc3QgdmFsdWUgPSBhdXRoW3Byb3BlcnR5XTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXV0aFtwcm9wZXJ0eV0gPSB2YWx1ZS5iaW5kKGF1dGgpO1xuICB9XG59KTsgLy8gRXhwb3NlIHdpbmRvdy5Tb2xpZEF1dGhDbGllbnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmICgnU29saWRBdXRoQ2xpZW50JyBpbiB3aW5kb3cpIHtcbiAgICBjb25zb2xlLndhcm4oJ0NhdXRpb246IG11bHRpcGxlIHZlcnNpb25zIG9mIHNvbGlkLWF1dGgtY2xpZW50IGFjdGl2ZS4nKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ1NvbGlkQXV0aENsaWVudCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2Fybignd2luZG93LlNvbGlkQXV0aENsaWVudCBoYXMgYmVlbiBkZXByZWNhdGVkLicpO1xuICAgICAgICAgIGNvbnNvbGUud2FybignUGxlYXNlIHVzZSB3aW5kb3cuc29saWQuYXV0aCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1dGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTb2xpZEF1dGhDbGllbnQ7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXV0aG5fZmV0Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BvcHVwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKiBnbG9iYWwgZmV0Y2ggKi9cblxuXG5cblxuXG5cbiAvLyBTdG9yZSB0aGUgZ2xvYmFsIGZldGNoLCBzbyB0aGUgdXNlciBpcyBmcmVlIHRvIG92ZXJyaWRlIGl0XG5cbmNvbnN0IGdsb2JhbEZldGNoID0gZmV0Y2g7XG5jbGFzcyBTb2xpZEF1dGhDbGllbnQgZXh0ZW5kcyBldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0LmEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuXG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9wZW5kaW5nU2Vzc2lvblwiLCB2b2lkIDApO1xuICB9XG5cbiAgZmV0Y2goaW5wdXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCBPYmplY3QoX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJ0b1VybFN0cmluZ1wiXSkoaW5wdXQpKTtcbiAgICByZXR1cm4gT2JqZWN0KF9hdXRobl9mZXRjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiYXV0aG5GZXRjaFwiXSkoT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0U3RvcmFnZVwiXSkoKSwgZ2xvYmFsRmV0Y2gsIGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGxvZ2luKGlkcCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0TG9naW5PcHRpb25zKE9iamVjdChfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImN1cnJlbnRVcmxOb1BhcmFtc1wiXSkoKSksIHt9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImxvZ2luXCJdKGlkcCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBwb3B1cExvZ2luKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdExvZ2luT3B0aW9ucygpLCB7fSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIS9odHRwcz86Ly50ZXN0KG9wdGlvbnMucG9wdXBVcmkpKSB7XG4gICAgICBvcHRpb25zLnBvcHVwVXJpID0gbmV3IFVSTChvcHRpb25zLnBvcHVwVXJpIHx8ICcvLndlbGwta25vd24vc29saWQvbG9naW4nLCB3aW5kb3cubG9jYXRpb24pLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmNhbGxiYWNrVXJpKSB7XG4gICAgICBvcHRpb25zLmNhbGxiYWNrVXJpID0gb3B0aW9ucy5wb3B1cFVyaTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3B1cCA9IE9iamVjdChfcG9wdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIm9wZW5JZHBQb3B1cFwiXSkob3B0aW9ucy5wb3B1cFVyaSk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IE9iamVjdChfcG9wdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIm9idGFpblNlc3Npb25cIl0pKG9wdGlvbnMuc3RvcmFnZSwgcG9wdXAsIG9wdGlvbnMpO1xuICAgIHRoaXMuZW1pdCgnbG9naW4nLCBzZXNzaW9uKTtcbiAgICB0aGlzLmVtaXQoJ3Nlc3Npb24nLCBzZXNzaW9uKTtcbiAgICByZXR1cm4gc2Vzc2lvbjtcbiAgfVxuXG4gIGFzeW5jIGN1cnJlbnRTZXNzaW9uKCkge1xuICAgIGxldCBzdG9yYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRTdG9yYWdlXCJdKSgpO1xuICAgIC8vIFRyeSB0byBvYnRhaW4gYSBzdG9yZWQgb3IgcGVuZGluZyBzZXNzaW9uXG4gICAgbGV0IHNlc3Npb24gPSB0aGlzLl9wZW5kaW5nU2Vzc2lvbiB8fCAoYXdhaXQgT2JqZWN0KF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJnZXRTZXNzaW9uXCJdKShzdG9yYWdlKSk7IC8vIElmIG5vbmUgZm91bmQsIGF0dGVtcHQgdG8gY3JlYXRlIGEgbmV3IHNlc3Npb25cblxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyBPSURDIHNlc3Npb24gZnJvbSBzdG9yZWQgdG9rZW5zXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9wZW5kaW5nU2Vzc2lvbiA9IF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJjdXJyZW50U2Vzc2lvblwiXShzdG9yYWdlKTtcbiAgICAgICAgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuX3BlbmRpbmdTZXNzaW9uO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH0gLy8gU2F2ZSB0aGUgbmV3IHNlc3Npb24gYW5kIGVtaXQgc2Vzc2lvbiBldmVudHNcblxuXG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCBPYmplY3QoX3Nlc3Npb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcInNhdmVTZXNzaW9uXCJdKShzdG9yYWdlKShzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5lbWl0KCdsb2dpbicsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmVtaXQoJ3Nlc3Npb24nLCBzZXNzaW9uKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdTZXNzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiBzZXNzaW9uO1xuICB9XG5cbiAgYXN5bmMgdHJhY2tTZXNzaW9uKGNhbGxiYWNrKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgc3RhbmRhcmQvbm8tY2FsbGJhY2stbGl0ZXJhbCAqL1xuICAgIGNhbGxiYWNrKChhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uKCkpKTtcbiAgICB0aGlzLm9uKCdzZXNzaW9uJywgY2FsbGJhY2spO1xuICB9XG5cbiAgc3RvcFRyYWNrU2Vzc2lvbihjYWxsYmFjaykge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3Nlc3Npb24nLCBjYWxsYmFjayk7XG4gIH1cblxuICBhc3luYyBsb2dvdXQoKSB7XG4gICAgbGV0IHN0b3JhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFN0b3JhZ2VcIl0pKCk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IE9iamVjdChfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZ2V0U2Vzc2lvblwiXSkoc3RvcmFnZSk7XG5cbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImxvZ291dFwiXShzdG9yYWdlLCBnbG9iYWxGZXRjaCk7XG4gICAgICAgIHRoaXMuZW1pdCgnbG9nb3V0Jyk7XG4gICAgICAgIHRoaXMuZW1pdCgnc2Vzc2lvbicsIG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgbG9nZ2luZyBvdXQ6Jyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgT2JqZWN0KF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJjbGVhclNlc3Npb25cIl0pKHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2dpbk9wdGlvbnModXJsKSB7XG4gIHJldHVybiB7XG4gICAgY2FsbGJhY2tVcmk6IHVybCA/IHVybC5zcGxpdCgnIycpWzBdIDogJycsXG4gICAgcG9wdXBVcmk6ICcnLFxuICAgIHN0b3JhZ2U6IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFN0b3JhZ2VcIl0pKClcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXV0aG5GZXRjaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF1dGhuRmV0Y2g7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGlzb21vcnBoaWNfZmV0Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgaXNvbW9ycGhpY19mZXRjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzb21vcnBoaWNfZmV0Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob3N0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG5cblxuXG5hc3luYyBmdW5jdGlvbiBhdXRobkZldGNoKHN0b3JhZ2UsIGZldGNoLCBpbnB1dCwgb3B0aW9ucykge1xuICAvLyBJZiBub3QgYXV0aGVudGljYXRlZCwgcGVyZm9ybSBhIHJlZ3VsYXIgZmV0Y2hcbiAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IE9iamVjdChfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZ2V0U2Vzc2lvblwiXSkoc3RvcmFnZSk7XG5cbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgcmV0dXJuIGZldGNoKGlucHV0LCBvcHRpb25zKTtcbiAgfSAvLyBJZiB3ZSBrbm93IHRoZSBzZXJ2ZXIgZXhwZWN0cyBjcmVkZW50aWFscywgc2VuZCB0aGVtXG5cblxuICBpZiAoYXdhaXQgc2hvdWxkU2hhcmVDcmVkZW50aWFscyhzdG9yYWdlLCBpbnB1dCkpIHtcbiAgICByZXR1cm4gT2JqZWN0KF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJmZXRjaFdpdGhDcmVkZW50aWFsc1wiXSkoc2Vzc2lvbiwgZmV0Y2gsIGlucHV0LCBvcHRpb25zKTtcbiAgfSAvLyBJZiB3ZSBkb24ndCBrbm93IGZvciBzdXJlLCB0cnkgYSByZWd1bGFyIGZldGNoIGZpcnN0XG5cblxuICBsZXQgcmVzcCA9IGF3YWl0IGZldGNoKGlucHV0LCBvcHRpb25zKTsgLy8gSWYgdGhlIHNlcnZlciB0aGVuIHJlcXVlc3RzIGNyZWRlbnRpYWxzLCBzZW5kIHRoZW1cblxuICBpZiAocmVzcC5zdGF0dXMgPT09IDQwMSkge1xuICAgIGF3YWl0IE9iamVjdChfaG9zdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1widXBkYXRlSG9zdEZyb21SZXNwb25zZVwiXSkoc3RvcmFnZSkocmVzcCk7XG5cbiAgICBpZiAoYXdhaXQgc2hvdWxkU2hhcmVDcmVkZW50aWFscyhzdG9yYWdlLCBpbnB1dCkpIHtcbiAgICAgIHJlc3AgPSBPYmplY3QoX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImZldGNoV2l0aENyZWRlbnRpYWxzXCJdKShzZXNzaW9uLCBmZXRjaCwgaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNwO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzaG91bGRTaGFyZUNyZWRlbnRpYWxzKHN0b3JhZ2UsIGlucHV0KSB7XG4gIGNvbnN0IHJlcXVlc3RIb3N0ID0gYXdhaXQgT2JqZWN0KF9ob3N0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJnZXRIb3N0XCJdKShzdG9yYWdlKShPYmplY3QoX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJ0b1VybFN0cmluZ1wiXSkoaW5wdXQpKTtcbiAgcmV0dXJuIHJlcXVlc3RIb3N0ICE9IG51bGwgJiYgcmVxdWVzdEhvc3QucmVxdWlyZXNBdXRoO1xufVxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcImZldGNoXCJdOyB9KCkpO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3VycmVudFVybFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRVcmw7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImN1cnJlbnRVcmxOb1BhcmFtc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRVcmxOb1BhcmFtczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmF2aWdhdGVUb1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5hdmlnYXRlVG87IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9yaWdpbk9mXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb3JpZ2luT2Y7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvVXJsU3RyaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9VcmxTdHJpbmc7IH0pO1xuLyogZXNsaW50LWVudiBicm93c2VyICovXG5mdW5jdGlvbiBnZXRMb2NhdGlvbigpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uIDoge1xuICAgIGhyZWY6ICdodHRwczovL2V4YW1wbGUub3JnLycsXG4gICAgcGF0aG5hbWU6ICcvJyxcbiAgICBvcmlnaW46ICdleGFtcGxlLm9yZydcbiAgfTtcbn1cblxuY29uc3QgY3VycmVudFVybCA9ICgpID0+IGdldExvY2F0aW9uKCkuaHJlZjtcbmNvbnN0IGN1cnJlbnRVcmxOb1BhcmFtcyA9ICgpID0+IGdldExvY2F0aW9uKCkub3JpZ2luICsgZ2V0TG9jYXRpb24oKS5wYXRobmFtZTtcbmNvbnN0IG5hdmlnYXRlVG8gPSB1cmwgPT4ge1xuICBnZXRMb2NhdGlvbigpLmhyZWYgPSB1cmw7XG59O1xuY29uc3Qgb3JpZ2luT2YgPSB1cmwgPT4gbmV3IFVSTCh1cmwpLm9yaWdpbjtcbmNvbnN0IHRvVXJsU3RyaW5nID0gdXJsID0+IHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgdXJsID0gJ3VybCcgaW4gdXJsID8gdXJsLnVybCA6IHVybC50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVUkwodXJsLCBjdXJyZW50VXJsKCkpLnRvU3RyaW5nKCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0SG9zdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEhvc3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNhdmVIb3N0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2F2ZUhvc3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInVwZGF0ZUhvc3RGcm9tUmVzcG9uc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1cGRhdGVIb3N0RnJvbVJlc3BvbnNlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyogZ2xvYmFsUmVxdWVzdCwgUmVzcG9uc2UsIFVSTCAqL1xuXG5cblxuZnVuY3Rpb24gZ2V0SG9zdChzdG9yYWdlKSB7XG4gIHJldHVybiBhc3luYyB1cmwgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGhvc3RcbiAgICB9ID0gbmV3IFVSTCh1cmwpO1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBPYmplY3QoX3Nlc3Npb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldFNlc3Npb25cIl0pKHN0b3JhZ2UpO1xuXG4gICAgaWYgKHNlc3Npb24gJiYgaG9zdCA9PT0gbmV3IFVSTChzZXNzaW9uLmlkcCkuaG9zdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBob3N0LFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgaG9zdHNcbiAgICB9ID0gYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJnZXREYXRhXCJdKShzdG9yYWdlKTtcbiAgICByZXR1cm4gaG9zdHMgJiYgaG9zdHNbaG9zdF07XG4gIH07XG59XG5mdW5jdGlvbiBzYXZlSG9zdChzdG9yYWdlKSB7XG4gIHJldHVybiBhc3luYyAoX3JlZikgPT4ge1xuICAgIGxldCB7XG4gICAgICB1cmwsXG4gICAgICByZXF1aXJlc0F1dGhcbiAgICB9ID0gX3JlZjtcbiAgICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JhZ2UsIGRhdGEgPT4gX29iamVjdFNwcmVhZCh7fSwgZGF0YSwge1xuICAgICAgaG9zdHM6IF9vYmplY3RTcHJlYWQoe30sIGRhdGEuaG9zdHMsIHtcbiAgICAgICAgW3VybF06IHtcbiAgICAgICAgICByZXF1aXJlc0F1dGhcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KSk7XG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVIb3N0RnJvbVJlc3BvbnNlKHN0b3JhZ2UpIHtcbiAgcmV0dXJuIGFzeW5jIHJlc3AgPT4ge1xuICAgIGlmIChfd2ViaWRfb2lkY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wicmVxdWlyZXNBdXRoXCJdKHJlc3ApKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhvc3RcbiAgICAgIH0gPSBuZXcgVVJMKHJlc3AudXJsKTtcbiAgICAgIGF3YWl0IHNhdmVIb3N0KHN0b3JhZ2UpKHtcbiAgICAgICAgdXJsOiBob3N0LFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFNlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTZXNzaW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzYXZlU2Vzc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNhdmVTZXNzaW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjbGVhclNlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbGVhclNlc3Npb247IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2Vzc2lvbihzdG9yYWdlKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldERhdGFcIl0pKHN0b3JhZ2UpO1xuICByZXR1cm4gZGF0YS5zZXNzaW9uIHx8IG51bGw7XG59XG5mdW5jdGlvbiBzYXZlU2Vzc2lvbihzdG9yYWdlKSB7XG4gIHJldHVybiBhc3luYyBzZXNzaW9uID0+IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJ1cGRhdGVTdG9yYWdlXCJdKShzdG9yYWdlLCBkYXRhID0+IF9vYmplY3RTcHJlYWQoe30sIGRhdGEsIHtcbiAgICAgIHNlc3Npb25cbiAgICB9KSk7XG4gICAgcmV0dXJuIGRhdGEuc2Vzc2lvbjtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNsZWFyU2Vzc2lvbihzdG9yYWdlKSB7XG4gIGF3YWl0IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1widXBkYXRlU3RvcmFnZVwiXSkoc3RvcmFnZSwgZGF0YSA9PiBfb2JqZWN0U3ByZWFkKHt9LCBkYXRhLCB7XG4gICAgc2Vzc2lvbjogbnVsbFxuICB9KSk7XG59XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJOQU1FU1BBQ0VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBOQU1FU1BBQ0U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRTdG9yYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmYXVsdFN0b3JhZ2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldERhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXREYXRhOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1cGRhdGVTdG9yYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlU3RvcmFnZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXN5bmNTdG9yYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXN5bmNTdG9yYWdlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtZW1TdG9yYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVtU3RvcmFnZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXBjU3RvcmFnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlwY1N0b3JhZ2U7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pcGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG5jb25zdCBOQU1FU1BBQ0UgPSAnc29saWQtYXV0aC1jbGllbnQnO1xuY29uc3QgZGVmYXVsdFN0b3JhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IGhhc0xvY2FsU3RvcmFnZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdztcbiAgcmV0dXJuIGFzeW5jU3RvcmFnZShoYXNMb2NhbFN0b3JhZ2UgPyB3aW5kb3cubG9jYWxTdG9yYWdlIDogbWVtU3RvcmFnZSgpKTtcbn07XG4vKipcbiAqIEdldHMgdGhlIGRlc2VyaWFsaXplZCBzdG9yZWQgZGF0YVxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGdldERhdGEoc3RvcmUpIHtcbiAgbGV0IHNlcmlhbGl6ZWQ7XG4gIGxldCBkYXRhO1xuXG4gIHRyeSB7XG4gICAgc2VyaWFsaXplZCA9IGF3YWl0IHN0b3JlLmdldEl0ZW0oTkFNRVNQQUNFKTtcbiAgICBkYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkIHx8ICd7fScpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZGVzZXJpYWxpemUgZGF0YTonLCBzZXJpYWxpemVkKTtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBVcGRhdGVzIGEgU3RvcmFnZSBvYmplY3Qgd2l0aG91dCBtdXRhdGluZyBpdHMgaW50ZXJtZWRpYXRlIHJlcHJlc2VudGF0aW9uLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVN0b3JhZ2Uoc3RvcmUsIHVwZGF0ZSkge1xuICBjb25zdCBjdXJyZW50RGF0YSA9IGF3YWl0IGdldERhdGEoc3RvcmUpO1xuICBjb25zdCBuZXdEYXRhID0gdXBkYXRlKGN1cnJlbnREYXRhKTtcbiAgYXdhaXQgc3RvcmUuc2V0SXRlbShOQU1FU1BBQ0UsIEpTT04uc3RyaW5naWZ5KG5ld0RhdGEpKTtcbiAgcmV0dXJuIG5ld0RhdGE7XG59XG4vKipcbiAqIFRha2VzIGEgc3luY2hyb25vdXMgc3RvcmFnZSBpbnRlcmZhY2UgYW5kIHdyYXBzIGl0IHdpdGggYW4gYXN5bmMgaW50ZXJmYWNlLlxuICovXG5cbmZ1bmN0aW9uIGFzeW5jU3RvcmFnZShzdG9yYWdlKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbToga2V5ID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RvcmFnZS5nZXRJdGVtKGtleSkpO1xuICAgIH0sXG4gICAgc2V0SXRlbTogKGtleSwgdmFsKSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCkpO1xuICAgIH0sXG4gICAgcmVtb3ZlSXRlbToga2V5ID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IG1lbVN0b3JhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0ge307XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbToga2V5ID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmVba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHN0b3JlW2tleV07XG4gICAgfSxcbiAgICBzZXRJdGVtOiAoa2V5LCB2YWwpID0+IHtcbiAgICAgIHN0b3JlW2tleV0gPSB2YWw7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtOiBrZXkgPT4ge1xuICAgICAgZGVsZXRlIHN0b3JlW2tleV07XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGlwY1N0b3JhZ2UoY2xpZW50KSB7XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbToga2V5ID0+IGNsaWVudC5yZXF1ZXN0KCdzdG9yYWdlL2dldEl0ZW0nLCBrZXkpLFxuICAgIHNldEl0ZW06IChrZXksIHZhbCkgPT4gY2xpZW50LnJlcXVlc3QoJ3N0b3JhZ2Uvc2V0SXRlbScsIGtleSwgdmFsKSxcbiAgICByZW1vdmVJdGVtOiBrZXkgPT4gY2xpZW50LnJlcXVlc3QoJ3N0b3JhZ2UvcmVtb3ZlSXRlbScsIGtleSlcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTZXJ2ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTZXJ2ZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNsaWVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENsaWVudDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcblxuXG4vKlxuICBUaGlzIG1vZHVsZSBkZXNjcmliZXMgYSBzaW1wbGUgSVBDIGludGVyZmFjZSBmb3IgY29tbXVuaWNhdGluZyBiZXR3ZWVuIGJyb3dzZXIgd2luZG93cy5cbiAgd2luZG93LnBvc3RNZXNzYWdlKCkgaXMgdGhlIHRyYW5zcG9ydCBpbnRlcmZhY2UsIGFuZCBhIHJlcXVlc3QvcmVzcG9uc2UgaW50ZXJmYWNlXG4gIGlzIGRlZmluZWQgb24gdG9wIG9mIGl0IGFzIGZvbGxvd3M6XG5cbiAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAnc29saWQtYXV0aC1jbGllbnQnOiB7XG4gICAgICBpZDogMTIzNCxcbiAgICAgIG1ldGhvZDogJ2RvU29tZXRoaW5nUGxlYXNlJyxcbiAgICAgIGFyZ3M6IFsgJ29uZScsICd0d28nLCAndGhyZWUnIF1cbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAnc29saWQtYXV0aC1jbGllbnQnOiB7XG4gICAgICBpZDogMTIzNCxcbiAgICAgIHJldDogJ3RoZV92YWx1ZSdcbiAgICB9XG4gIH1cbiovXG5jb25zdCBOQU1FU1BBQ0UgPSAnc29saWQtYXV0aC1jbGllbnQnO1xuLyoqXG4gKiBSZWNlaXZlcyBhbmQgaGFuZGxlcyByZW1vdGUgcHJvY2VkdXJlIGNhbGxzLlxuICovXG5cbmNsYXNzIFNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudFdpbmRvdywgY2xpZW50T3JpZ2luLCBoYW5kbGUpIHtcbiAgICBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMsIFwiX2NsaWVudFdpbmRvd1wiLCB2b2lkIDApO1xuXG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9jbGllbnRPcmlnaW5cIiwgdm9pZCAwKTtcblxuICAgIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcywgXCJfaGFuZGxlclwiLCB2b2lkIDApO1xuXG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9tZXNzYWdlTGlzdGVuZXJcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX2NsaWVudFdpbmRvdyA9IGNsaWVudFdpbmRvdztcbiAgICB0aGlzLl9jbGllbnRPcmlnaW4gPSBjbGllbnRPcmlnaW47XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZTtcblxuICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IGV2ZW50ID0+IHRoaXMuX2hhbmRsZU1lc3NhZ2UoZXZlbnQpO1xuICB9XG5cbiAgYXN5bmMgX2hhbmRsZU1lc3NhZ2UoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBkYXRhLFxuICAgICAgb3JpZ2luXG4gICAgfSA9IF9yZWY7XG5cbiAgICAvLyBFbnN1cmUgd2UgY2FuIHBvc3QgdG8gdGhlIG9yaWdpblxuICAgIGlmIChvcmlnaW4gIT09IHRoaXMuX2NsaWVudE9yaWdpbikge1xuICAgICAgY29uc29sZS53YXJuKFwic29saWQtYXV0aC1jbGllbnQgaXMgbGlzdGVuaW5nIHRvIFwiLmNvbmNhdCh0aGlzLl9jbGllbnRPcmlnaW4sIFwiIFwiKSArIFwic28gaWdub3JlZCBhIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBcIi5jb25jYXQob3JpZ2luLCBcIi5cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gUGFyc2UgdGhlIHJlcXVlc3QgYW5kIHNlbmQgaXQgdG8gdGhlIGhhbmRsZXJcblxuXG4gICAgY29uc3QgcmVxID0gZGF0YSAmJiBkYXRhW05BTUVTUEFDRV07XG5cbiAgICBpZiAocmVxICYmIHJlcS5tZXRob2QpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYXJnc1xuICAgICAgfSA9IHJlcTtcbiAgICAgIGNvbnN0IHJldCA9IGF3YWl0IHRoaXMuX2hhbmRsZXIobWV0aG9kLCAuLi5hcmdzKTtcblxuICAgICAgdGhpcy5fY2xpZW50V2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgW05BTUVTUEFDRV06IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICByZXRcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5fY2xpZW50T3JpZ2luKTtcbiAgICB9XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fbWVzc2FnZUxpc3RlbmVyKTtcbiAgfVxuXG59XG4vKipcbiAqIE1ha2VzIHJlbW90ZSBwcm9jZWR1cmUgY2FsbHMuXG4gKi9cblxuY2xhc3MgQ2xpZW50IHtcbiAgY29uc3RydWN0b3Ioc2VydmVyV2luZG93LCBzZXJ2ZXJPcmlnaW4pIHtcbiAgICBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMsIFwiX3NlcnZlcldpbmRvd1wiLCB2b2lkIDApO1xuXG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9zZXJ2ZXJPcmlnaW5cIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX3NlcnZlcldpbmRvdyA9IHNlcnZlcldpbmRvdztcbiAgICB0aGlzLl9zZXJ2ZXJPcmlnaW4gPSBzZXJ2ZXJPcmlnaW47XG4gIH1cblxuICByZXF1ZXN0KG1ldGhvZCkge1xuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3QgYXMgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXIgd2luZG93XG4gICAgY29uc3QgaWQgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5fc2VydmVyV2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgIFtOQU1FU1BBQ0VdOiB7XG4gICAgICAgIGlkLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGFyZ3NcbiAgICAgIH1cbiAgICB9LCB0aGlzLl9zZXJ2ZXJPcmlnaW4pOyAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlcXVlc3QncyByZXR1cm4gdmFsdWVcblxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVzcG9uc2VzIHRvIHRoZSByZXF1ZXN0XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHJlc3BvbnNlTGlzdGVuZXIpOyAvLyBDYW5jZWwgaWYgdGhlIHJlc3BvbnNlIHRha2VzIHRvbyBsb25nXG5cbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGNvbm5lY3QgdG8gbWFpbiB3aW5kb3cuJykpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHJlc3BvbnNlTGlzdGVuZXIpO1xuICAgICAgfSwgMjAwMCk7IC8vIFByb2Nlc3NlcyBhIHBvc3NpYmxlIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3BvbnNlTGlzdGVuZXIoX3JlZjIpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgY29uc3QgcmVzcCA9IGRhdGEgJiYgZGF0YVtOQU1FU1BBQ0VdO1xuXG4gICAgICAgIGlmIChyZXNwICYmIHJlc3AuaWQgPT09IGlkICYmIHJlc3AuaGFzT3duUHJvcGVydHkoJ3JldCcpKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwLnJldCk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcmVzcG9uc2VMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibG9naW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2dpbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3VycmVudFNlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50U2Vzc2lvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibG9nb3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9nb3V0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRSZWdpc3RlcmVkUnBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRSZWdpc3RlcmVkUnA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlcXVpcmVzQXV0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcXVpcmVzQXV0aDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmV0Y2hXaXRoQ3JlZGVudGlhbHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmZXRjaFdpdGhDcmVkZW50aWFsczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19vYmplY3RXaXRob3V0UHJvcGVydGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19vYmplY3RXaXRob3V0UHJvcGVydGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBhdXRoX2hlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgYXV0aF9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihhdXRoX2hlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc29saWRfb2lkY19ycF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NvbGlkX29pZGNfcnBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc29saWRfb2lkY19ycF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc29saWRfb2lkY19ycF9saWJfUG9QVG9rZW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zb2xpZF9vaWRjX3JwX2xpYl9Qb1BUb2tlbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zb2xpZF9vaWRjX3JwX2xpYl9Qb1BUb2tlbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyogZ2xvYmFsIFJlc3BvbnNlICovXG5cblxuXG5cblxuYXN5bmMgZnVuY3Rpb24gbG9naW4oaWRwLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcnAgPSBhd2FpdCBnZXRSZWdpc3RlcmVkUnAoaWRwLCBvcHRpb25zKTtcbiAgICBhd2FpdCBzYXZlQXBwSGFzaEZyYWdtZW50KG9wdGlvbnMuc3RvcmFnZSk7XG4gICAgcmV0dXJuIHNlbmRBdXRoUmVxdWVzdChycCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybignRXJyb3IgbG9nZ2luZyBpbiB3aXRoIFdlYklELU9JREMnKTtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGN1cnJlbnRTZXNzaW9uKCkge1xuICBsZXQgc3RvcmFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0U3RvcmFnZVwiXSkoKTtcblxuICB0cnkge1xuICAgIC8vIE9idGFpbiB0aGUgUmVseWluZyBQYXJ0eVxuICAgIGNvbnN0IHJwID0gYXdhaXQgZ2V0U3RvcmVkUnAoc3RvcmFnZSk7XG5cbiAgICBpZiAoIXJwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIE9idGFpbiBhbmQgY2xlYXIgdGhlIE9JREMgVVJMIGZyYWdtZW50XG5cblxuICAgIGNvbnN0IHVybCA9IE9iamVjdChfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImN1cnJlbnRVcmxcIl0pKCk7XG5cbiAgICBpZiAoIS8jKC4qJik/YWNjZXNzX3Rva2VuPS8udGVzdCh1cmwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIGF3YWl0IHJlc3RvcmVBcHBIYXNoRnJhZ21lbnQoc3RvcmFnZSk7IC8vIE9idGFpbiBhIHNlc3Npb24gZnJvbSB0aGUgUmVseWluZyBQYXJ0eVxuXG4gICAgY29uc3Qgc3RvcmVEYXRhID0gYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJnZXREYXRhXCJdKShzdG9yYWdlKTtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgcnAudmFsaWRhdGVSZXNwb25zZSh1cmwsIHN0b3JlRGF0YSk7XG5cbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBzZXNzaW9uLCB7XG4gICAgICB3ZWJJZDogc2Vzc2lvbi5pZENsYWltcy5zdWIsXG4gICAgICBpZHA6IHNlc3Npb24uaXNzdWVyXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybignRXJyb3IgZmluZGluZyBhIFdlYklELU9JREMgc2Vzc2lvbicpO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gbG9nb3V0KHN0b3JhZ2UsIGZldGNoKSB7XG4gIGNvbnN0IHJwID0gYXdhaXQgZ2V0U3RvcmVkUnAoc3RvcmFnZSk7XG5cbiAgaWYgKHJwKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGxvZyBvdXQgZnJvbSB0aGUgSURQXG4gICAgICBhd2FpdCBycC5sb2dvdXQoKTsgLy8gVGhlbiwgbG9nIG91dCBmcm9tIHRoZSBSUFxuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZXRjaCgnLy53ZWxsLWtub3duL3NvbGlkL2xvZ291dCcsIHtcbiAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkgey8vIElnbm9yZSBlcnJvcnMgZm9yIHdoZW4gd2UgYXJlIG5vdCBvbiBhIFNvbGlkIHBvZFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKCdFcnJvciBsb2dnaW5nIG91dCBvZiB0aGUgV2ViSUQtT0lEQyBzZXNzaW9uJyk7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkUnAoaWRwLCBvcHRpb25zKSB7XG4gIC8vIFRvIHJldXNlIGEgcG9zc2libGUgcHJldmlvdXMgUlAsXG4gIC8vIGl0IGJlIGZvciB0aGUgc2FtZSBJRFAgYW5kIHJlZGlyZWN0IFVSSVxuICBsZXQgcnAgPSBhd2FpdCBnZXRTdG9yZWRScChvcHRpb25zLnN0b3JhZ2UpO1xuXG4gIGlmICghcnAgfHwgcnAucHJvdmlkZXIudXJsICE9PSBpZHAgfHwgIXJwLnJlZ2lzdHJhdGlvbi5yZWRpcmVjdF91cmlzLmluY2x1ZGVzKG9wdGlvbnMuY2FsbGJhY2tVcmkpKSB7XG4gICAgLy8gUmVnaXN0ZXIgYSBuZXcgUlBcbiAgICBycCA9IGF3YWl0IHJlZ2lzdGVyUnAoaWRwLCBvcHRpb25zKTtcbiAgICBhd2FpdCBzdG9yZVJwKG9wdGlvbnMuc3RvcmFnZSwgaWRwLCBycCk7XG4gIH1cblxuICByZXR1cm4gcnA7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN0b3JlZFJwKHN0b3JhZ2UpIHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZ2V0RGF0YVwiXSkoc3RvcmFnZSk7XG4gIGNvbnN0IHtcbiAgICBycENvbmZpZ1xuICB9ID0gZGF0YTtcblxuICBpZiAocnBDb25maWcpIHtcbiAgICBycENvbmZpZy5zdG9yZSA9IHN0b3JhZ2U7XG4gICAgcmV0dXJuIF9zb2xpZF9vaWRjX3JwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLmZyb20ocnBDb25maWcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN0b3JlUnAoc3RvcmFnZSwgaWRwLCBycCkge1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JhZ2UsIGRhdGEgPT4gX29iamVjdFNwcmVhZCh7fSwgZGF0YSwge1xuICAgIHJwQ29uZmlnOiBycFxuICB9KSk7XG4gIHJldHVybiBycDtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJScChpZHAsIG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIHN0b3JhZ2UsXG4gICAgY2FsbGJhY2tVcmlcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IHJlc3BvbnNlVHlwZSA9ICdpZF90b2tlbiB0b2tlbic7XG4gIGNvbnN0IGNsaWVudE5hbWVJMThuID0ge307XG4gIE9iamVjdC5lbnRyaWVzKG9wdHMpLmZpbHRlcigoX3JlZikgPT4ge1xuICAgIGxldCBba2V5LCBfXSA9IF9yZWY7XG4gICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKCdjbGllbnROYW1lIycpO1xuICB9KS5mb3JFYWNoKChfcmVmMikgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMjtcbiAgICByZXR1cm4gY2xpZW50TmFtZUkxOG5ba2V5LnJlcGxhY2UoJ2NsaWVudE5hbWUjJywgJ2NsaWVudF9uYW1lIycpXSA9IHZhbHVlO1xuICB9KTtcbiAgY29uc3Qgc3VwcGxlbWVudGFyeU9wdGlvbnMgPSB7XG4gICAgbG9nb191cmk6IG9wdHMubG9nb1VyaSxcbiAgICBjb250YWN0czogb3B0cy5jb250YWN0cyxcbiAgICBjbGllbnRfbmFtZTogb3B0cy5jbGllbnROYW1lXG4gIH07XG5cbiAgY29uc3QgcmVnaXN0cmF0aW9uID0gX29iamVjdFNwcmVhZCh7XG4gICAgaXNzdWVyOiBpZHAsXG4gICAgZ3JhbnRfdHlwZXM6IFsnaW1wbGljaXQnXSxcbiAgICByZWRpcmVjdF91cmlzOiBbY2FsbGJhY2tVcmldLFxuICAgIHJlc3BvbnNlX3R5cGVzOiBbcmVzcG9uc2VUeXBlXSxcbiAgICBzY29wZTogJ29wZW5pZCBwcm9maWxlJ1xuICB9LCBjbGllbnROYW1lSTE4biwge30sIHN1cHBsZW1lbnRhcnlPcHRpb25zKTtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBhdXRoZW50aWNhdGU6IHtcbiAgICAgICAgcmVkaXJlY3RfdXJpOiBjYWxsYmFja1VyaSxcbiAgICAgICAgcmVzcG9uc2VfdHlwZTogcmVzcG9uc2VUeXBlXG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9yZTogc3RvcmFnZVxuICB9O1xuICByZXR1cm4gX3NvbGlkX29pZGNfcnBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEucmVnaXN0ZXIoaWRwLCByZWdpc3RyYXRpb24sIG9wdGlvbnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzZW5kQXV0aFJlcXVlc3QocnAsIF9yZWYzKSB7XG4gIGxldCB7XG4gICAgY2FsbGJhY2tVcmksXG4gICAgc3RvcmFnZVxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldERhdGFcIl0pKHN0b3JhZ2UpO1xuICBjb25zdCB1cmwgPSBhd2FpdCBycC5jcmVhdGVSZXF1ZXN0KHtcbiAgICByZWRpcmVjdF91cmk6IGNhbGxiYWNrVXJpXG4gIH0sIGRhdGEpO1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JhZ2UsICgpID0+IGRhdGEpO1xuICByZXR1cm4gT2JqZWN0KF91cmxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibmF2aWdhdGVUb1wiXSkodXJsKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2F2ZUFwcEhhc2hGcmFnbWVudChzdG9yZSkge1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JlLCBkYXRhID0+IF9vYmplY3RTcHJlYWQoe30sIGRhdGEsIHtcbiAgICBhcHBIYXNoRnJhZ21lbnQ6IHdpbmRvdy5sb2NhdGlvbi5oYXNoXG4gIH0pKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzdG9yZUFwcEhhc2hGcmFnbWVudChzdG9yZSkge1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JlLCAoX3JlZjQpID0+IHtcbiAgICBsZXQge1xuICAgICAgYXBwSGFzaEZyYWdtZW50ID0gJydcbiAgICB9ID0gX3JlZjQsXG4gICAgICAgIGRhdGEgPSBfYmFiZWxfcnVudGltZV9oZWxwZXJzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKF9yZWY0LCBbXCJhcHBIYXNoRnJhZ21lbnRcIl0pO1xuXG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBhcHBIYXNoRnJhZ21lbnQ7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0pO1xufVxuLyoqXG4gKiBBbnN3ZXJzIHdoZXRoZXIgYSBIVFRQIHJlc3BvbnNlIHJlcXVpcmVzIFdlYklELU9JREMgYXV0aGVudGljYXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiByZXF1aXJlc0F1dGgocmVzcCkge1xuICBpZiAocmVzcC5zdGF0dXMgIT09IDQwMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHd3d0F1dGhIZWFkZXIgPSByZXNwLmhlYWRlcnMuZ2V0KCd3d3ctYXV0aGVudGljYXRlJyk7XG5cbiAgaWYgKCF3d3dBdXRoSGVhZGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgYXV0aCA9IGF1dGhfaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJwYXJzZVwiXSh3d3dBdXRoSGVhZGVyKTtcbiAgcmV0dXJuIGF1dGguc2NoZW1lID09PSAnQmVhcmVyJyAmJiBhdXRoLnBhcmFtcyAmJiBhdXRoLnBhcmFtcy5zY29wZSA9PT0gJ29wZW5pZCB3ZWJpZCc7XG59XG4vKipcbiAqIEZldGNoZXMgYSByZXNvdXJjZSwgcHJvdmlkaW5nIHRoZSBXZWJJRC1PSURDIElEIFRva2VuIGFzIGF1dGhlbnRpY2F0aW9uLlxuICogQXNzdW1lcyB0aGF0IHRoZSByZXNvdXJjZSBoYXMgcmVxdWVzdGVkIHRob3NlIHRva2VucyBpbiBhIHByZXZpb3VzIHJlc3BvbnNlLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aENyZWRlbnRpYWxzKHNlc3Npb24sIGZldGNoLCBpbnB1dCwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBoZWFkZXJzXG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgY29uc3Qgb3JpZ0hlYWRlcnMgPSBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogaW5wdXQuaGVhZGVycztcblxuICBpZiAob3JpZ0hlYWRlcnMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdHlwZW9mIG9yaWdIZWFkZXJzLmVudHJpZXMgPT09ICdmdW5jdGlvbicgPyBvcmlnSGVhZGVycy5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhvcmlnSGVhZGVycyk7XG5cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfSAvLyBBZGQgQXV0aG9yaXphdGlvbiBoZWFkZXJcblxuXG4gIGNvbnN0IHBvcFRva2VuID0gYXdhaXQgX3NvbGlkX29pZGNfcnBfbGliX1BvUFRva2VuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdC5hLmlzc3VlRm9yKE9iamVjdChfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInRvVXJsU3RyaW5nXCJdKShpbnB1dCksIHNlc3Npb24pO1xuICBoZWFkZXJzLmF1dGhvcml6YXRpb24gPSBcIkJlYXJlciBcIi5jb25jYXQocG9wVG9rZW4pO1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgIGhlYWRlcnNcbiAgfSkpO1xufVxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXM7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2U7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZm9ybWF0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2Zvcm1hdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xuXG52YXIgX3BhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciB4eHggPSBmdW5jdGlvbiB4eHgoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYCR7a2V5fT0ke3ZhbHVlICYmICEoMCwgX3V0aWwuaXNUb2tlbikodmFsdWUpID8gKDAsIF91dGlsLnF1b3RlKSh2YWx1ZSkgOiB2YWx1ZX1gO1xuICB9O1xufTtcblxudmFyIGJ1aWxkID0gZnVuY3Rpb24gYnVpbGQocGFyYW1zKSB7XG4gIHJldHVybiBwYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIGtleSA9IF9yZWYyWzBdLFxuICAgICAgICB2YWx1ZXMgPSBfcmVmMlsxXTtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSB4eHgoa2V5KTtcblxuICAgIGlmICghKDAsIF91dGlsLmlzVG9rZW4pKGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KHByZXYpLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmFsdWVzLm1hcCh0cmFuc2Zvcm0pKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShwcmV2KS5jb25jYXQoW3RyYW5zZm9ybSh2YWx1ZXMpXSk7XG4gIH0sIFtdKTtcbn07XG5cbnZhciBjaGFsbGVuZ2UgPSBmdW5jdGlvbiBjaGFsbGVuZ2UocGFyYW1zLCBvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICByZXR1cm4gYnVpbGQocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbnRyaWVzID0gcGFyYW1zO1xuICAgIHJldHVybiBjaGFsbGVuZ2UoT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIGVudHJpZXNba2V5XV07XG4gICAgfSksIG9wdGlvbnMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc2NoZW1lLCB0b2tlbiwgcGFyYW1zKSB7XG4gIHZhciBvYmogPSB0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJyA/IHtcbiAgICBzY2hlbWUsXG4gICAgdG9rZW4sXG4gICAgcGFyYW1zXG4gIH0gOiBzY2hlbWU7XG5cbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICB9IGVsc2UgaWYgKCEoMCwgX3V0aWwuaXNTY2hlbWUpKG9iai5zY2hlbWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY2hlbWUuJyk7XG4gIH1cblxuICByZXR1cm4gW29iai5zY2hlbWVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodHlwZW9mIG9iai50b2tlbiAhPT0gJ3VuZGVmaW5lZCcgPyBbb2JqLnRva2VuXSA6IFtdKSwgX3RvQ29uc3VtYWJsZUFycmF5KHR5cGVvZiBvYmoucGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IGNoYWxsZW5nZShvYmoucGFyYW1zKSA6IFtdKSkuam9pbignICcpO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudW5xdW90ZSA9IGV4cG9ydHMucXVvdGUgPSBleHBvcnRzLmlzU2NoZW1lID0gZXhwb3J0cy5pc1Rva2VuID0gdm9pZCAwO1xudmFyIHRva2VuID0gL15bXlxcdTAwMDAtXFx1MDAxRlxcdTAwN0YoKTw+QCw7OlxcXFxcIi8/PXt9XFxbXFxdXFx1MDAyMFxcdTAwMDldKyQvO1xuXG52YXIgaXNUb2tlbiA9IGZ1bmN0aW9uIGlzVG9rZW4oc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiB0b2tlbi50ZXN0KHN0cik7XG59O1xuXG5leHBvcnRzLmlzVG9rZW4gPSBpc1Rva2VuO1xudmFyIGlzU2NoZW1lID0gaXNUb2tlbjtcbmV4cG9ydHMuaXNTY2hlbWUgPSBpc1NjaGVtZTtcblxudmFyIHF1b3RlID0gZnVuY3Rpb24gcXVvdGUoc3RyKSB7XG4gIHJldHVybiBgXCIke3N0ci5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyl9XCJgO1xufTtcblxuZXhwb3J0cy5xdW90ZSA9IHF1b3RlO1xuXG52YXIgdW5xdW90ZSA9IGZ1bmN0aW9uIHVucXVvdGUoc3RyKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XG59O1xuXG5leHBvcnRzLnVucXVvdGUgPSB1bnF1b3RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXBcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuLy8gbG9sIGRpc1xudmFyIGJvZHkgPSAvKCg/OlthLXpBLVowLTkuX34rXFwvLV0rPSooPzpcXHMrfCQpKXxbXlxcdTAwMDAtXFx1MDAxRlxcdTAwN0YoKTw+QCw7OlxcXFxcIi8/PXt9XFxbXFxdXFx1MDAyMFxcdTAwMDldKykoPzo9KFteXFxcXFwiPVxccyxdK3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCIpKT8vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHByZXYsIF9jdXIpIHtcbiAgLy8gRml4dXAgcXVvdGVkIHN0cmluZ3MgYW5kIHRva2VucyB3aXRoIHNwYWNlcyBhcm91bmQgdGhlbVxuICB2YXIgY3VyID0gX2N1ci5jaGFyQXQoMCkgPT09ICdcIicgPyAoMCwgX3V0aWwudW5xdW90ZSkoX2N1cikgOiBfY3VyLnRyaW0oKTsgLy8gTWFyc2hhbFxuXG4gIGlmIChBcnJheS5pc0FycmF5KHByZXYpKSB7XG4gICAgcmV0dXJuIHByZXYuY29uY2F0KGN1cik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByZXYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFtwcmV2LCBjdXJdO1xuICB9XG5cbiAgcmV0dXJuIGN1cjtcbn07XG5cbnZhciBwYXJzZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBwYXJzZVByb3BlcnRpZXMoc2NoZW1lLCBzdHJpbmcpIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdmFyIHBhcmFtcyA9IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcmVzID0gYm9keS5leGVjKHN0cmluZyk7XG5cbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzWzJdKSB7XG4gICAgICBwYXJhbXNbcmVzWzFdXSA9IG5vcm1hbGl6ZShwYXJhbXNbcmVzWzFdXSwgcmVzWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW4gPSBub3JtYWxpemUodG9rZW4sIHJlc1sxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWUsXG4gICAgcGFyYW1zLFxuICAgIHRva2VuXG4gIH07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVyIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBzdHIuaW5kZXhPZignICcpO1xuICB2YXIgc2NoZW1lID0gc3RyLnN1YnN0cigwLCBzdGFydCk7XG5cbiAgaWYgKCEoMCwgX3V0aWwuaXNTY2hlbWUpKHNjaGVtZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNjaGVtZSAke3NjaGVtZX1gKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZVByb3BlcnRpZXMoc2NoZW1lLCBzdHIuc3Vic3RyKHN0YXJ0KSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbmNvbnN0IGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5jb25zdCBmZXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbmNvbnN0IHtcbiAgVVJMXG59ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbmNvbnN0IEhlYWRlcnMgPSBmZXRjaC5IZWFkZXJzID8gZmV0Y2guSGVhZGVycyA6IGdsb2JhbC5IZWFkZXJzO1xuXG5jb25zdCB7XG4gIEpTT05Eb2N1bWVudFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5jb25zdCB7XG4gIEpXS1NldFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG5jb25zdCBBdXRoZW50aWNhdGlvblJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuY29uc3QgQXV0aGVudGljYXRpb25SZXNwb25zZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG5jb25zdCBSZWx5aW5nUGFydHlTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcblxuY29uc3Qgb25IdHRwRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuY29uc3QgRm9ybVVybEVuY29kZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcbi8qKlxuICogUmVseWluZ1BhcnR5XG4gKlxuICogQGNsYXNzXG4gKiBDbGllbnQgaW50ZXJmYWNlIGZvciBPcGVuSUQgQ29ubmVjdCBSZWx5aW5nIFBhcnR5LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgbGV0IGNsaWVudCA9IFJlbHlpbmdQYXJ0eSh7XG4gKiAgICBwcm92aWRlcjoge1xuICogICAgICBuYW1lOiAnQW52aWwgUmVzZWFyY2gsIEluYy4nLFxuICogICAgICB1cmw6ICdodHRwczovL2ZvcmdlLmFudmlsLmlvJ1xuICogICAgICAvLyBjb25maWd1cmF0aW9uXG4gKiAgICAgIC8vIGp3a3NcbiAqICAgIH0sXG4gKiAgICBkZWZhdWx0czoge1xuICogICAgICBwb3BUb2tlbjogZmFsc2UsXG4gKiAgICAgIGF1dGhlbnRpY2F0ZToge1xuICogICAgICAgIHJlc3BvbnNlX3R5cGU6ICdjb2RlJyxcbiAqICAgICAgICBkaXNwbGF5OiAncG9wdXAnLFxuICogICAgICAgIHNjb3BlOiAnb3BlbmlkIHByb2ZpbGUgZW1haWwnXG4gKiAgICAgIH0sXG4gKiAgICAgIHJlZ2lzdGVyOiB7XG4gKiAgICAgICAgY2xpZW50X25hbWU6ICdFeGFtcGxlJyxcbiAqICAgICAgICBjbGllbnRfdXJpOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScsXG4gKiAgICAgICAgbG9nb191cmk6ICdodHRwczovL2V4YW1wbGUuY29tL2Fzc2V0cy9sb2dvLnBuZycsXG4gKiAgICAgICAgcmVkaXJlY3RfdXJpczogWydodHRwczovL2FwcC5leGFtcGxlLmNvbS9jYWxsYmFjayddLFxuICogICAgICAgIHJlc3BvbnNlX3R5cGVzOiBbJ2NvZGUnLCAnY29kZSBpZF90b2tlbiB0b2tlbiddLFxuICogICAgICAgIGdyYW50X3R5cGVzOiBbJ2F1dGhvcml6YXRpb25fY29kZSddLFxuICogICAgICAgIGRlZmF1bHRfbWF4X2FnZTogNzIwMCxcbiAqICAgICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmlzOiBbJ2h0dHBzOi8vYXBwLmV4YW1wbGUuY29tJ11cbiAqICAgICAgfSxcbiAqICAgIH0sXG4gKiAgICByZWdpc3RyYXRpb246IHtcbiAqICAgICAgLy8gaWYgeW91IGhhdmUgaXQgc2F2ZWQgc29tZXdoZXJlXG4gKiAgICB9LFxuICogICAgc3RvcmU6IGxvY2FsU3RvcmFnZSB8fCByZXEuc2Vzc2lvblxuICogIH0pXG4gKlxuICogIGNsaWVudC5kaXNjb3ZlcigpID0+IFByb21pc2VcbiAqICBjbGllbnQuandrcygpID0+IFByb21pc2VcbiAqICBjbGllbnQuYXV0aGVudGljYXRlKClcbiAqICBjbGllbnQuYXV0aGVudGljYXRlVXJpKClcbiAqICBjbGllbnQudmFsaWRhdGVSZXNwb25zZSh1cmkpID0+IFByb21pc2VcbiAqICBjbGllbnQudXNlcmluZm8oKSA9PiBQcm9taXNlXG4gKiAgY2xpZW50LmxvZ291dCgpXG4gKi9cblxuXG5jbGFzcyBSZWx5aW5nUGFydHkgZXh0ZW5kcyBKU09ORG9jdW1lbnQge1xuICAvKipcbiAgICogU2NoZW1hXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNjaGVtYSgpIHtcbiAgICByZXR1cm4gUmVseWluZ1BhcnR5U2NoZW1hO1xuICB9XG4gIC8qKlxuICAgKiBmcm9tXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDcmVhdGUgYSBSZWx5aW5nUGFydHkgaW5zdGFuY2UgZnJvbSBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlbHlpbmdQYXJ0eT59XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb20oZGF0YSkge1xuICAgIGxldCBycCA9IG5ldyBSZWx5aW5nUGFydHkoZGF0YSk7XG4gICAgbGV0IHZhbGlkYXRpb24gPSBycC52YWxpZGF0ZSgpOyAvLyBzY2hlbWEgdmFsaWRhdGlvblxuXG4gICAgaWYgKCF2YWxpZGF0aW9uLnZhbGlkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHZhbGlkYXRpb24pKSk7XG4gICAgfVxuXG4gICAgbGV0IGp3a3MgPSBycC5wcm92aWRlci5qd2tzOyAvLyByZXF1ZXN0IHRoZSBKV0sgU2V0IGlmIG1pc3NpbmdcblxuICAgIGlmICghandrcykge1xuICAgICAgcmV0dXJuIHJwLmp3a3MoKS50aGVuKCgpID0+IHJwKTtcbiAgICB9IC8vIG90aGVyd2lzZSBpbXBvcnQgdGhlIEpXSyBTZXQgdG8gd2ViY3J5cHRvXG5cblxuICAgIHJldHVybiBKV0tTZXQuaW1wb3J0S2V5cyhqd2tzKS50aGVuKGp3a3MgPT4ge1xuICAgICAgcnAucHJvdmlkZXIuandrcyA9IGp3a3M7XG4gICAgICByZXR1cm4gcnA7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlZ2lzdGVyXG4gICAqXG4gICAqIEBwYXJhbSBpc3N1ZXIge3N0cmluZ30gUHJvdmlkZXIgVVJMXG4gICAqIEBwYXJhbSByZWdpc3RyYXRpb24ge09iamVjdH0gQ2xpZW50IGR5bmFtaWMgcmVnaXN0cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdHNcbiAgICogQHBhcmFtIFtvcHRpb25zLnN0b3JlXSB7U2Vzc2lvbnxTdG9yYWdlfVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWx5aW5nUGFydHk+fSBSZWx5aW5nUGFydHkgaW5zdGFuY2UsIHJlZ2lzdGVyZWQuXG4gICAqL1xuXG5cbiAgc3RhdGljIHJlZ2lzdGVyKGlzc3VlciwgcmVnaXN0cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgbGV0IHJwID0gbmV3IFJlbHlpbmdQYXJ0eSh7XG4gICAgICBwcm92aWRlcjoge1xuICAgICAgICB1cmw6IGlzc3VlclxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmRlZmF1bHRzKSxcbiAgICAgIHN0b3JlOiBvcHRpb25zLnN0b3JlXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gcnAuZGlzY292ZXIoKSkudGhlbigoKSA9PiBycC5qd2tzKCkpLnRoZW4oKCkgPT4gcnAucmVnaXN0ZXIocmVnaXN0cmF0aW9uKSkudGhlbigoKSA9PiBycCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2NvdmVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBGZXRjaGVzIHRoZSBpc3N1ZXIncyBPcGVuSUQgQ29uZmlndXJhdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUmVzb2x2ZXMgd2l0aCB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiByZXNwb25zZVxuICAgKi9cblxuXG4gIGRpc2NvdmVyKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgaXNzdWVyID0gdGhpcy5wcm92aWRlci51cmw7XG4gICAgICBhc3NlcnQoaXNzdWVyLCAnUmVseWluZ1BhcnR5IHByb3ZpZGVyIG11c3QgZGVmaW5lIFwidXJsXCInKTtcbiAgICAgIGxldCB1cmwgPSBuZXcgVVJMKGlzc3Vlcik7XG4gICAgICB1cmwucGF0aG5hbWUgPSAnLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nO1xuICAgICAgcmV0dXJuIGZldGNoKHVybC50b1N0cmluZygpKS50aGVuKG9uSHR0cEVycm9yKCdFcnJvciBmZXRjaGluZyBvcGVuaWQgY29uZmlndXJhdGlvbicpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS50aGVuKGpzb24gPT4gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uID0ganNvbik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlcidzIGEgY2xpZW50IHdpdGggcHJvdmlkZXIgYXMgYSBSZWx5aW5nIFBhcnR5XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFJlc29sdmVzIHdpdGggdGhlIHJlZ2lzdHJhdGlvbiByZXNwb25zZSBvYmplY3RcbiAgICovXG5cblxuICByZWdpc3RlcihvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb25maWd1cmF0aW9uID0gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24sICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICBhc3NlcnQoY29uZmlndXJhdGlvbi5yZWdpc3RyYXRpb25fZW5kcG9pbnQsICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBtaXNzaW5nIHJlZ2lzdHJhdGlvbl9lbmRwb2ludC4nKTtcbiAgICAgIGxldCB1cmkgPSBjb25maWd1cmF0aW9uLnJlZ2lzdHJhdGlvbl9lbmRwb2ludDtcbiAgICAgIGxldCBtZXRob2QgPSAncG9zdCc7XG4gICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSk7XG4gICAgICBsZXQgcGFyYW1zID0gdGhpcy5kZWZhdWx0cy5yZWdpc3RlcjtcbiAgICAgIGxldCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLCBvcHRpb25zKSk7XG4gICAgICByZXR1cm4gZmV0Y2godXJpLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keVxuICAgICAgfSkudGhlbihvbkh0dHBFcnJvcignRXJyb3IgcmVnaXN0ZXJpbmcgY2xpZW50JykpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpLnRoZW4oanNvbiA9PiB0aGlzLnJlZ2lzdHJhdGlvbiA9IGpzb24pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogandrc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gUHJvbWlzZXMgdGhlIGlzc3VlcidzIEpXSyBTZXQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIGp3a3MoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb25maWd1cmF0aW9uID0gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24sICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICBhc3NlcnQoY29uZmlndXJhdGlvbi5qd2tzX3VyaSwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG1pc3Npbmcgandrc191cmkuJyk7XG4gICAgICBsZXQgdXJpID0gY29uZmlndXJhdGlvbi5qd2tzX3VyaTtcbiAgICAgIHJldHVybiBmZXRjaCh1cmkpLnRoZW4ob25IdHRwRXJyb3IoJ0Vycm9yIHJlc29sdmluZyBwcm92aWRlciBrZXlzJykpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpLnRoZW4oanNvbiA9PiBKV0tTZXQuaW1wb3J0S2V5cyhqc29uKSkudGhlbihqd2tzID0+IHRoaXMucHJvdmlkZXIuandrcyA9IGp3a3MpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBjcmVhdGVSZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IEF1dGhuIHJlcXVlc3Qgb3B0aW9ucyBoYXNobWFwXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0X3VyaSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZXNwb25zZV90eXBlIHtzdHJpbmd9IGUuZy4gJ2NvZGUnIG9yICdpZF90b2tlbiB0b2tlbidcbiAgICogQHBhcmFtIHNlc3Npb24ge1Nlc3Npb258U3RvcmFnZX0gcmVxLnNlc3Npb24gb3IgbG9jYWxTdG9yYWdlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEF1dGhuIHJlcXVlc3QgVVJMXG4gICAqL1xuXG5cbiAgY3JlYXRlUmVxdWVzdChvcHRpb25zLCBzZXNzaW9uKSB7XG4gICAgcmV0dXJuIEF1dGhlbnRpY2F0aW9uUmVxdWVzdC5jcmVhdGUodGhpcywgb3B0aW9ucywgc2Vzc2lvbiB8fCB0aGlzLnN0b3JlKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgUmVzcG9uc2VcbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlIHtzdHJpbmd9IHJlcS5xdWVyeSBvciByZXEuYm9keS50ZXh0XG4gICAqIEBwYXJhbSBzZXNzaW9uIHtTZXNzaW9ufFN0b3JhZ2V9IHJlcS5zZXNzaW9uIG9yIGxvY2FsU3RvcmFnZSBvciBzaW1pbGFyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNlc3Npb24+fVxuICAgKi9cblxuXG4gIHZhbGlkYXRlUmVzcG9uc2UocmVzcG9uc2UsIHNlc3Npb24gPSB0aGlzLnN0b3JlKSB7XG4gICAgbGV0IG9wdGlvbnM7XG5cbiAgICBpZiAocmVzcG9uc2UubWF0Y2goL15odHRwKHM/KTpcXC9cXC8vKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcnA6IHRoaXMsXG4gICAgICAgIHJlZGlyZWN0OiByZXNwb25zZSxcbiAgICAgICAgc2Vzc2lvblxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcnA6IHRoaXMsXG4gICAgICAgIGJvZHk6IHJlc3BvbnNlLFxuICAgICAgICBzZXNzaW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGF1dGhSZXNwb25zZSA9IG5ldyBBdXRoZW50aWNhdGlvblJlc3BvbnNlKG9wdGlvbnMpO1xuICAgIHJldHVybiBBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlUmVzcG9uc2UoYXV0aFJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogdXNlcmluZm9cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIFByb21pc2VzIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIncyBjbGFpbXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHVzZXJpbmZvKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHRoaXMucHJvdmlkZXIuY29uZmlndXJhdGlvbjtcbiAgICAgIGFzc2VydChjb25maWd1cmF0aW9uLCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24udXNlcmluZm9fZW5kcG9pbnQsICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBtaXNzaW5nIHVzZXJpbmZvX2VuZHBvaW50LicpO1xuICAgICAgbGV0IHVyaSA9IGNvbmZpZ3VyYXRpb24udXNlcmluZm9fZW5kcG9pbnQ7XG4gICAgICBsZXQgYWNjZXNzX3Rva2VuID0gdGhpcy5zdG9yZS5hY2Nlc3NfdG9rZW47XG4gICAgICBhc3NlcnQoYWNjZXNzX3Rva2VuLCAnTWlzc2luZyBhY2Nlc3MgdG9rZW4uJyk7XG4gICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzX3Rva2VufWBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZldGNoKHVyaSwge1xuICAgICAgICBoZWFkZXJzXG4gICAgICB9KS50aGVuKG9uSHR0cEVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyaW5mbycpKS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBsb2dvdXRSZXF1ZXN0XG4gICAqXG4gICAqIENvbXBvc2VzIGFuZCByZXR1cm5zIHRoZSBsb2dvdXQgcmVxdWVzdCBVUkksIGJhc2VkIG9uIHRoZSBPUCdzXG4gICAqIGBlbmRfc2Vzc2lvbl9lbmRwb2ludGAsIHdpdGggYXBwcm9wcmlhdGUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogTm90ZTogQ2FsbGluZyBjbGllbnQgY29kZSBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IHRvIGNsZWFyIHRoZSBsb2NhbFxuICAgKiBzZXNzaW9uIHN0YXRlIChmb3IgZXhhbXBsZSwgYnkgY2FsbGluZyBgcnAuY2xlYXJTZXNzaW9uKClgKS4gSW4gYWRkaXRpb24sXG4gICAqIHNvbWUgSWRQcyAoc3VjaCBhcyBHb29nbGUpIG1heSBub3QgcHJvdmlkZSBhbiBgZW5kX3Nlc3Npb25fZW5kcG9pbnRgLFxuICAgKiBpbiB3aGljaCBjYXNlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1zZXNzaW9uLTFfMC5odG1sI1JQTG9nb3V0XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBwcm92aWRlciBjb25maWcgaXMgbm90IGluaXRpYWxpemVkXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpYCB3YXMgcHJvdmlkZWQgd2l0aG91dCBhXG4gICAqICAgY29ycmVzcG9uZGluZyBgaWRfdG9rZW5faGludGBcbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zPXt9XSB7b2JqZWN0fVxuICAgKlxuICAgKiBAcGFyYW0gW29wdGlvbnMuaWRfdG9rZW5faGludF0ge3N0cmluZ30gUkVDT01NRU5ERUQuXG4gICAqICAgUHJldmlvdXNseSBpc3N1ZWQgSUQgVG9rZW4gcGFzc2VkIHRvIHRoZSBsb2dvdXQgZW5kcG9pbnQgYXNcbiAgICogICBhIGhpbnQgYWJvdXQgdGhlIEVuZC1Vc2VyJ3MgY3VycmVudCBhdXRoZW50aWNhdGVkIHNlc3Npb24gd2l0aCB0aGVcbiAgICogICBDbGllbnQuIFRoaXMgaXMgdXNlZCBhcyBhbiBpbmRpY2F0aW9uIG9mIHRoZSBpZGVudGl0eSBvZiB0aGUgRW5kLVVzZXJcbiAgICogICB0aGF0IHRoZSBSUCBpcyByZXF1ZXN0aW5nIGJlIGxvZ2dlZCBvdXQgYnkgdGhlIE9QLiBUaGUgT1AgKm5lZWQgbm90KiBiZVxuICAgKiAgIGxpc3RlZCBhcyBhbiBhdWRpZW5jZSBvZiB0aGUgSUQgVG9rZW4gd2hlbiBpdCBpcyB1c2VkIGFzIGFuXG4gICAqICAgYGlkX3Rva2VuX2hpbnRgIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gW29wdGlvbnMucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpXSB7c3RyaW5nfSBPUFRJT05BTC4gVVJMIHRvIHdoaWNoXG4gICAqICAgdGhlIFJQIGlzIHJlcXVlc3RpbmcgdGhhdCB0aGUgRW5kLVVzZXIncyBVc2VyIEFnZW50IGJlIHJlZGlyZWN0ZWQgYWZ0ZXJcbiAgICogICBhIGxvZ291dCBoYXMgYmVlbiBwZXJmb3JtZWQuIFRoZSB2YWx1ZSBNVVNUIGhhdmUgYmVlbiBwcmV2aW91c2x5XG4gICAqICAgcmVnaXN0ZXJlZCB3aXRoIHRoZSBPUCwgZWl0aGVyIHVzaW5nIHRoZSBgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpc2BcbiAgICogICBSZWdpc3RyYXRpb24gcGFyYW1ldGVyIG9yIHZpYSBhbm90aGVyIG1lY2hhbmlzbS4gSWYgc3VwcGxpZWQsIHRoZSBPUFxuICAgKiAgIFNIT1VMRCBob25vciB0aGlzIHJlcXVlc3QgZm9sbG93aW5nIHRoZSBsb2dvdXQuXG4gICAqXG4gICAqICAgTm90ZTogVGhlIHJlcXVpcmVtZW50IHRvIHZhbGlkYXRlIHRoZSB1cmkgZm9yIHByZXZpb3VzIHJlZ2lzdHJhdGlvbiBtZWFuc1xuICAgKiAgIHRoYXQsIGluIHByYWN0aWNlLCB0aGUgYGlkX3Rva2VuX2hpbnRgIGlzIFJFUVVJUkVEIGlmXG4gICAqICAgYHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaWAgaXMgdXNlZC4gT3RoZXJ3aXNlLCB0aGUgT1AgaGFzIG5vIHdheSB0byBnZXRcbiAgICogICB0aGUgYGNsaWVudF9pZGAgdG8gbG9hZCB0aGUgc2F2ZWQgY2xpZW50IHJlZ2lzdHJhdGlvbiwgdG8gdmFsaWRhdGUgdGhlXG4gICAqICAgdXJpLiBUaGUgb25seSB3YXkgaXQgY2FuIGdldCBpdCBpcyBieSBkZWNvZGluZyB0aGUgYGlkX3Rva2VuX2hpbnRgLlxuICAgKlxuICAgKiBAcGFyYW0gW29wdGlvbnMuc3RhdGVdIHtzdHJpbmd9IE9QVElPTkFMLiBPcGFxdWUgdmFsdWUgdXNlZCBieSB0aGUgUlAgdG9cbiAgICogICBtYWludGFpbiBzdGF0ZSBiZXR3ZWVuIHRoZSBsb2dvdXQgcmVxdWVzdCBhbmQgdGhlIGNhbGxiYWNrIHRvIHRoZVxuICAgKiAgIGVuZHBvaW50IHNwZWNpZmllZCBieSB0aGUgYHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaWAgcXVlcnkgcGFyYW1ldGVyLiBJZlxuICAgKiAgIGluY2x1ZGVkIGluIHRoZSBsb2dvdXQgcmVxdWVzdCwgdGhlIE9QIHBhc3NlcyB0aGlzIHZhbHVlIGJhY2sgdG8gdGhlIFJQXG4gICAqICAgdXNpbmcgdGhlIGBzdGF0ZWAgcXVlcnkgcGFyYW1ldGVyIHdoZW4gcmVkaXJlY3RpbmcgdGhlIFVzZXIgQWdlbnQgYmFjayB0b1xuICAgKiAgIHRoZSBSUC5cbiAgICpcbiAgICogVE9ETzogSW4gdGhlIGZ1dHVyZSwgY29uc2lkZXIgYWRkaW5nIGByZXNwb25zZV9tb2RlYCBwYXJhbSwgZm9yIHRoZSBPUCB0b1xuICAgKiAgIGRldGVybWluZSBob3cgdG8gcmV0dXJuIHRoZSBgc3RhdGVgIGJhY2sgdGhlIFJQLlxuICAgKiAgIEBzZWUgaHR0cDovL29wZW5pZC5uZXQvc3BlY3Mvb2F1dGgtdjItbXVsdGlwbGUtcmVzcG9uc2UtdHlwZXMtMV8wLmh0bWwjUmVzcG9uc2VNb2Rlc1xuICAgKlxuICAgKiBUT0RPOiBIYW5kbGUgc3BlY2lhbCBjYXNlcyBmb3IgcG9wdWxhciBwcm92aWRlcnMgKEdvb2dsZSwgTVNGVClcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBMb2dvdXQgdXJpIChvciBudWxsIGlmIG5vIGVuZF9zZXNzaW9uX2VuZHBvaW50IHdhc1xuICAgKiAgIHByb3ZpZGVkIGluIHRoZSBJZFAgY29uZmlnKVxuICAgKi9cblxuXG4gIGxvZ291dFJlcXVlc3Qob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWRfdG9rZW5faGludCxcbiAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgIHN0YXRlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGNvbmZpZ3VyYXRpb247XG4gICAgYXNzZXJ0KHRoaXMucHJvdmlkZXIsICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICBjb25maWd1cmF0aW9uID0gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uO1xuICAgIGFzc2VydChjb25maWd1cmF0aW9uLCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbm90IGluaXRpYWxpemVkJyk7XG5cbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBPcGVuSWQgQ29uZmlndXJhdGlvbiBmb3IgYCArIGAke2NvbmZpZ3VyYXRpb24uaXNzdWVyfSBpcyBtaXNzaW5nIGVuZF9zZXNzaW9uX2VuZHBvaW50YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpICYmICFpZF90b2tlbl9oaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkX3Rva2VuX2hpbnQgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmknKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmIChpZF90b2tlbl9oaW50KSB7XG4gICAgICBwYXJhbXMuaWRfdG9rZW5faGludCA9IGlkX3Rva2VuX2hpbnQ7XG4gICAgfVxuXG4gICAgaWYgKHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSkge1xuICAgICAgcGFyYW1zLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHBhcmFtcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY29uZmlndXJhdGlvbi5lbmRfc2Vzc2lvbl9lbmRwb2ludCk7XG4gICAgdXJsLnNlYXJjaCA9IEZvcm1VcmxFbmNvZGVkLmVuY29kZShwYXJhbXMpO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbiAgfVxuICAvKipcbiAgICogTG9nb3V0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqXG4gICAqIFRPRE86IEFkZCBkZXByZWNhdGlvbiB3YXJuaW5ncywgdGhlbiByZW1vdmUuIENsaWVudCBjb2RlIHNob3VsZFxuICAgKiAgIHVzZSBgbG9nb3V0UmVxdWVzdCgpYCBpbnN0ZWFkXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIGxvZ291dCgpIHtcbiAgICBsZXQgY29uZmlndXJhdGlvbjtcblxuICAgIHRyeSB7XG4gICAgICBhc3NlcnQodGhpcy5wcm92aWRlciwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICAgIGNvbmZpZ3VyYXRpb24gPSB0aGlzLnByb3ZpZGVyLmNvbmZpZ3VyYXRpb247XG4gICAgICBhc3NlcnQoY29uZmlndXJhdGlvbiwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICAgIGFzc2VydChjb25maWd1cmF0aW9uLmVuZF9zZXNzaW9uX2VuZHBvaW50LCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbWlzc2luZyBlbmRfc2Vzc2lvbl9lbmRwb2ludC4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcbiAgICAgIHRoaXMuY2xlYXJTZXNzaW9uKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgbGV0IHVyaSA9IGNvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQ7XG4gICAgbGV0IG1ldGhvZCA9ICdnZXQnO1xuICAgIHJldHVybiBmZXRjaCh1cmksIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZSdcbiAgICB9KS50aGVuKG9uSHR0cEVycm9yKCdFcnJvciBsb2dnaW5nIG91dCcpKS50aGVuKCgpID0+IHRoaXMuY2xlYXJTZXNzaW9uKCkpOyAvLyBUT0RPOiBWYWxpZGF0ZSBgZnJvbnRjaGFubmVsX2xvZ291dF91cmlgIGlmIG5lY2Vzc2FyeVxuXG4gICAgLyoqXG4gICAgICogZnJvbnRjaGFubmVsX2xvZ291dF91cmkgLSBPUFRJT05BTC4gUlAgVVJMIHRoYXQgd2lsbCBjYXVzZSB0aGUgUlAgdG8gbG9nXG4gICAgICogaXRzZWxmIG91dCB3aGVuIHJlbmRlcmVkIGluIGFuIGlmcmFtZSBieSB0aGUgT1AuXG4gICAgICpcbiAgICAgKiBBbiBgaXNzYCAoaXNzdWVyKSBxdWVyeSBwYXJhbWV0ZXIgYW5kIGEgYHNpZGBcbiAgICAgKiAoc2Vzc2lvbiBJRCkgcXVlcnkgcGFyYW1ldGVyIE1BWSBiZSBpbmNsdWRlZCBieSB0aGUgT1AgdG8gZW5hYmxlIHRoZSBSUFxuICAgICAqIHRvIHZhbGlkYXRlIHRoZSByZXF1ZXN0IGFuZCB0byBkZXRlcm1pbmUgd2hpY2ggb2YgdGhlIHBvdGVudGlhbGx5XG4gICAgICogbXVsdGlwbGUgc2Vzc2lvbnMgaXMgdG8gYmUgbG9nZ2VkIG91dC4gSWYgYSBzaWQgKHNlc3Npb24gSUQpIHF1ZXJ5XG4gICAgICogcGFyYW1ldGVyIGlzIGluY2x1ZGVkLCBhbiBpc3MgKGlzc3VlcikgcXVlcnkgcGFyYW1ldGVyIE1VU1QgYWxzbyBiZVxuICAgICAqIGluY2x1ZGVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9vcGVuaWQubmV0L3NwZWNzL29wZW5pZC1jb25uZWN0LWZyb250Y2hhbm5lbC0xXzAuaHRtbCNSUExvZ291dFxuICAgICAqL1xuICB9XG5cbiAgY2xlYXJTZXNzaW9uKCkge1xuICAgIGxldCBzZXNzaW9uID0gdGhpcy5zdG9yZTtcblxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlbGV0ZSBzZXNzaW9uW1NFU1NJT05fUFJJVkFURV9LRVldO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gdXJpIHtzdHJpbmd9IFRhcmdldCBSZXNvdXJjZSBTZXJ2ZXIgVVJJXG4gICAqIEBwYXJhbSBpZFRva2VuIHtJRFRva2VufSBJRCBUb2tlbiB0byBiZSBlbWJlZGRlZCBpbiB0aGUgUG9QIHRva2VuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFBvUFRva2VuPn1cbiAgICovXG5cblxuICBwb3BUb2tlbkZvcih1cmksIGlkVG9rZW4pIHtcbiAgICByZXR1cm4gUG9QVG9rZW4uaXNzdWVGb3IodXJpLCBpZFRva2VuKTtcbiAgfVxuXG59XG5cbmNvbnN0IFNFU1NJT05fUFJJVkFURV9LRVkgPSAnb2lkYy5zZXNzaW9uLnByaXZhdGVLZXknO1xuUmVseWluZ1BhcnR5LlNFU1NJT05fUFJJVkFURV9LRVkgPSBTRVNTSU9OX1BSSVZBVEVfS0VZO1xubW9kdWxlLmV4cG9ydHMgPSBSZWx5aW5nUGFydHk7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG52YXIgb2JqZWN0QXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuLy8gTkI6IFRoZSBVUkwgdG8gdGhlIENvbW1vbkpTIHNwZWMgaXMga2VwdCBqdXN0IGZvciB0cmFkaXRpb24uXG4vLyAgICAgbm9kZS1hc3NlcnQgaGFzIGV2b2x2ZWQgYSBsb3Qgc2luY2UgdGhlbiwgYm90aCBpbiBBUEkgYW5kIGJlaGF2aW9yLlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbi8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5mdW5jdGlvbiBzdHJpY3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgc3RyaWN0KTtcbn1cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMjApKSlcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7Ly8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IsIG51bGwsIHJldCkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZCwgcmVqLCBjYikgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSkpXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJ3aW5kb3dcIl07IH0oKSk7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZvcm1hdHM6IF9fd2VicGFja19yZXF1aXJlX18oMjkpLFxuICBJbml0aWFsaXplcjogX193ZWJwYWNrX3JlcXVpcmVfXygzMCksXG4gIEpTT05Eb2N1bWVudDogX193ZWJwYWNrX3JlcXVpcmVfXygzMSksXG4gIEpTT05NYXBwaW5nOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSxcbiAgSlNPTlBhdGNoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSxcbiAgSlNPTlBvaW50ZXI6IF9fd2VicGFja19yZXF1aXJlX18oMzMpLFxuICBKU09OU2NoZW1hOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSxcbiAgVmFsaWRhdG9yOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxufTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIEpTT04gU2NoZW1hIEZvcm1hdHNcbiAqXG4gKiBUT0RPXG4gKiBJcyB0aGVyZSBhIGdvb2Qgd2F5IHRvIGV4cHJlc3MgdGhlc2Ugb3ZlciBtdWx0aXBsZSBsaW5lcyB3aXRoIGNvbW1lbnRzXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZyBhbmQgYXVkaXRpbmc/XG4gKi9cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERBVEVUSU1FX1JFR0VYUCA9IC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGQoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQ6XFxkXFxkKSQvaTtcbnZhciBVUklfUkVHRVhQID0gL14oPzpbYS16XVthLXowLTkrLS5dKik/KD86XFw6fFxcLylcXC8/W15cXHNdKiQvaTtcbnZhciBFTUFJTF9SRUdFWFAgPSAvXlthLXowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2k7XG52YXIgSVBWNF9SRUdFWFAgPSAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvO1xudmFyIElQVjZfUkVHRVhQID0gL15cXHMqKD86KD86KD86WzAtOWEtZl17MSw0fTopezd9KD86WzAtOWEtZl17MSw0fXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezZ9KD86OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs1fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs0fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDN9KXwoPzooPzo6WzAtOWEtZl17MSw0fSk/Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezN9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNH0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDJ9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezJ9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNX0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDN9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezF9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNn0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDR9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86Oig/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDd9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw1fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSg/OiUuKyk/XFxzKiQvaTtcbnZhciBIT1NUTkFNRV9SRUdFWFAgPSAvXlthLXpdKD86KD86Wy0wLTlhLXpdezAsNjF9KT9bMC05YS16XSk/KFxcLlthLXpdKD86KD86Wy0wLTlhLXpdezAsNjF9KT9bMC05YS16XSk/KSokL2k7XG5cbi8qKlxuICogRm9ybWF0c1xuICovXG5cbnZhciBGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtYXRzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtYXRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtYXRzLCBbe1xuICAgIGtleTogJ3JlZ2lzdGVyJyxcblxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IG1hcHBpbmcgZnJvbSBuYW1lZCBmb3JtYXQgdG8gUmVnRXhwIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBUT0RPXG4gICAgICogV2UgY2FuIGRvIHNvbWUgZXh0cmEgdmFsaWRhdGlvbiBvZiB0aGUgUmVnRXhwIHRvXG4gICAgICogZW5zdXJlIGl0J3MgdGhlIGFjY2VwdGFibGUgc3Vic2V0IG9mIFJlZ0V4cHMgYWxsb3dlZFxuICAgICAqIGJ5IEpTT04gU2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuICAgICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5hbWUsIHBhdHRlcm4pIHtcbiAgICAgIC8vIHZlcmlmeSBuYW1lIGlzIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IG5hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYXN0IGEgc3RyaW5nIHRvIFJlZ0V4cFxuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNbbmFtZV0gPSBwYXR0ZXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdpdmVuIGEgZm9ybWF0IG5hbWUsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZWdpc3RlcmVkIHZhbGlkYXRpb24uIEluIHRoZVxuICAgICAqIGV2ZW50IGEgZm9ybWF0IGlzIG5vdCByZWdpc3RlcmVkLCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVzb2x2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUobmFtZSkge1xuICAgICAgdmFyIGZvcm1hdCA9IHRoaXNbbmFtZV07XG5cbiAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBKU09OIFNjaGVtYSBmb3JtYXQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGVzdCB0aGF0IGEgdmFsdWUgY29uZm9ybXMgdG8gYSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGZvcm1hdCA9IHRoaXMucmVzb2x2ZShuYW1lKTtcbiAgICAgIHJldHVybiBmb3JtYXQudGVzdCh2YWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplJyxcblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQ3JlYXRlIGEgbmV3IEZvcm1hdHMgaW5zdGFuY2UgYW5kIHJlZ2lzdGVyIGRlZmF1bHQgZm9ybWF0c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0Zvcm1hdHN9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICB2YXIgZm9ybWF0cyA9IG5ldyBGb3JtYXRzKCk7XG4gICAgICBmb3JtYXRzLnJlZ2lzdGVyKCdkYXRlLXRpbWUnLCBEQVRFVElNRV9SRUdFWFApO1xuICAgICAgZm9ybWF0cy5yZWdpc3RlcigndXJpJywgVVJJX1JFR0VYUCk7XG4gICAgICBmb3JtYXRzLnJlZ2lzdGVyKCdlbWFpbCcsIEVNQUlMX1JFR0VYUCk7XG4gICAgICBmb3JtYXRzLnJlZ2lzdGVyKCdpcHY0JywgSVBWNF9SRUdFWFApO1xuICAgICAgZm9ybWF0cy5yZWdpc3RlcignaXB2NicsIElQVjZfUkVHRVhQKTtcbiAgICAgIGZvcm1hdHMucmVnaXN0ZXIoJ2hvc3RuYW1lJywgSE9TVE5BTUVfUkVHRVhQKTtcbiAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtYXRzO1xufSgpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtYXRzLmluaXRpYWxpemUoKTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIEluaXRpYWxpemVyXG4gKi9cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbml0aWFsaXplcihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5pdGlhbGl6ZXIpO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QgfHwgdGhpcztcblxuICAgIHRoaXMucm9vdC5kZXB0aCA9IHRoaXMucm9vdC5kZXB0aCB8fCAxO1xuXG4gICAgaWYgKHRoaXMubGV2ZWwgPiB0aGlzLnJvb3QuZGVwdGgpIHtcbiAgICAgIHRoaXMucm9vdC5kZXB0aCA9IHRoaXMubGV2ZWw7XG4gICAgfVxuXG4gICAgdGhpcy5sZXZlbCA9IHRoaXMubGV2ZWwgfHwgMDtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb21waWxlIChzdGF0aWMpXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEluaXRpYWxpemVyLCBbe1xuICAgIGtleTogJ2NvbXBpbGUnLFxuXG5cbiAgICAvKipcbiAgICAgKiBjb21waWxlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUoKSB7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdCxcbiAgICAgICAgICBkZXB0aCA9IHRoaXMuZGVwdGgsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsO1xuXG4gICAgICB2YXIgZGVjbGFyYXRpb25zID0gJyc7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICAvLyB0cmF2ZXJzZSB0aGUgc2NoZW1hIGFuZCBnZW5lcmF0ZSBjb2RlXG4gICAgICBib2R5ICs9IHRoaXMuZGVmYXVsdCgpO1xuICAgICAgYm9keSArPSB0aGlzLnByb3BlcnRpZXMoKTtcbiAgICAgIC8vYm9keSArPSB0aGlzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKClcbiAgICAgIGJvZHkgKz0gdGhpcy5pdGVtcygpO1xuICAgICAgLy9ib2R5ICs9IHRoaXMuYWRkaXRpb25hbEl0ZW1zKClcblxuXG4gICAgICAvLyB2YWx1ZVxuICAgICAgYm9keSArPSB0aGlzLm1lbWJlcigpO1xuICAgICAgYm9keSArPSB0aGlzLml0ZW0oKTtcblxuICAgICAgLy8gYWZ0ZXIgdHJhdmVyc2luZyB0aGUgc2NoZW1hXG4gICAgICAvLyBnZW5lcmF0ZSB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb25zXG4gICAgICBpZiAocm9vdCA9PT0gdGhpcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB0aGlzLnJvb3QuZGVwdGg7IGkrKykge1xuICAgICAgICAgIGRlY2xhcmF0aW9ucyArPSB0aGlzLmRlY2xhcmF0aW9uKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdcXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XFxuXFxuICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIgPT09IGZhbHNlKSB7XFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNvdXJjZSkpKVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgJyArIGRlY2xhcmF0aW9ucyArICdcXG4gICAgICAgICcgKyBib2R5ICsgJ1xcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRlY2xhcmF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlY2xhcmF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjbGFyYXRpb24obGV2ZWwpIHtcbiAgICAgIHJldHVybiAnXFxuICAgICAgdmFyIHRhcmdldCcgKyBsZXZlbCArICdcXG4gICAgICB2YXIgc291cmNlJyArIGxldmVsICsgJ1xcbiAgICAgIHZhciBjb3VudCcgKyBsZXZlbCArICdcXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWZhdWx0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlZmF1bHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYSxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICAgICAga2V5ID0gdGhpcy5rZXksXG4gICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdmFyIHZhbHVlID0gc2NoZW1hLmRlZmF1bHQ7IC8vIHJlbmFtZSBkZWZhdWx0IHRvIHZhbHVlIGJlY2F1c2UgaXQncyBhIGtleXdvcmQgYW5kIHN5bnRheCBoaWdobGlnaHRlciBicmVha3NcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSkge1xuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddID0gJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdcXG4gICAgICAgICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gPSAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcbiAgICAgICAgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbCA+IDEpIHtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIGNvdW50JyArIGxldmVsICsgJysrXFxuICAgICAgICAnO1xuICAgICAgICB9XG5cbiAgICAgICAgYmxvY2sgPSAnXFxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cyAhPT0gZmFsc2UpIHtcXG4gICAgICAgICAgJyArIGJsb2NrICsgJ1xcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtZW1iZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVtYmVyKCkge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIHJvb3QgPSB0aGlzLnJvb3QsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGtleSA9IHRoaXMua2V5O1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICAgICAgICBpdGVtcyA9IHNjaGVtYS5pdGVtcyxcbiAgICAgICAgICBhZGRpdGlvbmFsSXRlbXMgPSBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgLy8gYGtleWAgdGVsbHMgdXMgdG8gdHJlYXQgdGhpcyBzdWJzY2hlbWEgYXMgYW4gb2JqZWN0IG1lbWJlciB2cyBhbiBhcnJheSBpdGVtXG4gICAgICAvLyBhbmQgdGhlIGFic2VuY2Ugb2YgdGhlIG90aGVyIHZhbHVlcyBoZXJlIGluZGljYXRlcyB3ZSBhcmUgZGVhbGluZyB3aXRoIGFcbiAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgaWYgKGtleSAmJiAhcHJvcGVydGllcyAmJiAhYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgIWl0ZW1zICYmICFhZGRpdGlvbmFsSXRlbXMpIHtcblxuICAgICAgICAvLyBmaXJzdCBnZW5lcmF0ZSB0aGUgYXNzaWdubWVudCBzdGF0ZW1lbnRcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPSBzb3VyY2UnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICc7XG5cbiAgICAgICAgLy8gZm9yIG5lc3RlZCBjb250YWluZXIgb2JqZWN0cywgYWRkIHRoZSBjb3VudGVyIGluY3JlbWVudGluZyBzdGF0ZW1lbnRcbiAgICAgICAgaWYgKGxldmVsID4gMSkge1xuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3cmFwIHRoZSBmb3JlZ29pbmcgaW4gYSBjaGVjayBmb3IgcHJlc2VuY2Ugb24gdGhlIHNvdXJjZVxuICAgICAgICBibG9jayA9ICdcXG4gICAgICAgIGlmIChzb3VyY2UnICsgbGV2ZWwgKyAnLmhhc093blByb3BlcnR5KFxcJycgKyBrZXkgKyAnXFwnKSkge1xcbiAgICAgICAgICAnICsgYmxvY2sgKyAnXFxuICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGl0ZW1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZW0oKSB7XG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgcm9vdCA9IHRoaXMucm9vdCxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICAgICAgICBpdGVtcyA9IHNjaGVtYS5pdGVtcyxcbiAgICAgICAgICBhZGRpdGlvbmFsSXRlbXMgPSBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKGluZGV4ICYmICFwcm9wZXJ0aWVzICYmICFhZGRpdGlvbmFsUHJvcGVydGllcyAmJiAhaXRlbXMgJiYgIWFkZGl0aW9uYWxJdGVtcykge1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gPSBzb3VyY2UnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddXFxuICAgICAgJztcblxuICAgICAgICBpZiAobGV2ZWwgPiAxKSB7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICBjb3VudCcgKyBsZXZlbCArICcrK1xcbiAgICAgICAgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgaWYgKCcgKyBpbmRleCArICcgPCBsZW4pIHtcXG4gICAgICAgICAgJyArIGJsb2NrICsgJ1xcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIHJvb3QgPSB0aGlzLnJvb3QsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGtleSA9IHRoaXMua2V5LFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXM7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgc3Vic2NoZW1hID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IG5ldyBJbml0aWFsaXplcihzdWJzY2hlbWEsIHsga2V5OiBrZXksIHJvb3Q6IHJvb3QsIGxldmVsOiBsZXZlbCArIDEgfSk7XG5cbiAgICAgICAgICBibG9jayArPSBpbml0aWFsaXplci5jb21waWxlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJvb3QtbGV2ZWwgcHJvcGVydGllcyBib2lsZXJwbGF0ZVxuICAgICAgICBpZiAocm9vdCA9PT0gdGhpcykge1xuICAgICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXFwnb2JqZWN0XFwnICYmIHNvdXJjZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFxcJ29iamVjdFxcJykge1xcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcJz9cXCcpXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHNvdXJjZTEgPSBzb3VyY2VcXG4gICAgICAgICAgICB0YXJnZXQxID0gdGFyZ2V0XFxuICAgICAgICAgICAgY291bnQxID0gMFxcblxcbiAgICAgICAgICAgICcgKyBibG9jayArICdcXG4gICAgICAgICAgfVxcbiAgICAgICAgJztcblxuICAgICAgICAgIC8vIG5lc3RlZCBwcm9wZXJ0aWVzIGJvaWxlcnBsYXRlXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgICAgIGlmICgnICsgaW5kZXggKyAnIDwgc291cmNlJyArIGxldmVsICsgJy5sZW5ndGggfHwgdHlwZW9mIHNvdXJjZScgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gPT09IFxcJ29iamVjdFxcJykge1xcblxcbiAgICAgICAgICAgICAgc291cmNlJyArIChsZXZlbCArIDEpICsgJyA9IHNvdXJjZScgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gfHwge31cXG4gICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJyA9IDBcXG5cXG4gICAgICAgICAgICAgIGlmICgnICsgaW5kZXggKyAnIDwgdGFyZ2V0JyArIGxldmVsICsgJy5sZW5ndGggfHwgdHlwZW9mIHRhcmdldCcgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gIT09IFxcJ29iamVjdFxcJykge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnID0ge31cXG4gICAgICAgICAgICAgICAgaWYgKCcgKyBpbmRleCArICcgPCBzb3VyY2UnICsgbGV2ZWwgKyAnLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJysrXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICcgPSB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddXFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAnICsgYmxvY2sgKyAnXFxuXFxuICAgICAgICAgICAgICBpZiAoY291bnQnICsgKGxldmVsICsgMSkgKyAnID4gMCkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddID0gdGFyZ2V0JyArIChsZXZlbCArIDEpICsgJ1xcbiAgICAgICAgICAgICAgICBjb3VudCcgKyBsZXZlbCArICcrK1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddID0gc291cmNlJyArIGxldmVsICsgJ1snICsgaW5kZXggKyAnXVxcbiAgICAgICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgYmxvY2sgPSAnXFxuICAgICAgICAgICAgaWYgKCh0eXBlb2Ygc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPT09IFxcJ29iamVjdFxcJ1xcbiAgICAgICAgICAgICAgICAgICYmIHNvdXJjZScgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddICE9PSBudWxsXFxuICAgICAgICAgICAgICAgICAgJiYgIUFycmF5LmlzQXJyYXkoc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10pKVxcbiAgICAgICAgICAgICAgICB8fCAhc291cmNlJyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJykpIHtcXG5cXG4gICAgICAgICAgICAgIHNvdXJjZScgKyAobGV2ZWwgKyAxKSArICcgPSBzb3VyY2UnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSB8fCB7fVxcbiAgICAgICAgICAgICAgY291bnQnICsgKGxldmVsICsgMSkgKyAnID0gMFxcblxcbiAgICAgICAgICAgICAgaWYgKCF0YXJnZXQnICsgbGV2ZWwgKyAnLmhhc093blByb3BlcnR5KFxcJycgKyBrZXkgKyAnXFwnKVxcbiAgICAgICAgICAgICAgICAgIHx8IHR5cGVvZiB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSAhPT0gXFwnb2JqZWN0XFwnXFxuICAgICAgICAgICAgICAgICAgfHwgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPT09IG51bGxcXG4gICAgICAgICAgICAgICAgICB8fCBBcnJheS5pc0FycmF5KHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddKSkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnID0ge31cXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZScgKyBsZXZlbCArICcuaGFzT3duUHJvcGVydHkoXFwnJyArIGtleSArICdcXCcpKSB7XFxuICAgICAgICAgICAgICAgICAgY291bnQnICsgKGxldmVsICsgMSkgKyAnKytcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGFyZ2V0JyArIChsZXZlbCArIDEpICsgJyA9IHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddXFxuICAgICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJysrXFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAnICsgYmxvY2sgKyAnXFxuXFxuICAgICAgICAgICAgICBpZiAoY291bnQnICsgKGxldmVsICsgMSkgKyAnID4gMCkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSA9IHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICdcXG4gICAgICAgICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPSBzb3VyY2UnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRpdGlvbmFsUHJvcGVydGllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKCkge31cblxuICAgIC8qKlxuICAgICAqIGl0ZW1zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2l0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgcm9vdCA9IHRoaXMucm9vdCxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICAgICAga2V5ID0gdGhpcy5rZXksXG4gICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdmFyIGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKGl0ZW1zKSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAuLi5cblxuICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaXRlbXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGl0ZW1zKSkgPT09ICdvYmplY3QnICYmIGl0ZW1zICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9pbmRleCA9ICdpJyArIChsZXZlbCArIDEpO1xuICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IG5ldyBJbml0aWFsaXplcihpdGVtcywgeyBpbmRleDogX2luZGV4LCByb290OiByb290LCBsZXZlbDogbGV2ZWwgKyAxIH0pO1xuXG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICB2YXIgc0xlbiA9IHNvdXJjZScgKyAobGV2ZWwgKyAxKSArICcubGVuZ3RoIHx8IDBcXG4gICAgICAgICAgdmFyIHRMZW4gPSB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnLmxlbmd0aCB8fCAwXFxuICAgICAgICAgIHZhciBsZW4gPSAwXFxuXFxuICAgICAgICAgIGlmIChzTGVuID4gbGVuKSB7IGxlbiA9IHNMZW4gfVxcbiAgICAgICAgICAvLyBUSElTIElTIFdST05HLCBDQVVTRUQgU0lNUExFIEFSUkFZIElOSVQgVE8gRkFJTCAoT1ZFUldSSVRFXFxuICAgICAgICAgIC8vIEVYSVNUSU5HIFRBUkdFVCBWQUxVRVMgV0lUSCBVTkRFRklORUQgV0hFTiBTT1VSQ0UgSVMgU0hPUlRFUiBUSEFOXFxuICAgICAgICAgIC8vIFRBUkdFVCkuIExFQVZJTkcgSEVSRSBVTlRJTCBXRSBGSU5JU0ggVEVTVElORyBBTkQgU0VFIFdIWSBJVCBNSUdIVFxcbiAgICAgICAgICAvLyBIQVZFIEJFRU4gSEVSRSBJTiBUSEUgRklSU1QgUExBQ0UuXFxuICAgICAgICAgIC8vXFxuICAgICAgICAgIC8vIGlmICh0TGVuID4gbGVuKSB7IGxlbiA9IHRMZW4gfVxcblxcbiAgICAgICAgICBmb3IgKHZhciAnICsgX2luZGV4ICsgJyA9IDA7ICcgKyBfaW5kZXggKyAnIDwgbGVuOyAnICsgX2luZGV4ICsgJysrKSB7XFxuICAgICAgICAgICAgJyArIGluaXRpYWxpemVyLmNvbXBpbGUoKSArICdcXG4gICAgICAgICAgfVxcbiAgICAgICAgJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvb3QtbGV2ZWwgcHJvcGVydGllcyBib2lsZXJwbGF0ZVxuICAgICAgICBpZiAocm9vdCA9PT0gdGhpcykge1xuICAgICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XFxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXCc/XFwnKVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBzb3VyY2UxID0gc291cmNlXFxuICAgICAgICAgICAgdGFyZ2V0MSA9IHRhcmdldFxcblxcbiAgICAgICAgICAgICcgKyBibG9jayArICdcXG4gICAgICAgICAgfVxcbiAgICAgICAgJztcblxuICAgICAgICAgIC8vIG5lc3RlZCBwcm9wZXJ0aWVzIGJvaWxlcnBsYXRlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxvY2sgPSAnXFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZScgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddKSB8fCAhc291cmNlJyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJykpIHtcXG5cXG4gICAgICAgICAgICBzb3VyY2UnICsgKGxldmVsICsgMSkgKyAnID0gc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gfHwgW11cXG4gICAgICAgICAgICBjb3VudCcgKyAobGV2ZWwgKyAxKSArICcgPSAwXFxuXFxuICAgICAgICAgICAgaWYgKCF0YXJnZXQnICsgbGV2ZWwgKyAnLmhhc093blByb3BlcnR5KFxcJycgKyBrZXkgKyAnXFwnKSB8fCAhQXJyYXkuaXNBcnJheSh0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSkpIHtcXG4gICAgICAgICAgICAgIHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICcgPSBbXVxcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlJyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJykpIHtcXG4gICAgICAgICAgICAgICAgICBjb3VudCcgKyAobGV2ZWwgKyAxKSArICcrK1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICcgPSB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICAgICAgICAgY291bnQnICsgKGxldmVsICsgMSkgKyAnKytcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgJyArIGJsb2NrICsgJ1xcblxcbiAgICAgICAgICAgIGlmIChjb3VudCcgKyAobGV2ZWwgKyAxKSArICcgPiAwKSB7XFxuICAgICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSA9IHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICdcXG4gICAgICAgICAgICAgIGNvdW50JyArIGxldmVsICsgJysrXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddID0gc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ11cXG4gICAgICAgICAgICBjb3VudCcgKyBsZXZlbCArICcrK1xcbiAgICAgICAgICB9XFxuICAgICAgICAnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRpdGlvbmFsSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRpdGlvbmFsSXRlbXMoKSB7fVxuICB9XSwgW3tcbiAgICBrZXk6ICdjb21waWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZShzY2hlbWEpIHtcbiAgICAgIHZhciBpbml0aWFsaXplciA9IG5ldyBJbml0aWFsaXplcihzY2hlbWEpO1xuICAgICAgdmFyIGJsb2NrID0gaW5pdGlhbGl6ZXIuY29tcGlsZSgpO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKGJlYXV0aWZ5KGJsb2NrKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3RhcmdldCcsICdzb3VyY2UnLCAnb3B0aW9ucycsIGJsb2NrKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coZSwgZS5zdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEluaXRpYWxpemVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluaXRpYWxpemVyO1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBKU09OUGF0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuLyoqXG4gKiBKU09ORG9jdW1lbnRcbiAqXG4gKiBAY2xhc3NcbiAqIEpTT05Eb2N1bWVudCBpcyBhIGhpZ2ggbGV2ZWwgaW50ZXJmYWNlIHRoYXQgYmluZHMgdG9nZXRoZXIgYWxsIG90aGVyIGZlYXR1cmVzIG9mXG4gKiB0aGlzIHBhY2thZ2UgYW5kIHByb3ZpZGVzIHRoZSBwcmluY2lwbGUgbWV0aG9kIG9mIGRhdGEgbW9kZWxpbmcuXG4gKi9cblxudmFyIEpTT05Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgX2NyZWF0ZUNsYXNzKEpTT05Eb2N1bWVudCwgbnVsbCwgW3tcbiAgICBrZXk6ICdzY2hlbWEnLFxuXG5cbiAgICAvKipcbiAgICAgKiBTY2hlbWFcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2NoZW1hIG11c3QgYmUgZGVmaW5lZCBieSBjbGFzc2VzIGV4dGVuZGluZyBKU09ORG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH1dKTtcblxuICBmdW5jdGlvbiBKU09ORG9jdW1lbnQoKSB7XG4gICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKU09ORG9jdW1lbnQpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSlNPTkRvY3VtZW50LCBbe1xuICAgIGtleTogJ2luaXRpYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuY29uc3RydWN0b3Iuc2NoZW1hO1xuXG4gICAgICBzY2hlbWEuaW5pdGlhbGl6ZSh0aGlzLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBhbHRlcm5hdGUgLSBPUFRJT05BTCBhbHRlcm5hdGUgc2NoZW1hXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmFsaWRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZShhbHRlcm5hdGUpIHtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLmNvbnN0cnVjdG9yLnNjaGVtYTtcblxuICAgICAgcmV0dXJuIChhbHRlcm5hdGUgfHwgc2NoZW1hKS52YWxpZGF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3BzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhdGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0Y2gob3BzKSB7XG4gICAgICB2YXIgcGF0Y2ggPSBuZXcgSlNPTlBhdGNoKG9wcyk7XG4gICAgICBwYXRjaC5hcHBseSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge31cblxuICAgIC8qKlxuICAgICAqIFByb2plY3RcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdpdmVuIGEgbWFwcGluZywgcmV0dXJuIGFuIG9iamVjdCBwcm9qZWN0ZWQgZnJvbSB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IHNjaGVtYSA9IG5ldyBKU09OU2NoZW1hKHtcbiAgICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICAgKiAgICAgZm9vOiB7IHR5cGU6ICdBcnJheScgfVxuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBsZXQgbWFwcGluZyA9IG5ldyBKU09OTWFwcGluZyh7XG4gICAgICogICAnL2Zvby8wJzogJy9iYXIvYmF6J1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBjbGFzcyBGb29UcmFja2VyIGV4dGVuZHMgSlNPTkRvY3VtZW50IHtcbiAgICAgKiAgIHN0YXRpYyBnZXQgc2NoZW1hICgpIHsgcmV0dXJuIHNjaGVtYSB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogbGV0IGluc3RhbmNlID0gbmV3IEZvb1RyYWNrZXIoeyBmb286IFsncXV4J10gfSlcbiAgICAgKiBpbnN0YW5jZS5wcm9qZWN0KG1hcHBpbmcpXG4gICAgICogLy8gPT4geyBiYXI6IHsgYmF6OiAncXV4JyB9IH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTk1hcHBpbmd9IG1hcHBpbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2plY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9qZWN0KG1hcHBpbmcpIHtcbiAgICAgIHJldHVybiBtYXBwaW5nLnByb2plY3QodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6ICdzZXJpYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXNlcmlhbGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBKU09OJyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpTT05Eb2N1bWVudDtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTkRvY3VtZW50O1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEpTT05Qb2ludGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cbi8qKlxuICogTW9kZXNcbiAqL1xudmFyIFRIUk9XID0gMDtcbnZhciBSRUNPVkVSID0gMTtcbnZhciBTSUxFTlQgPSAyO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgbGlzdFxuICovXG52YXIgT1BFUkFUSU9OUyA9IFsnYWRkJywgJ3JlbW92ZScsICdyZXBsYWNlJywgJ21vdmUnLCAnY29weScsICd0ZXN0J107XG5cbi8qKlxuICogUGF0Y2hcbiAqXG4gKiBAY2xhc3NcbiAqIEltcGxlbWVudHMgUkZDIDY5MDI6IEphdmFTY3JpcHQgT2JqZWN0IE5vdGF0aW9uIChKU09OKSBQYXRjaFxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDJcbiAqL1xuXG52YXIgSlNPTlBhdGNoID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvcHNcbiAgICovXG4gIGZ1bmN0aW9uIEpTT05QYXRjaChvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTlBhdGNoKTtcblxuICAgIHRoaXMub3BzID0gb3BzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5XG4gICAqXG4gICAqIEB0b2RvIGhhbmRsZSBlcnJvcnMvcm9sbCBiYWNrXG4gICAqIEB0b2RvIHByb3RlY3QgcHJvcGVydGllcyB0aGF0IGFyZSBwcml2YXRlIGluIHRoZSBzY2hlbWFcbiAgICogQHRvZG8gbWFwIEpTT04gUG9pbnRlcnMgcmVhbCBwcm9wZXJ0eSBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEpTT05QYXRjaCwgW3tcbiAgICBrZXk6ICdhcHBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5vcHMuZm9yRWFjaChmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBvcCA9IG9wZXJhdGlvbi5vcDtcblxuICAgICAgICBpZiAoIW9wKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwib3BcIiBpbiBKU09OIFBhdGNoIG9wZXJhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9QRVJBVElPTlMuaW5kZXhPZihvcCkgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwib3BcIiBpbiBKU09OIFBhdGNoIG9wZXJhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcGVyYXRpb24ucGF0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcInBhdGhcIiBpbiBKU09OIFBhdGNoIG9wZXJhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXNbb3BdKG9wZXJhdGlvbiwgdGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwidmFsdWVcIiBpbiBKU09OIFBhdGNoIGFkZCBvcGVyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgSlNPTlBvaW50ZXIob3AucGF0aCwgU0lMRU5UKTtcbiAgICAgIHBvaW50ZXIuYWRkKHRhcmdldCwgb3AudmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUob3AsIHRhcmdldCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgSlNPTlBvaW50ZXIob3AucGF0aCk7XG4gICAgICBwb2ludGVyLnJlbW92ZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2Uob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwidmFsdWVcIiBpbiBKU09OIFBhdGNoIHJlcGxhY2Ugb3BlcmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gbmV3IEpTT05Qb2ludGVyKG9wLnBhdGgpO1xuICAgICAgcG9pbnRlci5yZXBsYWNlKHRhcmdldCwgb3AudmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLmZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJmcm9tXCIgaW4gSlNPTiBQYXRjaCBtb3ZlIG9wZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3AucGF0aC5tYXRjaChuZXcgUmVnRXhwKCdeJyArIG9wLmZyb20pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJmcm9tXCIgaW4gSlNPTiBQYXRjaCBtb3ZlIG9wZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IG5ldyBKU09OUG9pbnRlcihvcC5wYXRoKTtcbiAgICAgIHZhciBmcm9tID0gbmV3IEpTT05Qb2ludGVyKG9wLmZyb20pO1xuICAgICAgdmFyIHZhbHVlID0gZnJvbS5nZXQodGFyZ2V0KTtcblxuICAgICAgZnJvbS5yZW1vdmUodGFyZ2V0KTtcbiAgICAgIHBvaW50ZXIuYWRkKHRhcmdldCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY29weScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLmZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJmcm9tXCIgaW4gSlNPTiBQYXRjaCBjb3B5IG9wZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IG5ldyBKU09OUG9pbnRlcihvcC5wYXRoKTtcbiAgICAgIHZhciBmcm9tID0gbmV3IEpTT05Qb2ludGVyKG9wLmZyb20pO1xuICAgICAgdmFyIHZhbHVlID0gZnJvbS5nZXQodGFyZ2V0KTtcblxuICAgICAgcG9pbnRlci5hZGQodGFyZ2V0LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdChvcCwgdGFyZ2V0KSB7XG4gICAgICBpZiAob3AudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJ2YWx1ZVwiIGluIEpTT04gUGF0Y2ggdGVzdCBvcGVyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgSlNPTlBvaW50ZXIob3AucGF0aCk7XG4gICAgICB2YXIgdmFsdWUgPSBwb2ludGVyLmdldCh0YXJnZXQpO1xuXG4gICAgICBzd2l0Y2ggKF90eXBlb2Yob3AudmFsdWUpKSB7XG4gICAgICAgIC8vY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgLy9jYXNlICdudW1iZXInOlxuICAgICAgICAvL2Nhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAvLyAgaWYgKHZhbHVlICE9PSBvcC52YWx1ZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc21hdGNoaW5nIEpTT04gUGF0Y2ggdGVzdCB2YWx1ZScpXG4gICAgICAgIC8vICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBvcC52YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBKU09OIFBhdGNoIHRlc3QgdmFsdWUnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpTT05QYXRjaDtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRzXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QYXRjaDtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIE1vZGUgZW51bWVyYXRpb25cbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVEhST1cgPSAwO1xudmFyIFJFQ09WRVIgPSAxO1xudmFyIFNJTEVOVCA9IDI7XG5cbi8qKlxuICogSlNPTlBvaW50ZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEltcGxlbWVudHMgUkZDIDY5MDE6IEphdmFTY3JpcHQgT2JqZWN0IE5vdGF0aW9uIChKU09OKSBQb2ludGVyXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICovXG5cbnZhciBKU09OUG9pbnRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEpTT05Qb2ludGVyKGV4cHIsIG1vZGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTlBvaW50ZXIpO1xuXG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgICB0aGlzLm1vZGUgPSBtb2RlIHx8IFRIUk9XO1xuICAgIHRoaXMudG9rZW5zID0gZXhwciAmJiBleHByLmNoYXJBdCgwKSA9PT0gJyMnID8gdGhpcy5wYXJzZVVSSUZyYWdtZW50SWRlbnRpZmllcihleHByKSA6IHRoaXMucGFyc2VKU09OU3RyaW5nKGV4cHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhKU09OUG9pbnRlciwgW3tcbiAgICBrZXk6ICdlc2NhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGUoZXhwcikge1xuICAgICAgcmV0dXJuIGV4cHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5lc2NhcGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5lc2NhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmVzY2FwZShleHByKSB7XG4gICAgICByZXR1cm4gZXhwci5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VKU09OU3RyaW5nJyxcblxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgSlNPTiBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBQYXJzZSBhbiBleHByZXNzaW9uIGludG8gYSBsaXN0IG9mIHRva2Vuc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUpTT05TdHJpbmcoZXhwcikge1xuICAgICAgaWYgKHR5cGVvZiBleHByICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04gUG9pbnRlciBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHByID09PSAnJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChleHByLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIFBvaW50ZXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cHIgPT09ICcvJykge1xuICAgICAgICByZXR1cm4gWycnXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHIuc3Vic3RyKDEpLnNwbGl0KCcvJykubWFwKHRoaXMudW5lc2NhcGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvIEpTT04gU3RyaW5nXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVuZGVyIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBwb2ludGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9KU09OU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcvJyArIHRoaXMudG9rZW5zLm1hcCh0aGlzLmVzY2FwZSkuam9pbignLycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIFVSSSBGcmFnbWVudCBJZGVudGlmZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VVUklGcmFnbWVudElkZW50aWZpZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVVSSUZyYWdtZW50SWRlbnRpZmllcihleHByKSB7XG4gICAgICBpZiAodHlwZW9mIGV4cHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTiBQb2ludGVyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cHIuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gUG9pbnRlciBVUkkgRnJhZ21lbnQgSWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUpTT05TdHJpbmcoZGVjb2RlVVJJQ29tcG9uZW50KGV4cHIuc3Vic3RyKDEpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gVVJJIEZyYWdtZW50IElkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW5kZXIgYSBVUkkgRnJhZ21lbnQgSWRlbnRpZmllciByZXByZXNlbnRhdGlvbiBvZiBhIHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1VSSUZyYWdtZW50SWRlbnRpZmllcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvVVJJRnJhZ21lbnRJZGVudGlmaWVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy50b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KF90aGlzLmVzY2FwZSh0b2tlbikpO1xuICAgICAgfSkuam9pbignLycpO1xuXG4gICAgICByZXR1cm4gJyMvJyArIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBvYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgcG9pbnRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHNvdXJjZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBzb3VyY2U7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghY3VycmVudCB8fCBjdXJyZW50W3Rva2Vuc1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGUgIT09IFRIUk9XKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBQb2ludGVyIHJlZmVyZW5jZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3Rva2Vuc1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCBhIHZhbHVlIG9uIGEgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBwb2ludGVyLiBQdXRcbiAgICAgKiB3aWxsIGluc2VydCBhbiBhcnJheSBlbGVtZW50LiBUbyBjaGFuZ2UgYW4gZXhpc3RpbmcgYXJyYXkgZWxlbW5lbnQsIHVzZVxuICAgICAqIGBwb2ludGVyLnNldCgpYFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnM7XG4gICAgICB2YXIgY3VycmVudCA9IHRhcmdldDtcblxuICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIHRoZSB0b2tlbnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICAvLyBzZXQgdGhlIHByb3BlcnR5IG9uIHRoZSB0YXJnZXQgbG9jYXRpb25cbiAgICAgICAgaWYgKGkgPT09IHRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaWYgKHRva2VuID09PSAnLScpIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjdXJyZW50LnNwbGljZSh0b2tlbiwgMCwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudFt0b2tlbl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBoYW5kbGUgbWlzc2luZyB0YXJnZXQgbG9jYXRpb24gYmFzZWQgb24gXCJtb2RlXCJcbiAgICAgICAgfSBlbHNlIGlmICghY3VycmVudFt0b2tlbl0pIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBUSFJPVzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gUG9pbnRlciByZWZlcmVuY2UnKTtcblxuICAgICAgICAgICAgY2FzZSBSRUNPVkVSOlxuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFt0b2tlbl0gPSBwYXJzZUludCh0b2tlbikgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTSUxFTlQ6XG4gICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvaW50ZXIgbW9kZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlZmVyZW5jZSB0aGUgbmV4dCBvYmplY3QgaW4gdGhlIHBhdGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IGEgdmFsdWUgb24gYSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIHBvaW50ZXIuIFNldCB3aWxsXG4gICAgICogb3ZlcndyaXRlIGFuIGV4aXN0aW5nIGFycmF5IGVsZW1lbnQgYXQgdGhlIHRhcmdldCBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnM7XG4gICAgICB2YXIgY3VycmVudCA9IHRhcmdldDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmIChpID09PSB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGN1cnJlbnRbdG9rZW5dID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbdG9rZW5dID0gcGFyc2VJbnQodG9rZW4pID8gW10gOiB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxcbiAgICAgKlxuICAgICAqIC0gaWYgdGhpcyBpcyBhbiBhcnJheSBpdCBzaG91bGQgc3BsaWNlIHRoZSB2YWx1ZSBvdXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHRhcmdldCkge1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuICAgICAgdmFyIGN1cnJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRbdG9rZW5dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICBjdXJyZW50LnNwbGljZSh0b2tlbiwgMSk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGRlbGV0ZSBjdXJyZW50W3Rva2VuXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3Rva2VuXTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVsZXRlIGZyb20gdGhlIHRhcmdldFxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncGFyc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShleHByKSB7XG4gICAgICByZXR1cm4gbmV3IEpTT05Qb2ludGVyKGV4cHIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKU09OUG9pbnRlcjtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRzXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05Qb2ludGVyO1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBKU09OUG9pbnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG4vKipcbiAqIEpTT05Qb2ludGVyIG1vZGVcbiAqL1xudmFyIFJFQ09WRVIgPSAxO1xuXG4vKipcbiAqIEpTT05NYXBwaW5nXG4gKlxuICogQGNsYXNzXG4gKiBEZWZpbmVzIGEgbWVhbnMgdG8gZGVjbGFyYXRpdmVseSB0cmFuc2xhdGUgYmV0d2VlbiBvYmplY3RcbiAqIHJlcHJlc2VudGF0aW9ucyB1c2luZyBKU09OIFBvaW50ZXIgc3ludGF4LlxuICovXG5cbnZhciBKU09OTWFwcGluZyA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIFRyYW5zbGF0ZSBwb2ludGVycyBmcm9tIEpTT04gU3RyaW5ncyBpbnRvIFBvaW50ZXIgb2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwcGluZ1xuICAgKi9cbiAgZnVuY3Rpb24gSlNPTk1hcHBpbmcobWFwcGluZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTk1hcHBpbmcpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtYXBwaW5nJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgfSk7XG5cbiAgICBPYmplY3Qua2V5cyhtYXBwaW5nKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1hcHBpbmdba2V5XTtcbiAgICAgIF90aGlzLm1hcHBpbmcuc2V0KG5ldyBKU09OUG9pbnRlcihrZXksIFJFQ09WRVIpLCBuZXcgSlNPTlBvaW50ZXIodmFsdWUsIFJFQ09WRVIpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIEFzc2lnbiB2YWx1ZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IGJ5IHJlYWRpbmcgdGhlIG1hcHBpbmdcbiAgICogZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSlNPTk1hcHBpbmcsIFt7XG4gICAga2V5OiAnbWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKHRhcmdldCwgc291cmNlKSB7XG4gICAgICB0aGlzLm1hcHBpbmcuZm9yRWFjaChmdW5jdGlvbiAocmlnaHQsIGxlZnQpIHtcbiAgICAgICAgbGVmdC5hZGQodGFyZ2V0LCByaWdodC5nZXQoc291cmNlKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQXNzaWduIHZhbHVlcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgYnkgcmVhZGluZyB0aGUgbWFwcGluZ1xuICAgICAqIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdChzb3VyY2UsIHRhcmdldCkge1xuICAgICAgdGhpcy5tYXBwaW5nLmZvckVhY2goZnVuY3Rpb24gKHJpZ2h0LCBsZWZ0KSB7XG4gICAgICAgIHJpZ2h0LmFkZCh0YXJnZXQsIGxlZnQuZ2V0KHNvdXJjZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpTT05NYXBwaW5nO1xufSgpO1xuXG4vKipcbiAqIEV4cG9ydHNcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTk1hcHBpbmc7XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKiBAaWdub3JlXG4gKi9cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSW5pdGlhbGl6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBWYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuLyoqXG4gKiBKU09OU2NoZW1hXG4gKlxuICogQGNsYXNzXG4gKiBDb21waWxlcyBKU09OIFNjaGVtYSBkb2N1bWVudHMgdG8gYW4gb2JqZWN0IHdpdGggb2JqZWN0IGluaXRpYWxpemF0aW9uXG4gKiBhbmQgdmFsaWRhdGlvbiBtZXRob2RzLlxuICovXG5cbnZhciBKU09OU2NoZW1hID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gICAqL1xuICBmdW5jdGlvbiBKU09OU2NoZW1hKHNjaGVtYSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKU09OU2NoZW1hKTtcblxuICAgIC8vIFRPRE86IG9wdGlvbmFsbHkgcGFyc2UgSlNPTiBzdHJpbmc/XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBzY2hlbWEpO1xuXG4gICAgLy8gYWRkIHNjaGVtYS1kZXJpdmVkIGluaXRpYWxpemUgYW5kIHZhbGlkYXRlIG1ldGhvZHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBpbml0aWFsaXplOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0ZWFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogSW5pdGlhbGl6ZXIuY29tcGlsZShzY2hlbWEpXG4gICAgICB9LFxuICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBWYWxpZGF0b3IuY29tcGlsZShzY2hlbWEpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAuLi5cbiAgICogRGVhciBmdXR1cmUsXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2FzIG1ldGljdWxvdXNseSBwbGFnaWFyaXplZCBmcm9tIHNvbWUgY3VyaW91cyBhbWFsZ2FtIG9mXG4gICAqIHN0YWNrb3ZlcmZsb3cgcG9zdHMgd2hpbHN0IGRvemluZyBvZmYgYXQgbXkga2V5Ym9hcmQsIHRvbyBkZXByaXZlZCBvZiBSRU0tXG4gICAqIHNsZWVwIHRvIHJlY3Vyc2UgdW5hc3Npc3RlZC4gSWYgaXQgc3Vja3MsIHlvdSBoYXZlIG9ubHkgeW91cnNlbGYgdG8gYmxhbWUuXG4gICAqXG4gICAqIEdvb2RuaWdodC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYVxuICAgKiBAcmV0dXJucyB7SlNPTlNjaGVtYX1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSlNPTlNjaGVtYSwgW3tcbiAgICBrZXk6ICdleHRlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmQoc2NoZW1hKSB7XG4gICAgICBmdW5jdGlvbiBpc09iamVjdChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhICYmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBleHRlbmRlcih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgICAgICAgIGlmICghKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBzb3VyY2Vba2V5XSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZXh0ZW5kZXIodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBzb3VyY2Vba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXNjcmlwdG9yID0gZXh0ZW5kZXIodGhpcywgc2NoZW1hKTtcbiAgICAgIHJldHVybiBuZXcgSlNPTlNjaGVtYShkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSlNPTlNjaGVtYTtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBmb3JtYXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbi8qKlxuICogRm9yIHZhcmlhYmxlIGl0ZXJhdG9yIGNvdW50ZXJcbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgaW5kZXhDb3VudCA9IDA7XG5cbi8qKlxuICogVmFsaWRhdG9yXG4gKlxuICogQ29tcGlsZSBhbiBvYmplY3QgZGVzY3JpYmluZyBhIEpTT04gU2NoZW1hIGludG8gYSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5cbnZhciBWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhWYWxpZGF0b3IsIG51bGwsIFt7XG4gICAga2V5OiAnY29tcGlsZScsXG5cblxuICAgIC8qKlxuICAgICAqIENvbXBpbGUgKHN0YXRpYylcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIENvbXBpbGUgYW4gb2JqZWN0IGRlc2NyaWJpbmcgYSBKU09OIFNjaGVtYSBpbnRvIGEgdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUoc2NoZW1hKSB7XG4gICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzY2hlbWEpO1xuXG4gICAgICB2YXIgYm9keSA9ICdcXG4gICAgICAvLyBcImN1cnNvclwiXFxuICAgICAgbGV0IHZhbHVlID0gZGF0YVxcbiAgICAgIGxldCBjb250YWluZXJcXG4gICAgICBsZXQgc3RhY2sgPSBbXVxcbiAgICAgIGxldCB0b3AgPSAtMVxcblxcbiAgICAgIC8vIGVycm9yIHN0YXRlXFxuICAgICAgbGV0IHZhbGlkID0gdHJ1ZVxcbiAgICAgIGxldCBlcnJvcnMgPSBbXVxcblxcbiAgICAgIC8vIGNvbXBsZXggc2NoZW1hIHN0YXRlXFxuICAgICAgbGV0IGluaXRpYWxWYWxpZGl0eVxcbiAgICAgIGxldCBhbnlWYWxpZFxcbiAgICAgIGxldCBub3RWYWxpZFxcbiAgICAgIGxldCBjb3VudE9mVmFsaWRcXG4gICAgICBsZXQgaW5pdGlhbEVycm9yQ291bnRcXG4gICAgICBsZXQgYWNjdW11bGF0ZWRFcnJvckNvdW50XFxuXFxuICAgICAgLy8gdmFsaWRhdGlvbiBjb2RlXFxuICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuXFxuICAgICAgLy8gdmFsaWRhdGlvbiByZXN1bHRcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdmFsaWQsXFxuICAgICAgICBlcnJvcnNcXG4gICAgICB9XFxuICAgICc7XG5cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2RhdGEnLCBib2R5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBpdGVyYXRvciBpbmRleCBjb3VudGVyIGFuZCBpbmNyZWFzZSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY291bnRlcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gaW5kZXhDb3VudCsrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hIC0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2NoZW1hXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMgLSBjb21waWxhdGlvbiBvcHRpb25zXG4gICAgICovXG5cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFZhbGlkYXRvcihzY2hlbWEpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmFsaWRhdG9yKTtcblxuICAgIC8vIGFzc2lnbiBzY2hlbWEgdG8gdGhpc1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuXG4gICAgLy8gYXNzaWduIGFsbCBvcHRpb25zIHRvIHRoaXNcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gZW5zdXJlIGFkZHJlc3MgaXMgZGVmaW5lZFxuICAgIGlmICghdGhpcy5hZGRyZXNzKSB7XG4gICAgICB0aGlzLmFkZHJlc3MgPSAnJztcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgcmVxdWlyZSBpcyBib29sZWFuXG4gICAgaWYgKHRoaXMucmVxdWlyZSAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5yZXF1aXJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGVcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBpbnN0YW5jZSBjb21waWxlIG1ldGhvZCBpcyBcImR1bWJcIi4gSXQgb25seSBzZXF1ZW5jZXMgaW52b2NhdGlvbiBvZlxuICAgKiBtb3JlIHNwZWNpZmljIGNvbXBpbGF0aW9uIG1ldGhvZHMuIEl0IGdlbmVyYXRlcyBjb2RlIHRvXG4gICAqXG4gICAqICAtIHJlYWQgYSB2YWx1ZSBmcm9tIGlucHV0XG4gICAqICAtIHZhbGlkYXRlIHR5cGUocykgb2YgaW5wdXRcbiAgICogIC0gdmFsaWRhdGUgY29uc3RyYWludHMgZGVzY3JpYmVkIGJ5IHZhcmlvdXMgc2NoZW1hIGtleXdvcmRzXG4gICAqXG4gICAqIENvbmRpdGlvbmFsIGxvZ2ljIHJlbGF0ZWQgdG8gY29kZSBnZW5lcmF0aW9uIGlzIHB1c2hlZCBkb3duc3RlYW0gdG9cbiAgICogdHlwZS1zcGVjaWZpYyBtZXRob2RzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhWYWxpZGF0b3IsIFt7XG4gICAga2V5OiAnY29tcGlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUoKSB7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHRoaXMucmVxdWlyZSkge1xuICAgICAgICBibG9jayArPSB0aGlzLnJlcXVpcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHR5cGUgdmFsaWRhdGlvblxuICAgICAgYmxvY2sgKz0gdGhpcy50eXBlKCk7XG5cbiAgICAgIC8vIHR5cGUgc3BlY2lmaWMgdmFsaWRhdGlvbiBnZW5lcmF0b3JzXG4gICAgICAvLyBudWxsIGFuZCBib29sZWFuIGFyZSBjb3ZlcmVkIGJ5IHRoaXMudHlwZSgpXG4gICAgICAvLyBpbnRlZ2VyIHNob3VsZCBiZSBjb3ZlcmVkIGJ5IG51bWJlciBhbmQgdGhpcy50eXBlKClcbiAgICAgIGJsb2NrICs9IHRoaXMuYXJyYXkoKTtcbiAgICAgIGJsb2NrICs9IHRoaXMubnVtYmVyKCk7XG4gICAgICBibG9jayArPSB0aGlzLm9iamVjdCgpO1xuICAgICAgYmxvY2sgKz0gdGhpcy5zdHJpbmcoKTtcblxuICAgICAgLy8gbm9uLXR5cGUtc3BlY2lmaWMgdmFsaWRhdGlvbiBnZW5lcmF0b3JzXG4gICAgICBibG9jayArPSB0aGlzLmVudW0oKTtcbiAgICAgIGJsb2NrICs9IHRoaXMuYW55T2YoKTtcbiAgICAgIGJsb2NrICs9IHRoaXMuYWxsT2YoKTtcbiAgICAgIGJsb2NrICs9IHRoaXMubm90KCk7XG4gICAgICBibG9jayArPSB0aGlzLm9uZU9mKCk7XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwdXNoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3B1c2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgICAgcmV0dXJuICdcXG4gICAgICBzdGFjay5wdXNoKHZhbHVlKVxcbiAgICAgIGNvbnRhaW5lciA9IHZhbHVlXFxuICAgICAgdG9wKytcXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwb3BcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncG9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKCkge1xuICAgICAgcmV0dXJuICdcXG4gICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSkge1xcbiAgICAgICAgdG9wLS1cXG4gICAgICAgIHN0YWNrLnBvcCgpXFxuICAgICAgfVxcblxcbiAgICAgIHZhbHVlID0gY29udGFpbmVyID0gc3RhY2tbdG9wXVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHR5cGVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQW4gaW5zdGFuY2UgbWF0Y2hlcyBzdWNjZXNzZnVsbHkgaWYgaXRzIHByaW1pdGl2ZSB0eXBlIGlzIG9uZSBvZiB0aGVcbiAgICAgKiA+IHR5cGVzIGRlZmluZWQgYnkga2V5d29yZC4gUmVjYWxsOiBcIm51bWJlclwiIGluY2x1ZGVzIFwiaW50ZWdlclwiLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS4yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0eXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZSgpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5zY2hlbWEudHlwZSxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgdmFyIHR5cGVzID0gQXJyYXkuaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgICAgIHZhciBjb25kaXRpb25zID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgLy8gVE9ETzogY2FuIHdlIG1ha2UgYSBtYXBwaW5nIG9iamVjdCBmb3IgdGhpcyB0byBjbGVhbiBpdCB1cD9cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FycmF5JykgcmV0dXJuICchQXJyYXkuaXNBcnJheSh2YWx1ZSknO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHJldHVybiAndHlwZW9mIHZhbHVlICE9PSBcXCdib29sZWFuXFwnJztcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2ludGVnZXInKSByZXR1cm4gJyFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSc7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdudWxsJykgcmV0dXJuICd2YWx1ZSAhPT0gbnVsbCc7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSByZXR1cm4gJ3R5cGVvZiB2YWx1ZSAhPT0gXFwnbnVtYmVyXFwnJztcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHJldHVybiAnKHR5cGVvZiB2YWx1ZSAhPT0gXFwnb2JqZWN0XFwnIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSc7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSByZXR1cm4gJ3R5cGVvZiB2YWx1ZSAhPT0gXFwnc3RyaW5nXFwnJztcbiAgICAgICAgfSkuam9pbignICYmICcpO1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAvLyAnICsgYWRkcmVzcyArICcgdHlwZSBjaGVja2luZ1xcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICcgKyBjb25kaXRpb25zICsgJykge1xcbiAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICBrZXl3b3JkOiBcXCd0eXBlXFwnLFxcbiAgICAgICAgICBtZXNzYWdlOiBcXCdpbnZhbGlkIHR5cGVcXCdcXG4gICAgICAgIH0pXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUeXBlLXNwZWNpZmljIHZhbGlkYXRpb25zXG4gICAgICpcbiAgICAgKiBUeXBlIGNoZWNraW5nIGlzIG9wdGlvbmFsIGluIEpTT04gU2NoZW1hLCBhbmQgYSBzY2hlbWEgY2FuIGFsbG93XG4gICAgICogbXVsdGlwbGUgdHlwZXMuIEdlbmVyYXRlZCBjb2RlIG5lZWRzIHRvIGFwcGx5IHR5cGUtc3BlY2lmaWMgdmFsaWRhdGlvbnNcbiAgICAgKiBvbmx5IHRvIGFwcHJvcHJpYXRlIHZhbHVlcywgYW5kIGlnbm9yZSBldmVyeXRoaW5nIGVsc2UuIFR5cGUgdmFsaWRhdGlvblxuICAgICAqIGl0c2VsZiBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgZnJvbSBvdGhlciB2YWxpZGF0aW9uIGtleXdvcmRzLlxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZHMgYGFycmF5YCwgYG51bWJlcmAsIGBvYmplY3RgLCBgc3RyaW5nYCBnZW5lcmF0ZSB0eXBlLXNwZWNpZmljXG4gICAgICogdmFsaWRhdGlvbiBjb2RlIGJsb2Nrcywgd3JhcHBlZCBpbiBhIGNvbmRpdGlvbmFsIHN1Y2ggdGhhdCB0aGV5IHdpbGxcbiAgICAgKiBvbmx5IGJlIGFwcGxpZWQgdG8gdmFsdWVzIG9mIHRoYXQgdHlwZS5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB0aGUgYG51bWJlcmAgbWV0aG9kLCBnaXZlbiB0aGUgc2NoZW1hXG4gICAgICpcbiAgICAgKiAgICAgeyBtaW5pbXVtOiAzIH1cbiAgICAgKlxuICAgICAqIHdpbGwgZ2VuZXJhdGVcbiAgICAgKlxuICAgICAqICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAqICAgICAgIGlmICh2YWx1ZSA8IDMpIHtcbiAgICAgKiAgICAgICAgIHZhbGlkID0gZmFsc2VcbiAgICAgKiAgICAgICAgIGVycm9ycy5wdXNoKHsgbWVzc2FnZTogJy4uLicgfSlcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEludGVnZXIgdmFsdWVzIGFyZSBhbHNvIG51bWJlcnMsIGFuZCBhcmUgdmFsaWRhdGVkIHRoZSBzYW1lIGFzIG51bWJlcnNcbiAgICAgKiBvdGhlciB0aGFuIHRoZSB0eXBlIHZhbGlkYXRpb24gaXRzZWxmLiBUaGVyZWZvcmUgbm8gYGludGVnZXJgIG1ldGhvZCBpc1xuICAgICAqIG5lZWRlZC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGFycmF5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbnZva2UgbWV0aG9kcyBmb3IgYXJyYXktc3BlY2lmaWMga2V5d29yZHMgYW5kIHdyYXAgcmVzdWx0aW5nIGNvZGUgaW5cbiAgICAgKiB0eXBlLWNoZWNraW5nIGNvbmRpdGlvbmFsIHNvIHRoYXQgYW55IHJlc3VsdGluZyB2YWxpZGF0aW9ucyBhcmUgb25seVxuICAgICAqIGFwcGxpZWQgdG8gYXJyYXkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgIHZhciBrZXl3b3JkcyA9IFsnYWRkaXRpb25hbEl0ZW1zJywgJ2l0ZW1zJywgJ21pbkl0ZW1zJywgJ21heEl0ZW1zJywgJ3VuaXF1ZUl0ZW1zJ107XG4gICAgICB2YXIgdmFsaWRhdGlvbnMgPSB0aGlzLnZhbGlkYXRpb25zKGtleXdvcmRzKTtcbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAodmFsaWRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgLyoqXFxuICAgICAgICogQXJyYXkgdmFsaWRhdGlvbnNcXG4gICAgICAgKi9cXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgICAnICsgdmFsaWRhdGlvbnMgKyAnXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBudW1iZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludm9rZSBtZXRob2RzIGZvciBudW1iZXItc3BlY2lmaWMga2V5d29yZHMgYW5kIHdyYXAgcmVzdWx0aW5nIGNvZGUgaW5cbiAgICAgKiB0eXBlLWNoZWNraW5nIGNvbmRpdGlvbmFsIHNvIHRoYXQgYW55IHJlc3VsdGluZyB2YWxpZGF0aW9ucyBhcmUgb25seVxuICAgICAqIGFwcGxpZWQgdG8gbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ251bWJlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG51bWJlcigpIHtcbiAgICAgIHZhciBrZXl3b3JkcyA9IFsnbWluaW11bScsICdtYXhpbXVtJywgJ211bHRpcGxlT2YnXTtcbiAgICAgIHZhciB2YWxpZGF0aW9ucyA9IHRoaXMudmFsaWRhdGlvbnMoa2V5d29yZHMpO1xuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh2YWxpZGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAvKipcXG4gICAgICAgKiBOdW1iZXIgdmFsaWRhdGlvbnNcXG4gICAgICAgKi9cXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcXCdudW1iZXJcXCcpIHtcXG4gICAgICAnICsgdmFsaWRhdGlvbnMgKyAnXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludm9rZSBtZXRob2RzIGZvciBvYmplY3Qtc3BlY2lmaWMga2V5d29yZHMgYW5kIHdyYXAgcmVzdWx0aW5nIGNvZGUgaW5cbiAgICAgKiB0eXBlLWNoZWNraW5nIGNvbmRpdGlvbmFsIHNvIHRoYXQgYW55IHJlc3VsdGluZyB2YWxpZGF0aW9ucyBhcmUgb25seVxuICAgICAqIGFwcGxpZWQgdG8gb2JqZWN0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9iamVjdCgpIHtcbiAgICAgIHZhciBrZXl3b3JkcyA9IFsnbWF4UHJvcGVydGllcycsICdtaW5Qcm9wZXJ0aWVzJywgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJywgJ3Byb3BlcnRpZXMnLCAncGF0dGVyblByb3BlcnRpZXMnLCAnZGVwZW5kZW5jaWVzJywgJ3NjaGVtYURlcGVuZGVuY2llcycsICdwcm9wZXJ0eURlcGVuZGVuY2llcyddO1xuICAgICAgdmFyIHZhbGlkYXRpb25zID0gdGhpcy52YWxpZGF0aW9ucyhrZXl3b3Jkcyk7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHZhbGlkYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8qKlxcbiAgICAgICAqIE9iamVjdCB2YWxpZGF0aW9uc1xcbiAgICAgICAqL1xcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcJ29iamVjdFxcJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgICAnICsgdmFsaWRhdGlvbnMgKyAnXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludm9rZSBtZXRob2RzIGZvciBzdHJpbmctc3BlY2lmaWMga2V5d29yZHMgYW5kIHdyYXAgcmVzdWx0aW5nIGNvZGUgaW5cbiAgICAgKiB0eXBlLWNoZWNraW5nIGNvbmRpdGlvbmFsIHNvIHRoYXQgYW55IHJlc3VsdGluZyB2YWxpZGF0aW9ucyBhcmUgb25seVxuICAgICAqIGFwcGxpZWQgdG8gc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICAgIHZhciBrZXl3b3JkcyA9IFsnbWF4TGVuZ3RoJywgJ21pbkxlbmd0aCcsICdwYXR0ZXJuJywgJ2Zvcm1hdCddO1xuICAgICAgdmFyIHZhbGlkYXRpb25zID0gdGhpcy52YWxpZGF0aW9ucyhrZXl3b3Jkcyk7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHZhbGlkYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8qKlxcbiAgICAgICAqIFN0cmluZyB2YWxpZGF0aW9uc1xcbiAgICAgICAqL1xcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcJ3N0cmluZ1xcJykge1xcbiAgICAgICcgKyB2YWxpZGF0aW9ucyArICdcXG4gICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHZhbGlkYXRpb25zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJdGVyYXRlIG92ZXIgYW4gYXJyYXkgb2Yga2V5d29yZHMgYW5kIGludm9rZSBjb2RlIGdlbmVyYXRvciBtZXRob2RzXG4gICAgICogZm9yIGVhY2guIENvbmNhdGVuYXRlIHRoZSByZXN1bHRzIHRvZ2V0aGVyIGFuZCByZXR1cm4uIFVzZWQgYnkgXCJ0eXBlXCJcbiAgICAgKiBtZXRob2RzIHN1Y2ggYXMgdGhpcy5hcnJheSgpIGFuZCB0aGlzLnN0cmluZygpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXl3b3Jkc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZhbGlkYXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbnMoa2V5d29yZHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIHZhciBjb25zdHJhaW50cyA9IE9iamVjdC5rZXlzKHNjaGVtYSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleXdvcmRzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgICB9KTtcblxuICAgICAgY29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5d29yZCkge1xuICAgICAgICBibG9jayArPSBfdGhpc1trZXl3b3JkXSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbnVtXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRzIHZhbHVlXG4gICAgICogPiBpcyBlcXVhbCB0byBvbmUgb2YgdGhlIGVsZW1lbnRzIGluIHRoaXMga2V5d29yZCdzIGFycmF5IHZhbHVlLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbnVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VudW0oKSB7XG4gICAgICB2YXIgZW51bWVyYXRlZCA9IHRoaXMuc2NoZW1hLmVudW0sXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbJ3ZhbHVlICE9PSB1bmRlZmluZWQnXTtcbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoZW51bWVyYXRlZCkge1xuICAgICAgICBlbnVtZXJhdGVkLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkge1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCgndmFsdWUgIT09ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goJ3ZhbHVlICE9PSAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKCd2YWx1ZSAhPT0gXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCgndmFsdWUgIT09IG51bGwnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnXFwnICE9PSBKU09OLnN0cmluZ2lmeSh2YWx1ZSknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGluZ3MgYXJlIG5vdCB3ZWxsIGluIHRoZSBsYW5kIG9mIGVudW0nKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8qKlxcbiAgICAgICAqIFZhbGlkYXRlIFwiJyArIGFkZHJlc3MgKyAnXCIgZW51bVxcbiAgICAgICAqL1xcbiAgICAgIGlmICgnICsgY29uZGl0aW9ucy5qb2luKCcgJiYgJykgKyAnKSB7XFxuICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgIGtleXdvcmQ6IFxcJ2VudW1cXCcsXFxuICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSArIFxcJyBpcyBub3QgYW4gZW51bWVyYXRlZCB2YWx1ZVxcJ1xcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFueU9mXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRcbiAgICAgKiA+IHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCBhdCBsZWFzdCBvbmUgc2NoZW1hIGRlZmluZWQgYnkgdGhpc1xuICAgICAqID4ga2V5d29yZCdzIHZhbHVlLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS40XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhbnlPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFueU9mKCkge1xuICAgICAgdmFyIGFueU9mID0gdGhpcy5zY2hlbWEuYW55T2YsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFueU9mKSkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICBpbml0aWFsVmFsaWRpdHkgPSB2YWxpZFxcbiAgICAgICAgaW5pdGlhbEVycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoXFxuICAgICAgICBhbnlWYWxpZCA9IGZhbHNlXFxuICAgICAgJztcblxuICAgICAgICBhbnlPZi5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY2hlbWEpIHtcbiAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICBhY2N1bXVsYXRlZEVycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoXFxuICAgICAgICAnICsgdmFsaWRhdG9yLmNvbXBpbGUoKSArICdcXG4gICAgICAgIGlmIChhY2N1bXVsYXRlZEVycm9yQ291bnQgPT09IGVycm9ycy5sZW5ndGgpIHtcXG4gICAgICAgICAgYW55VmFsaWQgPSB0cnVlXFxuICAgICAgICB9XFxuICAgICAgICAnO1xuICAgICAgICB9KTtcblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIGlmIChhbnlWYWxpZCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gaW5pdGlhbFZhbGlkaXR5XFxuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLnNsaWNlKDAsIGluaXRpYWxFcnJvckNvdW50KVxcbiAgICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFsbE9mXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRcbiAgICAgKiA+IHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCBhbGwgc2NoZW1hcyBkZWZpbmVkIGJ5IHRoaXMga2V5d29yZCdzXG4gICAgICogPiB2YWx1ZS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjUuM1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWxsT2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxPZigpIHtcbiAgICAgIHZhciBhbGxPZiA9IHRoaXMuc2NoZW1hLmFsbE9mLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxPZikpIHtcbiAgICAgICAgYWxsT2YuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NoZW1hKSB7XG4gICAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICAnO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9uZU9mXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRcbiAgICAgKiA+IHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCBleGFjdGx5IG9uZSBzY2hlbWEgZGVmaW5lZCBieSB0aGlzXG4gICAgICogPiBrZXl3b3JkJ3MgdmFsdWUuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS41LjVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uZU9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25lT2YoKSB7XG4gICAgICB2YXIgb25lT2YgPSB0aGlzLnNjaGVtYS5vbmVPZixcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob25lT2YpKSB7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogVmFsaWRhdGUgJyArIGFkZHJlc3MgKyAnIG9uZU9mXFxuICAgICAgICAgKi9cXG4gICAgICAgIGluaXRpYWxWYWxpZGl0eSA9IHZhbGlkXFxuICAgICAgICBpbml0aWFsRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGhcXG4gICAgICAgIGNvdW50T2ZWYWxpZCA9IDBcXG4gICAgICAnO1xuXG4gICAgICAgIG9uZU9mLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjaGVtYSkge1xuICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSwgeyBhZGRyZXNzOiBhZGRyZXNzIH0pO1xuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIGFjY3VtdWxhdGVkRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGhcXG4gICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgaWYgKGFjY3VtdWxhdGVkRXJyb3JDb3VudCA9PT0gZXJyb3JzLmxlbmd0aCkge1xcbiAgICAgICAgICBjb3VudE9mVmFsaWQgKz0gMVxcbiAgICAgICAgfVxcbiAgICAgICAgJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICBpZiAoY291bnRPZlZhbGlkID09PSAxKSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBpbml0aWFsVmFsaWRpdHlcXG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuc2xpY2UoMCwgaW5pdGlhbEVycm9yQ291bnQpXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICAgIGtleXdvcmQ6IFxcJ29uZU9mXFwnLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogXFwnd2hhdCBpcyBhIHJlYXNvbmFibGUgZXJyb3IgbWVzc2FnZSBmb3IgdGhpcyBjYXNlP1xcJ1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbm90XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0IGZhaWxzIHRvIHZhbGlkYXRlXG4gICAgICogPiBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGUgc2NoZW1hIGRlZmluZWQgYnkgdGhpcyBrZXl3b3JkLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS42XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdub3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3QoKSB7XG4gICAgICB2YXIgbm90ID0gdGhpcy5zY2hlbWEubm90LFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoKHR5cGVvZiBub3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5vdCkpID09PSAnb2JqZWN0JyAmJiBub3QgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobm90KSkge1xuICAgICAgICB2YXIgc3Vic2NoZW1hID0gbm90O1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIE5PVFxcbiAgICAgICAgICovXFxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBpbml0aWFsVmFsaWRpdHkgPSB2YWxpZFxcbiAgICAgICAgICBpbml0aWFsRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGhcXG4gICAgICAgICAgbm90VmFsaWQgPSB0cnVlXFxuXFxuICAgICAgICAgIGFjY3VtdWxhdGVkRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGhcXG5cXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuXFxuICAgICAgICAgIGlmIChhY2N1bXVsYXRlZEVycm9yQ291bnQgPT09IGVycm9ycy5sZW5ndGgpIHtcXG4gICAgICAgICAgICBub3RWYWxpZCA9IGZhbHNlXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKG5vdFZhbGlkID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBpbml0aWFsVmFsaWRpdHlcXG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuc2xpY2UoMCwgaW5pdGlhbEVycm9yQ291bnQpXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5zbGljZSgwLCBpbml0aWFsRXJyb3JDb3VudClcXG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAgICBrZXl3b3JkOiBcXCdub3RcXCcsXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBcXCdobW0uLi5cXCdcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEl0ZXJhdGUgb3ZlciB0aGUgYHByb3BlcnRpZXNgIHNjaGVtYSBwcm9wZXJ0eSBpZiBpdCBpcyBhbiBvYmplY3QuIEZvciBlYWNoXG4gICAgICoga2V5LCBpbml0aWFsaXplIGEgbmV3IFZhbGlkYXRvciBmb3IgdGhlIHN1YnNjaGVtYSByZXByZXNlbnRlZCBieSB0aGUgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSBhbmQgaW52b2tlIGNvbXBpbGUuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbXBpbGluZyBlYWNoIHN1YnNjaGVtYSB0b1xuICAgICAqIHRoZSBibG9jayBvZiBjb2RlIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzLFxuICAgICAgICAgIHJlcXVpcmVkID0gc2NoZW1hLnJlcXVpcmVkO1xuXG4gICAgICB2YXIgYmxvY2sgPSB0aGlzLnB1c2goKTtcblxuICAgICAgLy8gZW5zdXJlIHRoZSB2YWx1ZSBvZiBcInJlcXVpcmVkXCIgc2NoZW1hIHByb3BlcnR5IGlzIGFuIGFycmF5XG4gICAgICByZXF1aXJlZCA9IEFycmF5LmlzQXJyYXkocmVxdWlyZWQpID8gcmVxdWlyZWQgOiBbXTtcblxuICAgICAgaWYgKCh0eXBlb2YgcHJvcGVydGllcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocHJvcGVydGllcykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgc3Vic2NoZW1hID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgIHZhciBpc1JlcXVpcmVkID0gcmVxdWlyZWQuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgLy8gaG93IHNob3VsZCB3ZSBiZSBjYWxjdWxhdGluZyB0aGVzZSB0aGluZ3M/IHNob3VsZCBiZSBqc29uIHBvaW50ZXI/XG4gICAgICAgICAgLy8gbmVlZHMgYSBzZXBhcmF0ZSBmdW5jdGlvblxuICAgICAgICAgIHZhciBwb2ludGVyID0gW2FkZHJlc3MsIGtleV0uZmlsdGVyKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gISFzZWdtZW50O1xuICAgICAgICAgIH0pLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgdmFsaWRhdGlvbiA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IHBvaW50ZXIsIHJlcXVpcmU6IGlzUmVxdWlyZWQgfSk7XG5cbiAgICAgICAgICAvLyByZWFkIHRoZSB2YWx1ZVxuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIHZhbHVlID0gY29udGFpbmVyW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICAgJztcblxuICAgICAgICAgIGJsb2NrICs9IHZhbGlkYXRpb24uY29tcGlsZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYmxvY2sgKz0gdGhpcy5wb3AoKTtcblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE90aGVyIFByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBmb3IgYSBrZXl3b3JkLiBJdCB3cmFwcyB2YWxpZGF0aW9ucyBmb3JcbiAgICAgKiBwYXR0ZXJuUHJvcGVydGllcyBhbmQgYWRkaXRpb25hbFByb3BlcnRpZXMgaW4gYSBzaW5nbGUgaXRlcmF0aW9uIG92ZXJcbiAgICAgKiBhbiBvYmplY3QtdHlwZSB2YWx1ZSdzIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBJdCBzaG91bGQgb25seSBiZSBpbnZva2VkIG9uY2UgZm9yIGEgZ2l2ZW4gc3Vic2NoZW1hLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb3RoZXJQcm9wZXJ0aWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3RoZXJQcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuICdcXG4gICAgICAvKipcXG4gICAgICAgKiBWYWxpZGF0ZSBPdGhlciBQcm9wZXJ0aWVzXFxuICAgICAgICovXFxuICAgICAgJyArIHRoaXMucHVzaCgpICsgJ1xcblxcbiAgICAgIGZvciAobGV0IGtleSBpbiBjb250YWluZXIpIHtcXG4gICAgICAgIHZhbHVlID0gY29udGFpbmVyW2tleV1cXG4gICAgICAgIG1hdGNoZWQgPSBmYWxzZVxcblxcbiAgICAgICAgJyArIHRoaXMucGF0dGVyblZhbGlkYXRpb25zKCkgKyAnXFxuICAgICAgICAnICsgdGhpcy5hZGRpdGlvbmFsVmFsaWRhdGlvbnMoKSArICdcXG4gICAgICB9XFxuXFxuICAgICAgJyArIHRoaXMucG9wKCkgKyAnXFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiBWYWxpZGF0aW9uc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogR2VuZXJhdGUgdmFsaWRhdGlvbiBjb2RlIGZyb20gYSBzdWJzY2hlbWEgZm9yIHByb3BlcnRpZXMgbWF0Y2hpbmcgYVxuICAgICAqIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhdHRlcm5WYWxpZGF0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdHRlcm5WYWxpZGF0aW9ucygpIHtcbiAgICAgIHZhciBwYXR0ZXJuUHJvcGVydGllcyA9IHRoaXMuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKCh0eXBlb2YgcGF0dGVyblByb3BlcnRpZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdHRlcm5Qcm9wZXJ0aWVzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhdHRlcm5Qcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIHN1YnNjaGVtYSA9IHBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dO1xuICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSk7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICBpZiAoa2V5Lm1hdGNoKFxcJycgKyBwYXR0ZXJuICsgJ1xcJykpIHtcXG4gICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZVxcbiAgICAgICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgICB9XFxuICAgICAgICAnO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uYWwgVmFsaWRhdGlvbnNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdlbmVyYXRlIHZhbGlkYXRpb24gY29kZSwgZWl0aGVyIGZyb20gYSBzdWJzY2hlbWEgZm9yIHByb3BlcnRpZXMgbm90XG4gICAgICogZGVmaW5lZCBpbiB0aGUgc2NoZW1hLCBvciB0byBkaXNhbGxvdyBwcm9wZXJ0aWVzIG5vdCBkZWZpbmVkIGluIHRoZVxuICAgICAqIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZGl0aW9uYWxWYWxpZGF0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZGl0aW9uYWxWYWxpZGF0aW9ucygpIHtcbiAgICAgIHZhciBfc2NoZW1hID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgcHJvcGVydGllcyA9IF9zY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IF9zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIHZhbGlkYXRpb25zID0gJyc7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgLy8gY2F0Y2ggYWRkaXRpb25hbCB1bm1hdGNoZWQgcHJvcGVydGllc1xuICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbJ21hdGNoZWQgIT09IHRydWUnXTtcblxuICAgICAgLy8gaWdub3JlIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNvbmRpdGlvbnMucHVzaCgna2V5ICE9PSBcXCcnICsga2V5ICsgJ1xcJycpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHZhbGlkYXRlIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICAgICAgaWYgKCh0eXBlb2YgYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFkZGl0aW9uYWxQcm9wZXJ0aWVzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBzdWJzY2hlbWEgPSBhZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IGFkZHJlc3MgKyAnW0FQS2V5XScgfSk7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8vIHZhbGlkYXRlIGFkZGl0aW9uYWwgcHJvcGVydGllc1xcbiAgICAgICAgaWYgKCcgKyBjb25kaXRpb25zLmpvaW4oJyAmJiAnKSArICcpIHtcXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgLy8gZXJyb3IgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICAgICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvLyB2YWxpZGF0ZSBub24tcHJlc2VuY2Ugb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXFxuICAgICAgICBpZiAoJyArIGNvbmRpdGlvbnMuam9pbignICYmICcpICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdhZGRpdGlvbmFsUHJvcGVydGllc1xcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBrZXkgKyBcXCcgaXMgbm90IGEgZGVmaW5lZCBwcm9wZXJ0eVxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwYXR0ZXJuUHJvcGVydGllc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogR2VuZXJhdGUgdmFsaWRhdGlvbiBjb2RlIGZvciBwcm9wZXJ0aWVzIG1hdGNoaW5nIGEgcGF0dGVyblxuICAgICAqIGRlZmluZWQgYnkgdGhlIHByb3BlcnR5IG5hbWUgKGtleSksIHdoaWNoIG11c3QgYmUgYSBzdHJpbmdcbiAgICAgKiByZXByZXNlbnRpbmcgYSB2YWxpZCByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXR0ZXJuUHJvcGVydGllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdHRlcm5Qcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICghdGhpcy5vdGhlclByb3BlcnRpZXNDYWxsZWQpIHtcbiAgICAgICAgdGhpcy5vdGhlclByb3BlcnRpZXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICBibG9jayArPSB0aGlzLm90aGVyUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdlbmVyYXRlIHZhbGlkYXRpb24gY29kZSBmb3IgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG5vdCBkZWZpbmVkXG4gICAgICogaW4gdGhlIHNjaGVtYSwgb3IgZGlzYWxsb3cgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGlmIHRoZSB2YWx1ZSBvZlxuICAgICAqIGBhZGRpdGlvbmFsUHJvcGVydGllc2AgaW4gdGhlIHNjaGVtYSBpcyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkaXRpb25hbFByb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydGllcygpIHtcbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoIXRoaXMub3RoZXJQcm9wZXJ0aWVzQ2FsbGVkKSB7XG4gICAgICAgIHRoaXMub3RoZXJQcm9wZXJ0aWVzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgYmxvY2sgKz0gdGhpcy5vdGhlclByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1pblByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQW4gb2JqZWN0IGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgXCJtaW5Qcm9wZXJ0aWVzXCIgaWYgaXRzIG51bWJlciBvZlxuICAgICAqID4gcHJvcGVydGllcyBpcyBncmVhdGVyIHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgdGhpcyBrZXl3b3JkLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNC4yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluUHJvcGVydGllcygpIHtcbiAgICAgIHZhciBtaW5Qcm9wZXJ0aWVzID0gdGhpcy5zY2hlbWEubWluUHJvcGVydGllcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgbWluIHByb3BlcnRpZXNcXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoIDwgJyArIG1pblByb3BlcnRpZXMgKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21pblByb3BlcnRpZXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIGZldyBwcm9wZXJ0aWVzXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWF4UHJvcGVydGllc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBvYmplY3QgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCBcIm1heFByb3BlcnRpZXNcIiBpZiBpdHMgbnVtYmVyIG9mXG4gICAgICogPiBwcm9wZXJ0aWVzIGlzIGxlc3MgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSB2YWx1ZSBvZiB0aGlzIGtleXdvcmQuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS40LjFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21heFByb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhQcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIG1heFByb3BlcnRpZXMgPSB0aGlzLnNjaGVtYS5tYXhQcm9wZXJ0aWVzLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cblxuICAgICAgcmV0dXJuICdcXG4gICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyBtYXggcHJvcGVydGllc1xcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPiAnICsgbWF4UHJvcGVydGllcyArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbWF4UHJvcGVydGllc1xcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCd0b28gbWFueSBwcm9wZXJ0aWVzXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVwZW5kZW5jaWVzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEZvciBhbGwgKG5hbWUsIHNjaGVtYSkgcGFpciBvZiBzY2hlbWEgZGVwZW5kZW5jaWVzLCBpZiB0aGUgaW5zdGFuY2UgaGFzXG4gICAgICogPiBhIHByb3BlcnR5IGJ5IHRoaXMgbmFtZSwgdGhlbiBpdCBtdXN0IGFsc28gdmFsaWRhdGUgc3VjY2Vzc2Z1bGx5IGFnYWluc3RcbiAgICAgKiA+IHRoZSBzY2hlbWEuXG4gICAgICogPlxuICAgICAqID4gTm90ZSB0aGF0IHRoaXMgaXMgdGhlIGluc3RhbmNlIGl0c2VsZiB3aGljaCBtdXN0IHZhbGlkYXRlIHN1Y2Nlc3NmdWxseSxcbiAgICAgKiA+IG5vdCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqID5cbiAgICAgKiA+IEZvciBlYWNoIChuYW1lLCBwcm9wZXJ0eXNldCkgcGFpciBvZiBwcm9wZXJ0eSBkZXBlbmRlbmNpZXMsIGlmIHRoZVxuICAgICAqID4gaW5zdGFuY2UgaGFzIGEgcHJvcGVydHkgYnkgdGhpcyBuYW1lLCB0aGVuIGl0IG11c3QgYWxzbyBoYXZlIHByb3BlcnRpZXNcbiAgICAgKiA+IHdpdGggdGhlIHNhbWUgbmFtZXMgYXMgcHJvcGVydHlzZXQuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS40LjUuMlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVwZW5kZW5jaWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVwZW5kZW5jaWVzKCkge1xuICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IHRoaXMuc2NoZW1hLmRlcGVuZGVuY2llcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHZhciBibG9jayA9IHRoaXMucHVzaCgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBkZXBlbmRlbmNpZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRlcGVuZGVuY2llcykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2tleV07XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbXTtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmN5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKCdjb250YWluZXJbXFwnJyArIGl0ZW0gKyAnXFwnXSA9PT0gdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICAgIGlmIChjb250YWluZXJbXFwnJyArIGtleSArICdcXCddICE9PSB1bmRlZmluZWQgJiYgKCcgKyBjb25kaXRpb25zLmpvaW4oJyB8fCAnKSArICcpKSB7XFxuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFxcJ2RlcGVuZGVuY2llc1xcJyxcXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXFwndW5tZXQgZGVwZW5kZW5jaWVzXFwnXFxuICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgJztcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGVwZW5kZW5jeSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGVwZW5kZW5jeSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIHN1YnNjaGVtYSA9IGRlcGVuZGVuY3k7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcblxuICAgICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICAgIGlmIChjb250YWluZXJbXFwnJyArIGtleSArICdcXCddICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBibG9jayArPSB0aGlzLnBvcCgpO1xuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWRcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQW4gb2JqZWN0IGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0cyBwcm9wZXJ0eSBzZXRcbiAgICAgKiA+IGNvbnRhaW5zIGFsbCBlbGVtZW50cyBpbiB0aGlzIGtleXdvcmQncyBhcnJheSB2YWx1ZS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjQuM1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVxdWlyZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1aXJlZCgpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5zY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8vIHZhbGlkYXRlICcgKyBhZGRyZXNzICsgJyBwcmVzZW5jZVxcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgIGtleXdvcmQ6IFxcJ3JlcXVpcmVkXFwnLFxcbiAgICAgICAgICBtZXNzYWdlOiBcXCdpcyByZXF1aXJlZFxcJ1xcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgICc7XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGRpdGlvbmFsSXRlbXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3VjY2Vzc2Z1bCB2YWxpZGF0aW9uIG9mIGFuIGFycmF5IGluc3RhbmNlIHdpdGggcmVnYXJkcyB0byB0aGVzZSB0d29cbiAgICAgKiA+IGtleXdvcmRzIGlzIGRldGVybWluZWQgYXMgZm9sbG93czogaWYgXCJpdGVtc1wiIGlzIG5vdCBwcmVzZW50LCBvciBpdHNcbiAgICAgKiA+IHZhbHVlIGlzIGFuIG9iamVjdCwgdmFsaWRhdGlvbiBvZiB0aGUgaW5zdGFuY2UgYWx3YXlzIHN1Y2NlZWRzLFxuICAgICAqID4gcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgXCJhZGRpdGlvbmFsSXRlbXNcIjsgaWYgdGhlIHZhbHVlIG9mXG4gICAgICogPiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGJvb2xlYW4gdmFsdWUgdHJ1ZSBvciBhbiBvYmplY3QsIHZhbGlkYXRpb24gb2ZcbiAgICAgKiA+IHRoZSBpbnN0YW5jZSBhbHdheXMgc3VjY2VlZHM7IGlmIHRoZSB2YWx1ZSBvZiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzXG4gICAgICogPiBib29sZWFuIHZhbHVlIGZhbHNlIGFuZCB0aGUgdmFsdWUgb2YgXCJpdGVtc1wiIGlzIGFuIGFycmF5LCB0aGVcbiAgICAgKiA+IGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0cyBzaXplIGlzIGxlc3MgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSBzaXplXG4gICAgICogPiBvZiBcIml0ZW1zXCIuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS4zLjFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZGl0aW9uYWxJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZGl0aW9uYWxJdGVtcygpIHtcbiAgICAgIHZhciBfc2NoZW1hMiA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIGl0ZW1zID0gX3NjaGVtYTIuaXRlbXMsXG4gICAgICAgICAgYWRkaXRpb25hbEl0ZW1zID0gX3NjaGVtYTIuYWRkaXRpb25hbEl0ZW1zLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoYWRkaXRpb25hbEl0ZW1zID09PSBmYWxzZSAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvLyBkb25cXCd0IGFsbG93IGFkZGl0aW9uYWwgaXRlbXNcXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAnICsgaXRlbXMubGVuZ3RoICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdhZGRpdGlvbmFsSXRlbXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwnYWRkaXRpb25hbCBpdGVtcyBub3QgYWxsb3dlZFxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIGlmICgodHlwZW9mIGFkZGl0aW9uYWxJdGVtcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYWRkaXRpb25hbEl0ZW1zKSkgPT09ICdvYmplY3QnICYmIGFkZGl0aW9uYWxJdGVtcyAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICB2YXIgc3Vic2NoZW1hID0gYWRkaXRpb25hbEl0ZW1zO1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEpO1xuICAgICAgICB2YXIgY291bnRlciA9IFZhbGlkYXRvci5jb3VudGVyO1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgaXRlbXNcXG4gICAgICAgICcgKyB0aGlzLnB1c2goKSArICdcXG5cXG4gICAgICAgIGZvciAodmFyIGknICsgY291bnRlciArICcgPSAnICsgaXRlbXMubGVuZ3RoICsgJzsgaScgKyBjb3VudGVyICsgJyA8PSBjb250YWluZXIubGVuZ3RoOyBpJyArIGNvdW50ZXIgKyAnKyspIHtcXG4gICAgICAgICAgdmFsdWUgPSBjb250YWluZXJbaScgKyBjb3VudGVyICsgJ11cXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICB9XFxuXFxuICAgICAgICAnICsgdGhpcy5wb3AoKSArICdcXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlbXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3VjY2Vzc2Z1bCB2YWxpZGF0aW9uIG9mIGFuIGFycmF5IGluc3RhbmNlIHdpdGggcmVnYXJkcyB0byB0aGVzZSB0d29cbiAgICAgKiA+IGtleXdvcmRzIGlzIGRldGVybWluZWQgYXMgZm9sbG93czogaWYgXCJpdGVtc1wiIGlzIG5vdCBwcmVzZW50LCBvciBpdHNcbiAgICAgKiA+IHZhbHVlIGlzIGFuIG9iamVjdCwgdmFsaWRhdGlvbiBvZiB0aGUgaW5zdGFuY2UgYWx3YXlzIHN1Y2NlZWRzLFxuICAgICAqID4gcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgXCJhZGRpdGlvbmFsSXRlbXNcIjsgaWYgdGhlIHZhbHVlIG9mXG4gICAgICogPiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGJvb2xlYW4gdmFsdWUgdHJ1ZSBvciBhbiBvYmplY3QsIHZhbGlkYXRpb24gb2ZcbiAgICAgKiA+IHRoZSBpbnN0YW5jZSBhbHdheXMgc3VjY2VlZHM7IGlmIHRoZSB2YWx1ZSBvZiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzXG4gICAgICogPiBib29sZWFuIHZhbHVlIGZhbHNlIGFuZCB0aGUgdmFsdWUgb2YgXCJpdGVtc1wiIGlzIGFuIGFycmF5LCB0aGVcbiAgICAgKiA+IGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0cyBzaXplIGlzIGxlc3MgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSBzaXplXG4gICAgICogPiBvZiBcIml0ZW1zXCIuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS4zLjFcbiAgICAgKlxuICAgICAqIENvZGUgdG8gZ2VuZXJhdGVcbiAgICAgKlxuICAgICAqICAgICAvLyB0aGlzIG91dGVyIGNvbmRpdGlvbmFsIGlzIGdlbmVyYXRlZCBieSB0aGlzLmFycmF5KClcbiAgICAgKiAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHtcbiAgICAgKiAgICAgICBsZXQgcGFyZW50ID0gdmFsdWVcbiAgICAgKiAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5sZW5ndGg7IGkrKykge1xuICAgICAqICAgICAgICAgdmFsdWUgPSBwYXJlbnRbaV1cbiAgICAgKiAgICAgICAgIC8vIG90aGVyIHZhbGlkYXRpb24gY29kZSBkZXBlbmRpbmcgb24gdmFsdWUgaGVyZVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgICB2YWx1ZSA9IHBhcmVudFxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2l0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLnNjaGVtYS5pdGVtcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgLy8gaWYgaXRlbXMgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBibG9jayArPSB0aGlzLnB1c2goKTtcblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgIHZhciBzdWJzY2hlbWEgPSBpdGVtO1xuICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSwgeyBhZGRyZXNzOiBhZGRyZXNzICsgJ1snICsgaW5kZXggKyAnXScgfSk7XG5cbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIC8vIGl0ZW0gIycgKyBpbmRleCArICdcXG4gICAgICAgICAgdmFsdWUgPSBjb250YWluZXJbJyArIGluZGV4ICsgJ11cXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICAnO1xuICAgICAgICB9KTtcblxuICAgICAgICBibG9jayArPSB0aGlzLnBvcCgpO1xuXG4gICAgICAgIC8vIGlmIGl0ZW1zIGlzIGFuIG9iamVjdFxuICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGl0ZW1zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpdGVtcykpID09PSAnb2JqZWN0JyAmJiBpdGVtcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgc3Vic2NoZW1hID0gaXRlbXM7XG4gICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSk7XG4gICAgICAgIHZhciBjb3VudGVyID0gVmFsaWRhdG9yLmNvdW50ZXI7XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgLy8gaXRlbXNcXG4gICAgICAgICcgKyB0aGlzLnB1c2goKSArICdcXG5cXG4gICAgICAgIGZvciAodmFyIGknICsgY291bnRlciArICcgPSAwOyBpJyArIGNvdW50ZXIgKyAnIDwgY29udGFpbmVyLmxlbmd0aDsgaScgKyBjb3VudGVyICsgJysrKSB7XFxuICAgICAgICAgIC8vIHJlYWQgYXJyYXkgZWxlbWVudFxcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcltpJyArIGNvdW50ZXIgKyAnXVxcbiAgICAgICAgICAnICsgdmFsaWRhdG9yLmNvbXBpbGUoKSArICdcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICcgKyB0aGlzLnBvcCgpICsgJ1xcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtaW5JdGVtc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBhcnJheSBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IFwibWluSXRlbXNcIiBpZiBpdHMgc2l6ZSBpcyBncmVhdGVyXG4gICAgICogPiB0aGFuLCBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIHRoaXMga2V5d29yZC5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjMuM1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWluSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5JdGVtcygpIHtcbiAgICAgIHZhciBtaW5JdGVtcyA9IHRoaXMuc2NoZW1hLm1pbkl0ZW1zLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cblxuICAgICAgcmV0dXJuICdcXG4gICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyBtaW4gaXRlbXNcXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCAnICsgbWluSXRlbXMgKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21pbkl0ZW1zXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBmZXcgcHJvcGVydGllc1xcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1heEl0ZW1zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGFycmF5IGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgXCJtYXhJdGVtc1wiIGlmIGl0cyBzaXplIGlzIGxlc3NcbiAgICAgKiA+IHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgdGhpcyBrZXl3b3JkLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMy4yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtYXhJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heEl0ZW1zKCkge1xuICAgICAgdmFyIG1heEl0ZW1zID0gdGhpcy5zY2hlbWEubWF4SXRlbXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuXG4gICAgICByZXR1cm4gJ1xcbiAgICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIG1heCBpdGVtc1xcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+ICcgKyBtYXhJdGVtcyArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbWF4SXRlbXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIG1hbnkgcHJvcGVydGllc1xcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVuaXF1ZUl0ZW1zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IElmIHRoaXMga2V5d29yZCBoYXMgYm9vbGVhbiB2YWx1ZSBmYWxzZSwgdGhlIGluc3RhbmNlIHZhbGlkYXRlc1xuICAgICAqID4gc3VjY2Vzc2Z1bGx5LiBJZiBpdCBoYXMgYm9vbGVhbiB2YWx1ZSB0cnVlLCB0aGUgaW5zdGFuY2UgdmFsaWRhdGVzXG4gICAgICogPiBzdWNjZXNzZnVsbHkgaWYgYWxsIG9mIGl0cyBlbGVtZW50cyBhcmUgdW5pcXVlLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMy40XG4gICAgICpcbiAgICAgKiBUT0RPXG4gICAgICogb3B0aW1pemVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VuaXF1ZUl0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5pcXVlSXRlbXMoKSB7XG4gICAgICB2YXIgdW5pcXVlSXRlbXMgPSB0aGlzLnNjaGVtYS51bmlxdWVJdGVtcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHVuaXF1ZUl0ZW1zID09PSB0cnVlKSB7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8vIHZhbGlkYXRlICcgKyBhZGRyZXNzICsgJyB1bmlxdWUgaXRlbXNcXG4gICAgICAgIGxldCB2YWx1ZXMgPSB2YWx1ZS5tYXAodiA9PiBKU09OLnN0cmluZ2lmeSh2KSkgLy8gVE9ETzogb3B0aW1pemVcXG4gICAgICAgIGxldCBzZXQgPSBuZXcgU2V0KHZhbHVlcylcXG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBzZXQuc2l6ZSkge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCd1bmlxdWVJdGVtc1xcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCdpdGVtcyBtdXN0IGJlIHVuaXF1ZVxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtaW5MZW5ndGhcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQSBzdHJpbmcgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRzIGxlbmd0aCBpc1xuICAgICAqID4gZ3JlYXRlciB0aGFuLCBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIHRoaXMga2V5d29yZC4gVGhlIGxlbmd0aCBvZlxuICAgICAqID4gYSBzdHJpbmcgaW5zdGFuY2UgaXMgZGVmaW5lZCBhcyB0aGUgbnVtYmVyIG9mIGl0cyBjaGFyYWN0ZXJzIGFzXG4gICAgICogPiBkZWZpbmVkIGJ5IFJGQyA0NjI3IFtSRkM0NjI3XS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjIuMlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWluTGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluTGVuZ3RoKCkge1xuICAgICAgdmFyIG1pbkxlbmd0aCA9IHRoaXMuc2NoZW1hLm1pbkxlbmd0aCxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgdmFsaWRhdGUgbWluTGVuZ3RoXFxuICAgICAgICBpZiAoQXJyYXkuZnJvbSh2YWx1ZSkubGVuZ3RoIDwgJyArIG1pbkxlbmd0aCArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbWluTGVuZ3RoXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBzaG9ydFxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1heExlbmd0aFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBIHN0cmluZyBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IHRoaXMga2V5d29yZCBpZiBpdHMgbGVuZ3RoIGlzIGxlc3NcbiAgICAgKiA+IHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgdGhpcyBrZXl3b3JkLiBUaGUgbGVuZ3RoIG9mIGEgc3RyaW5nXG4gICAgICogPiBpbnN0YW5jZSBpcyBkZWZpbmVkIGFzIHRoZSBudW1iZXIgb2YgaXRzIGNoYXJhY3RlcnMgYXMgZGVmaW5lZCBieVxuICAgICAqID4gUkZDIDQ2MjcgW1JGQzQ2MjddLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMi4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtYXhMZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhMZW5ndGgoKSB7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gdGhpcy5zY2hlbWEubWF4TGVuZ3RoLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cblxuICAgICAgcmV0dXJuICdcXG4gICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyB2YWxpZGF0ZSBtYXhMZW5ndGhcXG4gICAgICAgIGlmIChBcnJheS5mcm9tKHZhbHVlKS5sZW5ndGggPiAnICsgbWF4TGVuZ3RoICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdtYXhMZW5ndGhcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIGxvbmdcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXR0ZXJuXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEEgc3RyaW5nIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgdmFsaWQgaWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAqID4gbWF0Y2hlcyB0aGUgaW5zdGFuY2Ugc3VjY2Vzc2Z1bGx5LlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMi4zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXR0ZXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0dGVybigpIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5zY2hlbWEucGF0dGVybixcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiAnXFxuICAgICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyB2YWxpZGF0ZSBwYXR0ZXJuXFxuICAgICAgICAgIGlmICghdmFsdWUubWF0Y2gobmV3IFJlZ0V4cChcXCcnICsgcGF0dGVybiArICdcXCcpKSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAgICBrZXl3b3JkOiBcXCdwYXR0ZXJuXFwnLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogXFwnZG9lcyBub3QgbWF0Y2ggdGhlIHJlcXVpcmVkIHBhdHRlcm5cXCdcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3RydWN0dXJhbCB2YWxpZGF0aW9uIGFsb25lIG1heSBiZSBpbnN1ZmZpY2llbnQgdG8gdmFsaWRhdGUgdGhhdFxuICAgICAqID4gYW4gaW5zdGFuY2UgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgb2YgYW4gYXBwbGljYXRpb24uIFRoZVxuICAgICAqID4gXCJmb3JtYXRcIiBrZXl3b3JkIGlzIGRlZmluZWQgdG8gYWxsb3cgaW50ZXJvcGVyYWJsZSBzZW1hbnRpY1xuICAgICAqID4gdmFsaWRhdGlvbiBmb3IgYSBmaXhlZCBzdWJzZXQgb2YgdmFsdWVzIHdoaWNoIGFyZSBhY2N1cmF0ZWx5XG4gICAgICogPiBkZXNjcmliZWQgYnkgYXV0aG9yaXRhdGl2ZSByZXNvdXJjZXMsIGJlIHRoZXkgUkZDcyBvciBvdGhlclxuICAgICAqID4gZXh0ZXJuYWwgc3BlY2lmaWNhdGlvbnMuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNy4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoKSB7XG4gICAgICB2YXIgZm9ybWF0ID0gdGhpcy5zY2hlbWEuZm9ybWF0LFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBtYXRjaGVyID0gZm9ybWF0cy5yZXNvbHZlKGZvcm1hdCk7XG5cbiAgICAgIGlmIChtYXRjaGVyKSB7XG4gICAgICAgIHJldHVybiAnXFxuICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIHZhbGlkYXRlIGZvcm1hdFxcbiAgICAgIGlmICghdmFsdWUubWF0Y2goJyArIG1hdGNoZXIgKyAnKSkge1xcbiAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICBrZXl3b3JkOiBcXCdmb3JtYXRcXCcsXFxuICAgICAgICAgIG1lc3NhZ2U6IFxcJ2lzIG5vdCBcIicgKyBmb3JtYXQgKyAnXCIgZm9ybWF0XFwnXFxuICAgICAgICB9KVxcbiAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pbmltdW1cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3VjY2Vzc2Z1bCB2YWxpZGF0aW9uIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIGFuZCB2YWx1ZSBvZlxuICAgICAqID4gXCJleGNsdXNpdmVNaW5pbXVtXCI6IGlmIFwiZXhjbHVzaXZlTWluaW11bVwiIGlzIG5vdCBwcmVzZW50LCBvciBoYXNcbiAgICAgKiA+IGJvb2xlYW4gdmFsdWUgZmFsc2UsIHRoZW4gdGhlIGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0IGlzIGdyZWF0ZXJcbiAgICAgKiA+IHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgXCJtaW5pbXVtXCI7IGlmIFwiZXhjbHVzaXZlTWluaW11bVwiIGlzXG4gICAgICogPiBwcmVzZW50IGFuZCBoYXMgYm9vbGVhbiB2YWx1ZSB0cnVlLCB0aGUgaW5zdGFuY2UgaXMgdmFsaWQgaWYgaXQgaXNcbiAgICAgKiA+IHN0cmljdGx5IGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgXCJtaW5pbXVtXCIuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS4xLjNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21pbmltdW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5pbXVtKCkge1xuICAgICAgdmFyIF9zY2hlbWEzID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgbWluaW11bSA9IF9zY2hlbWEzLm1pbmltdW0sXG4gICAgICAgICAgZXhjbHVzaXZlTWluaW11bSA9IF9zY2hlbWEzLmV4Y2x1c2l2ZU1pbmltdW0sXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIG9wZXJhdG9yID0gZXhjbHVzaXZlTWluaW11bSA9PT0gdHJ1ZSA/ICc8PScgOiAnPCc7XG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgdmFsaWRhdGUgbWluaW11bVxcbiAgICAgICAgaWYgKHZhbHVlICcgKyBvcGVyYXRvciArICcgJyArIG1pbmltdW0gKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21pbmltdW1cXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIHNtYWxsXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBTdWNjZXNzZnVsIHZhbGlkYXRpb24gZGVwZW5kcyBvbiB0aGUgcHJlc2VuY2UgYW5kIHZhbHVlIG9mXG4gICAgICogPiBcImV4Y2x1c2l2ZU1heGltdW1cIjogaWYgXCJleGNsdXNpdmVNYXhpbXVtXCIgaXMgbm90IHByZXNlbnQsIG9yIGhhc1xuICAgICAqID4gYm9vbGVhbiB2YWx1ZSBmYWxzZSwgdGhlbiB0aGUgaW5zdGFuY2UgaXMgdmFsaWQgaWYgaXQgaXMgbG93ZXIgdGhhbixcbiAgICAgKiA+IG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgXCJtYXhpbXVtXCI7IGlmIFwiZXhjbHVzaXZlTWF4aW11bVwiIGhhc1xuICAgICAqID4gYm9vbGVhbiB2YWx1ZSB0cnVlLCB0aGUgaW5zdGFuY2UgaXMgdmFsaWQgaWYgaXQgaXMgc3RyaWN0bHkgbG93ZXJcbiAgICAgKiA+IHRoYW4gdGhlIHZhbHVlIG9mIFwibWF4aW11bVwiLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMS4yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtYXhpbXVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4aW11bSgpIHtcbiAgICAgIHZhciBfc2NoZW1hNCA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIG1heGltdW0gPSBfc2NoZW1hNC5tYXhpbXVtLFxuICAgICAgICAgIGV4Y2x1c2l2ZU1heGltdW0gPSBfc2NoZW1hNC5leGNsdXNpdmVNYXhpbXVtLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBvcGVyYXRvciA9IGV4Y2x1c2l2ZU1heGltdW0gPT09IHRydWUgPyAnPj0nIDogJz4nO1xuXG4gICAgICByZXR1cm4gJ1xcbiAgICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIHZhbGlkYXRlIG1heGltdW1cXG4gICAgICAgIGlmICh2YWx1ZSAnICsgb3BlcmF0b3IgKyAnICcgKyBtYXhpbXVtICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdtYXhpbXVtXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBsYXJnZVxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG11bHRpcGxlT2ZcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQSBudW1lcmljIGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgXCJtdWx0aXBsZU9mXCIgaWYgdGhlIHJlc3VsdCBvZlxuICAgICAqID4gdGhlIGRpdmlzaW9uIG9mIHRoZSBpbnN0YW5jZSBieSB0aGlzIGtleXdvcmQncyB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMS4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtdWx0aXBsZU9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbGVPZigpIHtcbiAgICAgIHZhciBtdWx0aXBsZU9mID0gdGhpcy5zY2hlbWEubXVsdGlwbGVPZjtcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh0eXBlb2YgbXVsdGlwbGVPZiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG11bHRpcGxlT2YudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgIHZhciBkZWNpbWFscyA9IGxlbmd0aCAtIG11bHRpcGxlT2YudG9GaXhlZCgwKS5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgcG93ID0gZGVjaW1hbHMgPiAwID8gTWF0aC5wb3coMTAsIGRlY2ltYWxzKSA6IDE7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGRlY2ltYWxzID4gMCkge1xuICAgICAgICAgIGNvbmRpdGlvbiA9ICcodmFsdWUgKiAnICsgcG93ICsgJykgJSAnICsgbXVsdGlwbGVPZiAqIHBvdyArICcgIT09IDAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmRpdGlvbiA9ICd2YWx1ZSAlICcgKyBtdWx0aXBsZU9mICsgJyAhPT0gMCc7XG4gICAgICAgIH1cblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICBpZiAoJyArIGNvbmRpdGlvbiArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbXVsdGlwbGVPZlxcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCdtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJyArIG11bHRpcGxlT2YgKyAnXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWYWxpZGF0b3I7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIEBtb2R1bGUgSlNPTiBPYmplY3QgU2lnbmluZyBhbmQgRW5jcnlwdGlvbiAoSk9TRSlcbiAqL1xudmFyIEpXQSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIEpXSyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xudmFyIEpXS1NldCA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xudmFyIEpXVCA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIEpXUyA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xudmFyIEJhc2U2NFVSTFNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIEpPU0VIZWFkZXJTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcbnZhciBKV0tTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbnZhciBKV0tTZXRTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcbnZhciBKV1RDbGFpbXNTZXRTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbnZhciBKV1RTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEpXQTogSldBLFxuICBKV0s6IEpXSyxcbiAgSldLU2V0OiBKV0tTZXQsXG4gIEpXVDogSldULFxuICBKV1M6IEpXUyxcbiAgQmFzZTY0VVJMU2NoZW1hOiBCYXNlNjRVUkxTY2hlbWEsXG4gIEpPU0VIZWFkZXJTY2hlbWE6IEpPU0VIZWFkZXJTY2hlbWEsXG4gIEpXS1NjaGVtYTogSldLU2NoZW1hLFxuICBKV0tTZXRTY2hlbWE6IEpXS1NldFNjaGVtYSxcbiAgSldUQ2xhaW1zU2V0U2NoZW1hOiBKV1RDbGFpbXNTZXRTY2hlbWEsXG4gIEpXVFNjaGVtYTogSldUU2NoZW1hXG59O1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKlxuICogVE9ET1xuICogLSBzd2l0Y2ggYmV0d2VlbiBOb2RlLmpzIHdlYmNyeXB0byBwYWNrYWdlIGFuZCBicm93c2VyIGltcGxlbWVudGF0aW9uXG4gKi9cbnZhciBiYXNlNjR1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbnZhciBzdXBwb3J0ZWRBbGdvcml0aG1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpLFxuICAgIE5vdFN1cHBvcnRlZEVycm9yID0gX3JlcXVpcmUuTm90U3VwcG9ydGVkRXJyb3I7XG5cbi8qKlxuICogSldBXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOFxuICovXG5cblxudmFyIEpXQSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSldBKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKV0EpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpXQSwgbnVsbCwgW3tcbiAgICBrZXk6ICdzaWduJyxcblxuXG4gICAgLyoqXG4gICAgICogU2lnblxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQ3JlYXRlIGEgZGlnaXRhbCBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxnXG4gICAgICogQHBhcmFtIHtDcnlwdG9LZXl9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbihhbGcsIGtleSwgZGF0YSkge1xuICAgICAgLy8gbm9ybWFsaXplIHRoZSBhbGdvcml0aG1cbiAgICAgIHZhciBub3JtYWxpemVkQWxnb3JpdGhtID0gc3VwcG9ydGVkQWxnb3JpdGhtcy5ub3JtYWxpemUoJ3NpZ24nLCBhbGcpO1xuXG4gICAgICAvLyB2YWxpZGF0ZSBhbGdvcml0aG0gaXMgc3VwcG9ydGVkXG4gICAgICBpZiAobm9ybWFsaXplZEFsZ29yaXRobSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTm90U3VwcG9ydGVkRXJyb3IoYWxnKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkYXRlIHR5cGUgb2Yga2V5XG4gICAgICAvLyBUT0RPXG4gICAgICAvLyAgLSBpcyB0aGUga2V5IHN1aXRhYmxlIGZvciB0aGUgYWxnb3JpdGhtP1xuICAgICAgLy8gIC0gZG9lcyB0aGF0IGdldCB2YWxpZGF0ZWQgaW4gd2ViY3J5cHRvP1xuICAgICAgLy9pZiAoa2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5KSB7XG4gICAgICAvLyAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBJbnZhbGlkS2V5RXJyb3IoKSlcbiAgICAgIC8vfVxuXG4gICAgICAvLyBzaWduIHRoZSBkYXRhXG4gICAgICByZXR1cm4gbm9ybWFsaXplZEFsZ29yaXRobS5zaWduKGtleSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWZXJpZnkgYSBkaWdpdGFsIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGdcbiAgICAgKiBAcGFyYW0ge0NyeXB0b0tleX0gcHJpdmF0ZUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoYWxnLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWRBbGdvcml0aG0gPSBzdXBwb3J0ZWRBbGdvcml0aG1zLm5vcm1hbGl6ZSgndmVyaWZ5JywgYWxnKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWRBbGdvcml0aG0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IE5vdFN1cHBvcnRlZEVycm9yKGFsZykpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPXG4gICAgICAvLyB2YWxpZGF0ZSBwdWJsaWNLZXlcblxuICAgICAgLy8gdmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAgICAgIHJldHVybiBub3JtYWxpemVkQWxnb3JpdGhtLnZlcmlmeShrZXksIHNpZ25hdHVyZSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jcnlwdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRGVjcnlwdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogSW1wb3J0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ltcG9ydEtleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltcG9ydEtleShrZXkpIHtcbiAgICAgIHZhciBub3JtYWxpemVkQWxnb3JpdGhtID0gc3VwcG9ydGVkQWxnb3JpdGhtcy5ub3JtYWxpemUoJ2ltcG9ydEtleScsIGtleS5hbGcpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBbGdvcml0aG0uaW1wb3J0S2V5KGtleSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpXQTtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSldBO1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCkuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKEJ1ZmZlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhZF9zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0LCBlbmNvZGluZykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKSB7IGVuY29kaW5nID0gXCJ1dGY4XCI7IH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZnJvbUJhc2U2NChpbnB1dC50b1N0cmluZyhcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tQmFzZTY0KEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xufVxuO1xuZnVuY3Rpb24gZGVjb2RlKGJhc2U2NHVybCwgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IFwidXRmOFwiOyB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRvQmFzZTY0KGJhc2U2NHVybCksIFwiYmFzZTY0XCIpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0KGJhc2U2NHVybCkge1xuICAgIGJhc2U2NHVybCA9IGJhc2U2NHVybC50b1N0cmluZygpO1xuICAgIHJldHVybiBwYWRfc3RyaW5nXzEuZGVmYXVsdChiYXNlNjR1cmwpXG4gICAgICAgIC5yZXBsYWNlKC9cXC0vZywgXCIrXCIpXG4gICAgICAgIC5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgcmV0dXJuIGJhc2U2NFxuICAgICAgICAucmVwbGFjZSgvPS9nLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbn1cbmZ1bmN0aW9uIHRvQnVmZmVyKGJhc2U2NHVybCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0b0Jhc2U2NChiYXNlNjR1cmwpLCBcImJhc2U2NFwiKTtcbn1cbnZhciBiYXNlNjR1cmwgPSBlbmNvZGU7XG5iYXNlNjR1cmwuZW5jb2RlID0gZW5jb2RlO1xuYmFzZTY0dXJsLmRlY29kZSA9IGRlY29kZTtcbmJhc2U2NHVybC50b0Jhc2U2NCA9IHRvQmFzZTY0O1xuYmFzZTY0dXJsLmZyb21CYXNlNjQgPSBmcm9tQmFzZTY0O1xuYmFzZTY0dXJsLnRvQnVmZmVyID0gdG9CdWZmZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBiYXNlNjR1cmw7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKS5CdWZmZXIpKVxuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cblxuXG52YXIgYmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MilcbnZhciBpZWVlNzU0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MylcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NClcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSkpXG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHBhZFN0cmluZyhpbnB1dCkge1xuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gNDtcbiAgICB2YXIgc3RyaW5nTGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHZhciBkaWZmID0gc3RyaW5nTGVuZ3RoICUgc2VnbWVudExlbmd0aDtcbiAgICBpZiAoIWRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICB2YXIgcG9zaXRpb24gPSBzdHJpbmdMZW5ndGg7XG4gICAgdmFyIHBhZExlbmd0aCA9IHNlZ21lbnRMZW5ndGggLSBkaWZmO1xuICAgIHZhciBwYWRkZWRTdHJpbmdMZW5ndGggPSBzdHJpbmdMZW5ndGggKyBwYWRMZW5ndGg7XG4gICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhwYWRkZWRTdHJpbmdMZW5ndGgpO1xuICAgIGJ1ZmZlci53cml0ZShpbnB1dCk7XG4gICAgd2hpbGUgKHBhZExlbmd0aC0tKSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZShcIj1cIiwgcG9zaXRpb24rKyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhZFN0cmluZztcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNDEpLkJ1ZmZlcikpXG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIE5vbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbnZhciBITUFDID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgUlNBU1NBX1BLQ1MxX3YxXzUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcbnZhciBTdXBwb3J0ZWRBbGdvcml0aG1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cbi8qKlxuICogUmVnaXN0ZXIgU3VwcG9ydGVkIEFsZ29yaXRobXNcbiAqL1xudmFyIHN1cHBvcnRlZEFsZ29yaXRobXMgPSBuZXcgU3VwcG9ydGVkQWxnb3JpdGhtcygpO1xuXG4vKipcbiAqIFNpZ25cbiAqL1xuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTMjU2JywgJ3NpZ24nLCBuZXcgSE1BQyh7XG4gIG5hbWU6ICdITUFDJyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMjU2J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdIUzM4NCcsICdzaWduJywgbmV3IEhNQUMoe1xuICBuYW1lOiAnSE1BQycsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTM4NCdcbiAgfVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnSFM1MTInLCAnc2lnbicsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTMjU2JywgJ3NpZ24nLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0yNTYnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTMzg0JywgJ3NpZ24nLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0zODQnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTNTEyJywgJ3NpZ24nLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTMjU2JywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTMzg0JywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTNTEyJywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTMjU2JywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTMzg0JywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTNTEyJywgJ3NpZ24nLCB7fSlcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ25vbmUnLCAnc2lnbicsIG5ldyBOb25lKHtcbiAgLy8gbm90aGluZyBnb2VzIGhlcmVcbn0pKTtcblxuLyoqXG4gKiBWZXJpZnlcbiAqL1xuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTMjU2JywgJ3ZlcmlmeScsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0yNTYnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTMzg0JywgJ3ZlcmlmeScsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0zODQnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTNTEyJywgJ3ZlcmlmeScsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTMjU2JywgJ3ZlcmlmeScsIG5ldyBSU0FTU0FfUEtDUzFfdjFfNSh7XG4gIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTI1NidcbiAgfVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUlMzODQnLCAndmVyaWZ5JywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMzg0J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzUxMicsICd2ZXJpZnknLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTMjU2JywgJ3ZlcmlmeScsIHt9KVxuLy9zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnRVMzODQnLCAndmVyaWZ5Jywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdFUzUxMicsICd2ZXJpZnknLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTMjU2JywgJ3ZlcmlmeScsIHt9KVxuLy9zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUFMzODQnLCAndmVyaWZ5Jywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdQUzUxMicsICd2ZXJpZnknLCB7fSlcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ25vbmUnLCAndmVyaWZ5JywgbmV3IE5vbmUoe1xuICAvLyBub3RoaW5nIGdvZXMgaGVyZVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUlMyNTYnLCAnaW1wb3J0S2V5JywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMjU2J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzM4NCcsICdpbXBvcnRLZXknLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0zODQnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTNTEyJywgJ2ltcG9ydEtleScsIG5ldyBSU0FTU0FfUEtDUzFfdjFfNSh7XG4gIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTUxMidcbiAgfVxufSkpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRlZEFsZ29yaXRobXM7XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBOb25lXG4gKi9cbnZhciBOb25lID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb25lKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb25lKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb25lLCBbe1xuICAgIGtleTogJ3NpZ24nLFxuXG4gICAgLyoqXG4gICAgICogc2lnblxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZlcmlmeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeSgpIHtcbiAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBnZXQgY2FsbGVkLiBidXQgeW91IGxvb2tlZC5cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9uZTtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTm9uZTtcblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHtcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgVGV4dEVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblxuLyoqXG4gKiBITUFDIHdpdGggU0hBLTIgRnVuY3Rpb25zXG4gKi9cblxudmFyIEhNQUMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiaXRsZW5ndGhcbiAgICovXG4gIGZ1bmN0aW9uIEhNQUMocGFyYW1zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhNQUMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogU2lnblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogR2VuZXJhdGUgYSBoYXNoLWJhc2VkIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZSBmb3IgYVxuICAgKiBnaXZlbiBpbnB1dCBhbmQga2V5LiBFbmZvcmNlIHRoZSBrZXkgbGVuZ3RoIGlzIGVxdWFsIHRvXG4gICAqIG9yIGdyZWF0ZXIgdGhhbiB0aGUgYml0bGVuZ3RoLlxuICAgKlxuICAgKiBAcGFyYW0ge0NyeXB0b0tleX0ga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhNQUMsIFt7XG4gICAga2V5OiAnc2lnbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oa2V5LCBkYXRhKSB7XG4gICAgICB2YXIgYWxnb3JpdGhtID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgIC8vIFRPRE86IHZhbGlkYXRlIGtleSBsZW5ndGhcblxuICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkudGhlbihmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjR1cmwoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnlcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZlcmlmeSBhIGRpZ2l0YWwgc2lnbmF0dXJlIGZvciBhIGdpdmVuIGlucHV0IGFuZCBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5fSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoa2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgIHZhciBhbGdvcml0aG0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IFVpbnQ4QXJyYXkuZnJvbShiYXNlNjR1cmwudG9CdWZmZXIoc2lnbmF0dXJlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2VydCBTdWZmaWNpZW50IEtleSBMZW5ndGhcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBc3NlcnQgdGhhdCB0aGUga2V5IGxlbmd0aCBpcyBzdWZmaWNpZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnRTdWZmaWNpZW50S2V5TGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0U3VmZmljaWVudEtleUxlbmd0aChrZXkpIHtcbiAgICAgIGlmIChrZXkubGVuZ3RoIDwgdGhpcy5iaXRsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUga2V5IGlzIHRvbyBzaG9ydC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSE1BQztcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSE1BQztcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKS5CdWZmZXIpKVxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJjcnlwdG9cIl07IH0oKSk7XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbnZhciBUZXh0RW5jb2RlciA9IGdsb2JhbC5UZXh0RW5jb2RlciA/IGdsb2JhbC5UZXh0RW5jb2RlciAvLyBicm93c2VyXG46IF9fd2VicGFja19yZXF1aXJlX18oNTEpLlRleHRFbmNvZGVyOyAvLyBub2RlIHNoaW1cbm1vZHVsZS5leHBvcnRzID0gVGV4dEVuY29kZXI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJUZXh0RW5jb2RlclwiXTsgfSgpKTtcblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHtcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgVGV4dEVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblxuLyoqXG4gKiBSU0FTU0EtUEtDUzEtdjFfNVxuICovXG5cbnZhciBSU0FTU0FfUEtDUzFfdjFfNSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJpdGxlbmd0aFxuICAgKi9cbiAgZnVuY3Rpb24gUlNBU1NBX1BLQ1MxX3YxXzUocGFyYW1zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJTQVNTQV9QS0NTMV92MV81KTtcblxuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIHNpZ25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdlbmVyYXRlIGEgZGlnaXRhbCBzaWduYXR1cmUgZm9yIGEgZ2l2ZW4gaW5wdXQgYW5kIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge0NyeXB0b0tleX0ga2V5XG4gICAqIEBwYXJhbSB7QnVmZmVyU291cmNlfSBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhSU0FTU0FfUEtDUzFfdjFfNSwgW3tcbiAgICBrZXk6ICdzaWduJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbihrZXksIGRhdGEpIHtcbiAgICAgIHZhciBhbGdvcml0aG0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgLy8gVE9ET1xuICAgICAgLy9pZiAoIXRoaXMuc3VmZmljaWVudEtleVNpemUoKSkge1xuICAgICAgLy8gIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgIC8vICAgIG5ldyBFcnJvcihcbiAgICAgIC8vICAgICAgJ0Ega2V5IHNpemUgb2YgMjA0OCBiaXRzIG9yIGxhcmdlciBtdXN0IGJlIHVzZWQgd2l0aCBSU0FTU0EtUEtDUzEtdjFfNSdcbiAgICAgIC8vICAgIClcbiAgICAgIC8vICApXG4gICAgICAvL31cblxuICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkudGhlbihmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjR1cmwoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB2ZXJpZnlcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZlcmlmeSBhIGRpZ2l0YWwgc2lnbmF0dXJlIGZvciBhIGdpdmVuIGlucHV0IGFuZCBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5fSBrZXlcbiAgICAgKiBAcGFyYW0ge0J1ZmZlclNvdXJjZX0gc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtCdWZmZXJTb3VyY2V9IGRhdGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoa2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgIHZhciBhbGdvcml0aG0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IFVpbnQ4QXJyYXkuZnJvbShiYXNlNjR1cmwudG9CdWZmZXIoc2lnbmF0dXJlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIC4uLlxuXG4gICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS52ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW1wb3J0S2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pXS30ga2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ltcG9ydEtleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltcG9ydEtleShrZXkpIHtcbiAgICAgIHZhciBqd2sgPSBPYmplY3QuYXNzaWduKHt9LCBrZXkpO1xuICAgICAgdmFyIGFsZ29yaXRobSA9IHRoaXMucGFyYW1zO1xuICAgICAgdmFyIHVzYWdlcyA9IGtleVsna2V5X29wcyddIHx8IFtdO1xuXG4gICAgICBpZiAoa2V5LnVzZSA9PT0gJ3NpZycpIHtcbiAgICAgICAgdXNhZ2VzLnB1c2goJ3ZlcmlmeScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5LnVzZSA9PT0gJ2VuYycpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVuY3J5cHRpb24ga2V5c1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkua2V5X29wcykge1xuICAgICAgICB1c2FnZXMgPSBrZXkua2V5X29wcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBqd2ssIGFsZ29yaXRobSwgdHJ1ZSwgdXNhZ2VzKS50aGVuKGZ1bmN0aW9uIChjcnlwdG9LZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGp3aywgJ2NyeXB0b0tleScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogY3J5cHRvS2V5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUlNBU1NBX1BLQ1MxX3YxXzU7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJTQVNTQV9QS0NTMV92MV81O1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNDEpLkJ1ZmZlcikpXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIE5vdFN1cHBvcnRlZEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG5cbi8qKlxuICogT3BlcmF0aW9uc1xuICovXG52YXIgb3BlcmF0aW9ucyA9IFsnc2lnbicsICd2ZXJpZnknLCAnZW5jcnlwdCcsICdkZWNyeXB0JywgJ2ltcG9ydEtleSddO1xuXG4vKipcbiAqIFN1cHBvcnRlZEFsZ29yaXRobXNcbiAqL1xuXG52YXIgU3VwcG9ydGVkQWxnb3JpdGhtcyA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFN1cHBvcnRlZEFsZ29yaXRobXMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdXBwb3J0ZWRBbGdvcml0aG1zKTtcblxuICAgIG9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgIF90aGlzW29wXSA9IHt9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1cHBvcnRlZCBPcGVyYXRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFN1cHBvcnRlZEFsZ29yaXRobXMsIFt7XG4gICAga2V5OiAnZGVmaW5lJyxcblxuXG4gICAgLyoqXG4gICAgICogZGVmaW5lXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZWdpc3RlciBXZWIgQ3J5cHRvIEFQSSBhbGdvcml0aG0gcGFyYW1ldGVyIGZvciBhbiBhbGdvcml0aG1cbiAgICAgKiBhbmQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmd1bWVudFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZpbmUoYWxnLCBvcCwgYXJndW1lbnQpIHtcbiAgICAgIHZhciByZWdpc3RlcmVkQWxnb3JpdGhtcyA9IHRoaXNbb3BdO1xuICAgICAgcmVnaXN0ZXJlZEFsZ29yaXRobXNbYWxnXSA9IGFyZ3VtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG5vcm1hbGl6ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWFwIEpXQSBhbGcgbmFtZSB0byBXZWIgQ3J5cHRvIEFQSSBhbGdvcml0aG0gcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWxnXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdub3JtYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUob3AsIGFsZykge1xuICAgICAgdmFyIHJlZ2lzdGVyZWRBbGdvcml0aG1zID0gdGhpc1tvcF07XG5cbiAgICAgIGlmICghcmVnaXN0ZXJlZEFsZ29yaXRobXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcigpOyAvLyB3aGF0IGtpbmQgb2YgZXJyb3Igc2hvdWxkIHRoaXMgYmU/XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmd1bWVudCA9IHJlZ2lzdGVyZWRBbGdvcml0aG1zW2FsZ107XG5cbiAgICAgIGlmICghYXJndW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RTdXBwb3J0ZWRFcnJvcihhbGcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJndW1lbnQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdvcGVyYXRpb25zJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBvcGVyYXRpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdXBwb3J0ZWRBbGdvcml0aG1zO1xufSgpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdXBwb3J0ZWRBbGdvcml0aG1zO1xuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBOb3RTdXBwb3J0ZWRFcnJvclxuICovXG52YXIgTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhOb3RTdXBwb3J0ZWRFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBOb3RTdXBwb3J0ZWRFcnJvcihhbGcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm90U3VwcG9ydGVkRXJyb3IpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE5vdFN1cHBvcnRlZEVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTm90U3VwcG9ydGVkRXJyb3IpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLm1lc3NhZ2UgPSBhbGcgKyBcIiBpcyBub3QgYSBzdXBwb3J0ZWQgYWxnb3JpdGhtXCI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIE5vdFN1cHBvcnRlZEVycm9yO1xufShFcnJvcik7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vdFN1cHBvcnRlZEVycm9yO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBEYXRhRXJyb3I6IF9fd2VicGFja19yZXF1aXJlX18oNTYpLFxuICBOb3RTdXBwb3J0ZWRFcnJvcjogX193ZWJwYWNrX3JlcXVpcmVfXyg1NClcbn07XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIERhdGFFcnJvclxuICovXG52YXIgRGF0YUVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoRGF0YUVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIERhdGFFcnJvcihtZXNzYWdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFFcnJvcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERhdGFFcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGFFcnJvcikpLmNhbGwodGhpcywgbWVzc2FnZSkpO1xuICB9XG5cbiAgcmV0dXJuIERhdGFFcnJvcjtcbn0oRXJyb3IpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhRXJyb3I7XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05Eb2N1bWVudCA9IF9yZXF1aXJlLkpTT05Eb2N1bWVudDtcblxudmFyIEpXS1NjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xudmFyIEpXQSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG4vKipcbiAqIEpXSyBDbGFzc1xuICovXG5cbnZhciBKV0sgPSBmdW5jdGlvbiAoX0pTT05Eb2N1bWVudCkge1xuICBfaW5oZXJpdHMoSldLLCBfSlNPTkRvY3VtZW50KTtcblxuICBmdW5jdGlvbiBKV0soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpXSyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEpXSy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEpXSykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpXSywgbnVsbCwgW3tcbiAgICBrZXk6ICdpbXBvcnRLZXknLFxuXG5cbiAgICAvKipcbiAgICAgKiBpbXBvcnRLZXlcbiAgICAgKlxuICAgICAqIFRPRE86XG4gICAgICogLSBzaG91bGQgdGhpcyBiZSBvbiBKV0E/XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltcG9ydEtleShqd2spIHtcbiAgICAgIHJldHVybiBKV0EuaW1wb3J0S2V5KGp3ayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2NoZW1hJyxcblxuXG4gICAgLyoqXG4gICAgICogU2NoZW1hXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSldLU2NoZW1hO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKV0s7XG59KEpTT05Eb2N1bWVudCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpXSztcblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSksXG4gICAgQkFTRTY0X1JFR0VYUCA9IF9yZXF1aXJlMi5CQVNFNjRfUkVHRVhQO1xuXG4vKipcbiAqIEpXSyBTY2hlbWFcbiAqL1xuXG5cbnZhciBKV0tTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICBrdHk6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgLy9mb3JtYXQ6ICdjYXNlLXNlbnNpdGl2ZScsXG4gICAgICBlbnVtOiBbJ1JTQScsICdFQycsICdvY3QnXSAvLyBvdGhlciB2YWx1ZXMgTUFZIGJlIHVzZWRcbiAgICB9LFxuXG4gICAgdXNlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIC8vZm9ybWF0OiAnY2FzZS1zZW5zaXRpdmUnLFxuICAgICAgZW51bTogWydzaWcnLCAnZW5jJ10gLy8gb3RoZXIgdmFsdWVzIE1BWSBiZSB1c2VkXG4gICAgfSxcblxuICAgIGtleV9vcHM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAvL2Zvcm1hdDogJ2Nhc2Utc2Vuc2l0aXZlJyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIGVudW06IFsnc2lnbicsICd2ZXJpZnknLCAnZW5jcnlwdCcsICdkZWNyeXB0JywgJ3dyYXBLZXknLCAndW53cmFwS2V5JywgJ2Rlcml2ZUtleScsICdkZXJpdmVCaXRzJ10gLy8gb3RoZXIgdmFsdWVzIE1BWSBiZSB1c2VkXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFsZzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAvL2Zvcm1hdDogJ2Nhc2Utc2Vuc2l0aXZlJyxcbiAgICAgIGVudW06IFsnSFMyNTYnLCAnSFMzODQnLCAnSFM1MTInLCAnUlMyNTYnLCAnUlMzODQnLCAnUlM1MTInLCAnRVMyNTYnLCAnRVMzODQnLCAnRVM1MTInLCAnUFMyNTYnLCAnUFMzODQnLCAnUFM1MTInLCAnbm9uZSddIC8vIG90aGVyIHZhbHVlcyBNQVkgYmUgdXNlZFxuICAgIH0sXG5cbiAgICBraWQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIHg1dToge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIC8vZm9ybWF0OiAndXJsJ1xuICAgIH0sXG5cbiAgICB4NWM6IHtcbiAgICAgIHR5cGU6ICdhcnJheSdcbiAgICAgIC8vZm9ybWF0OiBCQVNFNjRfUkVHRVhQXG4gICAgfSxcblxuICAgIHg1dDoge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIC8vZm9ybWF0OiBCQVNFNjRfUkVHRVhQXG4gICAgfVxuXG4gICAgLy8neDV0I1MyNTYnOiB7XG4gICAgLy8gIHR5cGU6ICdzdHJpbmcnLFxuICAgIC8vICAvL2Zvcm1hdDogQkFTRTY0X1JFR0VYUFxuICAgIC8vfVxuICB9XG59KTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBKV0tTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBQYWNrYWdlIGRlcGVuZGVuY2llc1xuICovXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBGb3JtYXRzID0gX3JlcXVpcmUuRm9ybWF0cztcblxuLyoqXG4gKiBGb3JtYXQgZXh0ZW5zaW9uc1xuICovXG5cblxuRm9ybWF0cy5yZWdpc3RlcignU3RyaW5nT3JVUkknLCBuZXcgUmVnRXhwKCkpO1xuRm9ybWF0cy5yZWdpc3RlcignTnVtZXJpY0RhdGUnLCBuZXcgUmVnRXhwKCkpO1xuRm9ybWF0cy5yZWdpc3RlcignVVJJJywgbmV3IFJlZ0V4cCgpKTtcbkZvcm1hdHMucmVnaXN0ZXIoJ3VybCcsIG5ldyBSZWdFeHAoKSk7XG5Gb3JtYXRzLnJlZ2lzdGVyKCdiYXNlNjQnLCBuZXcgUmVnRXhwKCkpO1xuRm9ybWF0cy5yZWdpc3RlcignYmFzZTY0dXJsJywgbmV3IFJlZ0V4cCgpKTtcbkZvcm1hdHMucmVnaXN0ZXIoJ01lZGlhVHlwZScsIG5ldyBSZWdFeHAoKSk7XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05Eb2N1bWVudCA9IF9yZXF1aXJlLkpTT05Eb2N1bWVudDtcblxudmFyIEpXS1NldFNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xudmFyIEpXSyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuXG4vKipcbiAqIEpXS1NldFxuICpcbiAqIEBjbGFzc1xuICogSldLU2V0IHJlcHJlc2VudHMgYSBKU09OIFdlYiBLZXkgU2V0IGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDUgb2YgUkZDIDc1MTc6XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNyNzZWN0aW9uLTVcbiAqL1xuXG52YXIgSldLU2V0ID0gZnVuY3Rpb24gKF9KU09ORG9jdW1lbnQpIHtcbiAgX2luaGVyaXRzKEpXS1NldCwgX0pTT05Eb2N1bWVudCk7XG5cbiAgZnVuY3Rpb24gSldLU2V0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKV0tTZXQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChKV0tTZXQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihKV0tTZXQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKV0tTZXQsIG51bGwsIFt7XG4gICAga2V5OiAnaW1wb3J0S2V5cycsXG5cblxuICAgIC8qKlxuICAgICAqIGltcG9ydEtleXNcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1wb3J0S2V5cyhqd2tzKSB7XG4gICAgICB2YXIgdmFsaWRhdGlvbiA9IHRoaXMuc2NoZW1hLnZhbGlkYXRlKGp3a3MpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBKV0tTZXQ6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uLCBudWxsLCAyKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWp3a3Mua2V5cykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDYW5ub3QgaW1wb3J0IEpXS1NldDoga2V5cyBwcm9wZXJ0eSBpcyBlbXB0eScpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGltcG9ydGVkID0gdm9pZCAwLFxuICAgICAgICAgIGltcG9ydGluZyA9IHZvaWQgMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaW1wb3J0ZWQgPSBuZXcgSldLU2V0KGp3a3MpO1xuICAgICAgICBpbXBvcnRpbmcgPSBqd2tzLmtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gSldLLmltcG9ydEtleShrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGltcG9ydGluZykudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBpbXBvcnRlZC5rZXlzID0ga2V5cztcbiAgICAgICAgcmV0dXJuIGltcG9ydGVkO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2NoZW1hJyxcblxuXG4gICAgLyoqXG4gICAgICogc2NoZW1hXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSldLU2V0U2NoZW1hO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKV0tTZXQ7XG59KEpTT05Eb2N1bWVudCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpXS1NldDtcblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG52YXIgSldLU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbi8qKlxuICogSldLU2V0U2NoZW1hXG4gKi9cbnZhciBKV0tTZXRTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAga2V5czoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiBKV0tTY2hlbWFcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpXS1NldFNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIGJhc2U2NHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09ORG9jdW1lbnQgPSBfcmVxdWlyZS5KU09ORG9jdW1lbnQ7XG5cbnZhciBKV1RTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbnZhciBKV1MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBEYXRhRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxuLyoqXG4gKiBKV1RcbiAqL1xuXG52YXIgSldUID0gZnVuY3Rpb24gKF9KU09ORG9jdW1lbnQpIHtcbiAgX2luaGVyaXRzKEpXVCwgX0pTT05Eb2N1bWVudCk7XG5cbiAgZnVuY3Rpb24gSldUKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKV1QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChKV1QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihKV1QpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKV1QsIFt7XG4gICAga2V5OiAnaXNKV0UnLFxuXG5cbiAgICAvKipcbiAgICAgKiBpc0pXRVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0pXRSgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuaGVhZGVyLmVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXNvbHZlS2V5c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNvbHZlS2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVLZXlzKGp3a3MpIHtcbiAgICAgIHZhciBraWQgPSB0aGlzLmhlYWRlci5raWQ7XG4gICAgICB2YXIga2V5cyA9IHZvaWQgMCxcbiAgICAgICAgICBtYXRjaCA9IHZvaWQgMDtcblxuICAgICAgLy8gdHJlYXQgYW4gYXJyYXkgYXMgdGhlIFwia2V5c1wiIHByb3BlcnR5IG9mIGEgSldLIFNldFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoandrcykpIHtcbiAgICAgICAga2V5cyA9IGp3a3M7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXNlbmNlIG9mIGtleXMgaW5kaWNhdGVzIG9iamVjdCBpcyBhIEpXSyBTZXRcbiAgICAgIGlmIChqd2tzLmtleXMpIHtcbiAgICAgICAga2V5cyA9IGp3a3Mua2V5cztcbiAgICAgIH1cblxuICAgICAgLy8gd3JhcCBhIHBsYWluIG9iamVjdCB0aGV5IGlzIG5vdCBhIEpXSyBTZXQgaW4gQXJyYXlcbiAgICAgIGlmICghandrcy5rZXlzICYmICh0eXBlb2YgandrcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoandrcykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBrZXlzID0gW2p3a3NdO1xuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgdGhlcmUgYXJlIGtleXMgdG8gc2VhcmNoXG4gICAgICBpZiAoIWtleXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGFFcnJvcignSW52YWxpZCBKV0sgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWF0Y2ggYnkgXCJraWRcIiBvciBcInVzZVwiIGhlYWRlclxuICAgICAgaWYgKGtpZCkge1xuICAgICAgICBtYXRjaCA9IGtleXMuZmluZChmdW5jdGlvbiAoandrKSB7XG4gICAgICAgICAgcmV0dXJuIGp3ay5raWQgPT09IGtpZDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IGtleXMuZmluZChmdW5jdGlvbiAoandrKSB7XG4gICAgICAgICAgcmV0dXJuIGp3ay51c2UgPT09ICdzaWcnO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gYXNzaWduIG1hdGNoaW5nIGtleSB0byBKV1QgYW5kIHJldHVybiBhIGJvb2xlYW5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLmtleSA9IG1hdGNoLmNyeXB0b0tleTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZW5jb2RlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBFbmNvZGUgYSBKV1QgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmNvZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGUoKSB7XG4gICAgICAvLyB2YWxpZGF0ZVxuICAgICAgdmFyIHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKCk7XG5cbiAgICAgIGlmICghdmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodmFsaWRhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2tlbiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmlzSldFKCkpIHtcbiAgICAgICAgcmV0dXJuIEpXRS5lbmNyeXB0KHRva2VuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBKV1Muc2lnbih0b2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWZXJpZnkgYSBkZWNvZGVkIEpXVCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZlcmlmeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeSgpIHtcbiAgICAgIHZhciB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZSgpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHZhbGlkYXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSldTLnZlcmlmeSh0aGlzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2RlY29kZScsXG5cblxuICAgIC8qKlxuICAgICAqIGRlY29kZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRGVjb2RlIGEgSlNPTiBXZWIgVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAgICogQHJldHVybnMge0pXVH1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKGRhdGEpIHtcbiAgICAgIHZhciBFeHRlbmRlZEpXVCA9IHRoaXM7XG4gICAgICB2YXIgand0ID0gdm9pZCAwO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRhRXJyb3IoJ0pXVCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEpTT04gb2YgRmxhdHRlbmVkIEpTT04gU2VyaWFsaXphdGlvblxuICAgICAgaWYgKGRhdGEuc3RhcnRzV2l0aCgneycpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBEYXRhRXJyb3IoJ0ludmFsaWQgSldUIHNlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnNpZ25hdHVyZXMgfHwgZGF0YS5yZWNpcGllbnRzKSB7XG4gICAgICAgICAgZGF0YS5zZXJpYWxpemF0aW9uID0gJ2pzb24nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEuc2VyaWFsaXphdGlvbiA9ICdmbGF0dGVuZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgand0ID0gbmV3IEV4dGVuZGVkSldUKGRhdGEsIHsgZmlsdGVyOiBmYWxzZSB9KTtcblxuICAgICAgICAvLyBDb21wYWN0IFNlcmlhbGl6YXRpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHNlcmlhbGl6YXRpb24gPSAnY29tcGFjdCc7XG4gICAgICAgICAgdmFyIHNlZ21lbnRzID0gZGF0YS5zcGxpdCgnLicpO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoICE9PSAzICYmIGxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgSldUJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhlYWRlciA9IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShzZWdtZW50c1swXSkpO1xuXG4gICAgICAgICAgLy8gSlNPTiBXZWIgU2lnbmF0dXJlXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSAnSldTJztcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKHNlZ21lbnRzWzFdKSk7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gc2VnbWVudHNbMl07XG5cbiAgICAgICAgICAgIGp3dCA9IG5ldyBFeHRlbmRlZEpXVCh7IHR5cGU6IHR5cGUsIHNlZ21lbnRzOiBzZWdtZW50cywgaGVhZGVyOiBoZWFkZXIsIHBheWxvYWQ6IHBheWxvYWQsIHNpZ25hdHVyZTogc2lnbmF0dXJlLCBzZXJpYWxpemF0aW9uOiBzZXJpYWxpemF0aW9uIH0sIHsgZmlsdGVyOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBKU09OIFdlYiBFbmNyeXB0aW9uXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgLy9sZXQgdHlwZSA9ICdKV0UnXG4gICAgICAgICAgICAvL2xldCBbcHJvdGVjdGVkLCBlbmNyeXB0aW9uX2tleSwgaXYsIGNpcGhlcnRleHQsIHRhZ10gPSBzZWdtZW50c1xuXG4gICAgICAgICAgICAvL2p3dCA9IG5ldyBFeHRlbmRlZEpXVCh7XG4gICAgICAgICAgICAvLyAgdHlwZSxcbiAgICAgICAgICAgIC8vICBwcm90ZWN0ZWQ6IGJhc2U2NHVybC5kZWNvZGUoSlNPTi5wYXJzZShwcm90ZWN0ZWQpKSxcbiAgICAgICAgICAgIC8vICBlbmNyeXB0aW9uX2tleSxcbiAgICAgICAgICAgIC8vICBpdixcbiAgICAgICAgICAgIC8vICBjaXBoZXJ0ZXh0LFxuICAgICAgICAgICAgLy8gIHRhZyxcbiAgICAgICAgICAgIC8vICBzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICAvL30pXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBEYXRhRXJyb3IoJ0ludmFsaWQgSldUIGNvbXBhY3Qgc2VyaWFsaXphdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqd3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZW5jb2RlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBFbmNvZGUgYSBKU09OIFdlYiBUb2tlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICogQHBhcmFtIHtDcnlwdG9LZXl9IGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VuY29kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuY29kZShoZWFkZXIsIHBheWxvYWQsIGtleSkge1xuICAgICAgdmFyIGp3dCA9IG5ldyBKV1QoaGVhZGVyLCBwYXlsb2FkKTtcbiAgICAgIHJldHVybiBqd3QuZW5jb2RlKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5fSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoa2V5LCB0b2tlbikge1xuICAgICAgdmFyIGp3dCA9IEpXVC5kZWNvZGUodG9rZW4pO1xuICAgICAgand0LmtleSA9IGtleTtcbiAgICAgIHJldHVybiBqd3QudmVyaWZ5KCkudGhlbihmdW5jdGlvbiAodmVyaWZpZWQpIHtcbiAgICAgICAgcmV0dXJuIGp3dDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NjaGVtYScsXG5cblxuICAgIC8qKlxuICAgICAqIHNjaGVtYVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEpXVFNjaGVtYTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSldUO1xufShKU09ORG9jdW1lbnQpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBKV1Q7XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIEJhc2U2NFVSTFNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIEpXVENsYWltc1NldFNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xudmFyIEpPU0VIZWFkZXJTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCksXG4gICAgSlNPTlNjaGVtYSA9IF9yZXF1aXJlLkpTT05TY2hlbWE7XG5cbi8qKlxuICogSldUU2NoZW1hXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNjaGVtYSByZXByZXNlbnRzIGFsbCB0aGUgdGhpbmdzIGEgZGVzZXJpYWxpemVkIEpXVCBjYW4gYmUsIGkuZS4sXG4gKiBlaXRoZXIgYSBKV1Mgb3IgSldFLCBhbmQgYW55IHNlcmlhbGl6YXRpb24gb2YgdGhlbS4gVmFsaWRhdGlvbiBvZiB3ZWxsLVxuICogZm9ybWVkbmVzcyBmb3IgYSBnaXZlbiBzZXJpYWxpemF0aW9uIGlzIGFjY29tcGxpc2hlZCBhdCB0aGUgdGltZSBvZlxuICogZW5jb2RpbmcuXG4gKi9cblxuXG52YXIgSldUU2NoZW1hID0gbmV3IEpTT05TY2hlbWEoe1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogdHlwZVxuICAgICAqL1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydKV1MnLCAnSldFJ11cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2VnbWVudHNcbiAgICAgKi9cbiAgICBzZWdtZW50czoge1xuICAgICAgdHlwZTogJ2FycmF5J1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZWFkZXJcbiAgICAgKi9cbiAgICBoZWFkZXI6IEpPU0VIZWFkZXJTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQ6IEpPU0VIZWFkZXJTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiB1bnByb3RlY3RlZFxuICAgICAqL1xuICAgIHVucHJvdGVjdGVkOiBKT1NFSGVhZGVyU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogaXZcbiAgICAgKi9cbiAgICBpdjogQmFzZTY0VVJMU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogYWFkXG4gICAgICovXG4gICAgYWFkOiBCYXNlNjRVUkxTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiBjaXBoZXJ0ZXh0XG4gICAgICovXG4gICAgY2lwaGVydGV4dDogQmFzZTY0VVJMU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogdGFnXG4gICAgICovXG4gICAgdGFnOiBCYXNlNjRVUkxTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiByZWNpcGllbnRzXG4gICAgICovXG4gICAgcmVjaXBpZW50czoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgaGVhZGVyOiBKT1NFSGVhZGVyU2NoZW1hLFxuICAgICAgICAgIGVuY3J5cHRlZF9rZXk6IEJhc2U2NFVSTFNjaGVtYVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBheWxvYWRcbiAgICAgKi9cbiAgICBwYXlsb2FkOiBKV1RDbGFpbXNTZXRTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiBzaWduYXR1cmVzXG4gICAgICovXG4gICAgc2lnbmF0dXJlczoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgcHJvdGVjdGVkOiBKT1NFSGVhZGVyU2NoZW1hLFxuICAgICAgICAgIGhlYWRlcjogSk9TRUhlYWRlclNjaGVtYSxcbiAgICAgICAgICBzaWduYXR1cmU6IEJhc2U2NFVSTFNjaGVtYSxcbiAgICAgICAgICBrZXk6IHsgdHlwZTogJ29iamVjdCcgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIHNpZ25hdHVyZTogQmFzZTY0VVJMU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogdmVyaWZpZWRcbiAgICAgKi9cbiAgICB2ZXJpZmllZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoga2V5XG4gICAgICovXG4gICAga2V5OiB7XG4gICAgICB0eXBlOiAnb2JqZWN0J1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzZXJpYWxpemF0aW9uXG4gICAgICovXG4gICAgc2VyaWFsaXphdGlvbjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NvbXBhY3QnLCAnanNvbicsICdmbGF0dGVuZWQnXSxcbiAgICAgIGRlZmF1bHQ6ICdjb21wYWN0J1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSldUU2NoZW1hO1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG4vKipcbiAqIEJhc2U2NFVSTFNjaGVtYVxuICovXG5cblxudmFyIEJhc2U2NFVSTFNjaGVtYSA9IG5ldyBKU09OU2NoZW1hKHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGZvcm1hdDogJ2Jhc2U2NHVybCdcbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U2NFVSTFNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09OU2NoZW1hID0gX3JlcXVpcmUuSlNPTlNjaGVtYTtcblxuLyoqXG4gKiBKV1RDbGFpbXNTZXRTY2hlbWFcbiAqXG4gKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00XG4gKlxuICogNC4gIEpXVCBDbGFpbXNcbiAqXG4gKiAgIFRoZSBKV1QgQ2xhaW1zIFNldCByZXByZXNlbnRzIGEgSlNPTiBvYmplY3Qgd2hvc2UgbWVtYmVycyBhcmUgdGhlXG4gKiAgIGNsYWltcyBjb252ZXllZCBieSB0aGUgSldULiAgVGhlIENsYWltIE5hbWVzIHdpdGhpbiBhIEpXVCBDbGFpbXMgU2V0XG4gKiAgIE1VU1QgYmUgdW5pcXVlOyBKV1QgcGFyc2VycyBNVVNUIGVpdGhlciByZWplY3QgSldUcyB3aXRoIGR1cGxpY2F0ZVxuICogICBDbGFpbSBOYW1lcyBvciB1c2UgYSBKU09OIHBhcnNlciB0aGF0IHJldHVybnMgb25seSB0aGUgbGV4aWNhbGx5IGxhc3RcbiAqICAgZHVwbGljYXRlIG1lbWJlciBuYW1lLCBhcyBzcGVjaWZpZWQgaW4gU2VjdGlvbiAxNS4xMiAoXCJUaGUgSlNPTlxuICogICBPYmplY3RcIikgb2YgRUNNQVNjcmlwdCA1LjEgW0VDTUFTY3JpcHRdLlxuICpcbiAqICAgVGhlIHNldCBvZiBjbGFpbXMgdGhhdCBhIEpXVCBtdXN0IGNvbnRhaW4gdG8gYmUgY29uc2lkZXJlZCB2YWxpZCBpc1xuICogICBjb250ZXh0IGRlcGVuZGVudCBhbmQgaXMgb3V0c2lkZSB0aGUgc2NvcGUgb2YgdGhpcyBzcGVjaWZpY2F0aW9uLlxuICogICBTcGVjaWZpYyBhcHBsaWNhdGlvbnMgb2YgSldUcyB3aWxsIHJlcXVpcmUgaW1wbGVtZW50YXRpb25zIHRvXG4gKiAgIHVuZGVyc3RhbmQgYW5kIHByb2Nlc3Mgc29tZSBjbGFpbXMgaW4gcGFydGljdWxhciB3YXlzLiAgSG93ZXZlciwgaW5cbiAqICAgdGhlIGFic2VuY2Ugb2Ygc3VjaCByZXF1aXJlbWVudHMsIGFsbCBjbGFpbXMgdGhhdCBhcmUgbm90IHVuZGVyc3Rvb2RcbiAqICAgYnkgaW1wbGVtZW50YXRpb25zIE1VU1QgYmUgaWdub3JlZC5cbiAqXG4gKiAgIFRoZXJlIGFyZSB0aHJlZSBjbGFzc2VzIG9mIEpXVCBDbGFpbSBOYW1lczogUmVnaXN0ZXJlZCBDbGFpbSBOYW1lcyxcbiAqICAgUHVibGljIENsYWltIE5hbWVzLCBhbmQgUHJpdmF0ZSBDbGFpbSBOYW1lcy5cbiAqL1xuXG5cbnZhciBKV1RDbGFpbXNTZXRTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjFcbiAgICAgKlxuICAgICAqIDQuMS4gIFJlZ2lzdGVyZWQgQ2xhaW0gTmFtZXNcbiAgICAgKlxuICAgICAqICAgVGhlIGZvbGxvd2luZyBDbGFpbSBOYW1lcyBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgSUFOQSBcIkpTT04gV2ViIFRva2VuXG4gICAgICogICBDbGFpbXNcIiByZWdpc3RyeSBlc3RhYmxpc2hlZCBieSBTZWN0aW9uIDEwLjEuICBOb25lIG9mIHRoZSBjbGFpbXNcbiAgICAgKiAgIGRlZmluZWQgYmVsb3cgYXJlIGludGVuZGVkIHRvIGJlIG1hbmRhdG9yeSB0byB1c2Ugb3IgaW1wbGVtZW50IGluIGFsbFxuICAgICAqICAgY2FzZXMsIGJ1dCByYXRoZXIgdGhleSBwcm92aWRlIGEgc3RhcnRpbmcgcG9pbnQgZm9yIGEgc2V0IG9mIHVzZWZ1bCxcbiAgICAgKiAgIGludGVyb3BlcmFibGUgY2xhaW1zLiAgQXBwbGljYXRpb25zIHVzaW5nIEpXVHMgc2hvdWxkIGRlZmluZSB3aGljaFxuICAgICAqICAgc3BlY2lmaWMgY2xhaW1zIHRoZXkgdXNlIGFuZCB3aGVuIHRoZXkgYXJlIHJlcXVpcmVkIG9yIG9wdGlvbmFsLiAgQWxsXG4gICAgICogICB0aGUgbmFtZXMgYXJlIHNob3J0IGJlY2F1c2UgYSBjb3JlIGdvYWwgb2YgSldUcyBpcyBmb3IgdGhlXG4gICAgICogICByZXByZXNlbnRhdGlvbiB0byBiZSBjb21wYWN0LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogaXNzXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNC4xLjFcbiAgICAgKlxuICAgICAqIDQuMS4xLiAgXCJpc3NcIiAoSXNzdWVyKSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJpc3NcIiAoaXNzdWVyKSBjbGFpbSBpZGVudGlmaWVzIHRoZSBwcmluY2lwYWwgdGhhdCBpc3N1ZWQgdGhlXG4gICAgICogICBKV1QuICBUaGUgcHJvY2Vzc2luZyBvZiB0aGlzIGNsYWltIGlzIGdlbmVyYWxseSBhcHBsaWNhdGlvbiBzcGVjaWZpYy5cbiAgICAgKiAgIFRoZSBcImlzc1wiIHZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSVxuICAgICAqICAgdmFsdWUuICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBpc3M6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnU3RyaW5nT3JVUkknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN1YlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS4yXG4gICAgICpcbiAgICAgKiA0LjEuMi4gIFwic3ViXCIgKFN1YmplY3QpIENsYWltXG4gICAgICpcbiAgICAgKiAgIFRoZSBcInN1YlwiIChzdWJqZWN0KSBjbGFpbSBpZGVudGlmaWVzIHRoZSBwcmluY2lwYWwgdGhhdCBpcyB0aGVcbiAgICAgKiAgIHN1YmplY3Qgb2YgdGhlIEpXVC4gIFRoZSBjbGFpbXMgaW4gYSBKV1QgYXJlIG5vcm1hbGx5IHN0YXRlbWVudHNcbiAgICAgKiAgIGFib3V0IHRoZSBzdWJqZWN0LiAgVGhlIHN1YmplY3QgdmFsdWUgTVVTVCBlaXRoZXIgYmUgc2NvcGVkIHRvIGJlXG4gICAgICogICBsb2NhbGx5IHVuaXF1ZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgaXNzdWVyIG9yIGJlIGdsb2JhbGx5IHVuaXF1ZS5cbiAgICAgKiAgIFRoZSBwcm9jZXNzaW5nIG9mIHRoaXMgY2xhaW0gaXMgZ2VuZXJhbGx5IGFwcGxpY2F0aW9uIHNwZWNpZmljLiAgVGhlXG4gICAgICogICBcInN1YlwiIHZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSVxuICAgICAqICAgdmFsdWUuICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBzdWI6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnU3RyaW5nT3JVUkknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGF1ZFxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS4zXG4gICAgICpcbiAgICAgKiA0LjEuMy4gIFwiYXVkXCIgKEF1ZGllbmNlKSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIGlkZW50aWZpZXMgdGhlIHJlY2lwaWVudHMgdGhhdCB0aGUgSldUIGlzXG4gICAgICogICBpbnRlbmRlZCBmb3IuICBFYWNoIHByaW5jaXBhbCBpbnRlbmRlZCB0byBwcm9jZXNzIHRoZSBKV1QgTVVTVFxuICAgICAqICAgaWRlbnRpZnkgaXRzZWxmIHdpdGggYSB2YWx1ZSBpbiB0aGUgYXVkaWVuY2UgY2xhaW0uICBJZiB0aGUgcHJpbmNpcGFsXG4gICAgICogICBwcm9jZXNzaW5nIHRoZSBjbGFpbSBkb2VzIG5vdCBpZGVudGlmeSBpdHNlbGYgd2l0aCBhIHZhbHVlIGluIHRoZVxuICAgICAqICAgXCJhdWRcIiBjbGFpbSB3aGVuIHRoaXMgY2xhaW0gaXMgcHJlc2VudCwgdGhlbiB0aGUgSldUIE1VU1QgYmVcbiAgICAgKiAgIHJlamVjdGVkLiAgSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIFwiYXVkXCIgdmFsdWUgaXMgYW4gYXJyYXkgb2YgY2FzZS1cbiAgICAgKiAgIHNlbnNpdGl2ZSBzdHJpbmdzLCBlYWNoIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSSB2YWx1ZS4gIEluIHRoZVxuICAgICAqICAgc3BlY2lhbCBjYXNlIHdoZW4gdGhlIEpXVCBoYXMgb25lIGF1ZGllbmNlLCB0aGUgXCJhdWRcIiB2YWx1ZSBNQVkgYmUgYVxuICAgICAqICAgc2luZ2xlIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyBjb250YWluaW5nIGEgU3RyaW5nT3JVUkkgdmFsdWUuICBUaGVcbiAgICAgKiAgIGludGVycHJldGF0aW9uIG9mIGF1ZGllbmNlIHZhbHVlcyBpcyBnZW5lcmFsbHkgYXBwbGljYXRpb24gc3BlY2lmaWMuXG4gICAgICogICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBhdWQ6IHtcbiAgICAgIHR5cGU6IFsnYXJyYXknLCAnc3RyaW5nJ10sXG4gICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSScsXG4gICAgICBpdGVtczoge1xuICAgICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSSdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZXhwXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNC4xLjRcbiAgICAgKlxuICAgICAqIDQuMS40LiAgXCJleHBcIiAoRXhwaXJhdGlvbiBUaW1lKSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSBpZGVudGlmaWVzIHRoZSBleHBpcmF0aW9uIHRpbWUgb25cbiAgICAgKiAgIG9yIGFmdGVyIHdoaWNoIHRoZSBKV1QgTVVTVCBOT1QgYmUgYWNjZXB0ZWQgZm9yIHByb2Nlc3NpbmcuICBUaGVcbiAgICAgKiAgIHByb2Nlc3Npbmcgb2YgdGhlIFwiZXhwXCIgY2xhaW0gcmVxdWlyZXMgdGhhdCB0aGUgY3VycmVudCBkYXRlL3RpbWVcbiAgICAgKiAgIE1VU1QgYmUgYmVmb3JlIHRoZSBleHBpcmF0aW9uIGRhdGUvdGltZSBsaXN0ZWQgaW4gdGhlIFwiZXhwXCIgY2xhaW0uXG4gICAgICpcbiAgICAgKiAgIEltcGxlbWVudGVycyBNQVkgcHJvdmlkZSBmb3Igc29tZSBzbWFsbCBsZWV3YXksIHVzdWFsbHkgbm8gbW9yZSB0aGFuXG4gICAgICogICBhIGZldyBtaW51dGVzLCB0byBhY2NvdW50IGZvciBjbG9jayBza2V3LiAgSXRzIHZhbHVlIE1VU1QgYmUgYSBudW1iZXJcbiAgICAgKiAgIGNvbnRhaW5pbmcgYSBOdW1lcmljRGF0ZSB2YWx1ZS4gIFVzZSBvZiB0aGlzIGNsYWltIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICovXG4gICAgZXhwOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGZvcm1hdDogJ051bWVyaWNEYXRlJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBuYmZcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjEuNVxuICAgICAqXG4gICAgICogNC4xLjUuICBcIm5iZlwiIChOb3QgQmVmb3JlKSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJuYmZcIiAobm90IGJlZm9yZSkgY2xhaW0gaWRlbnRpZmllcyB0aGUgdGltZSBiZWZvcmUgd2hpY2ggdGhlIEpXVFxuICAgICAqICAgTVVTVCBOT1QgYmUgYWNjZXB0ZWQgZm9yIHByb2Nlc3NpbmcuICBUaGUgcHJvY2Vzc2luZyBvZiB0aGUgXCJuYmZcIlxuICAgICAqICAgY2xhaW0gcmVxdWlyZXMgdGhhdCB0aGUgY3VycmVudCBkYXRlL3RpbWUgTVVTVCBiZSBhZnRlciBvciBlcXVhbCB0b1xuICAgICAqICAgdGhlIG5vdC1iZWZvcmUgZGF0ZS90aW1lIGxpc3RlZCBpbiB0aGUgXCJuYmZcIiBjbGFpbS4gIEltcGxlbWVudGVycyBNQVlcbiAgICAgKiAgIHByb3ZpZGUgZm9yIHNvbWUgc21hbGwgbGVld2F5LCB1c3VhbGx5IG5vIG1vcmUgdGhhbiBhIGZldyBtaW51dGVzLCB0b1xuICAgICAqICAgYWNjb3VudCBmb3IgY2xvY2sgc2tldy4gIEl0cyB2YWx1ZSBNVVNUIGJlIGEgbnVtYmVyIGNvbnRhaW5pbmcgYVxuICAgICAqICAgTnVtZXJpY0RhdGUgdmFsdWUuICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBuYmY6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZm9ybWF0OiAnTnVtZXJpY0RhdGUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlhdFxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS42XG4gICAgICpcbiAgICAgKiA0LjEuNi4gIFwiaWF0XCIgKElzc3VlZCBBdCkgQ2xhaW1cbiAgICAgKlxuICAgICAqICAgVGhlIFwiaWF0XCIgKGlzc3VlZCBhdCkgY2xhaW0gaWRlbnRpZmllcyB0aGUgdGltZSBhdCB3aGljaCB0aGUgSldUIHdhc1xuICAgICAqICAgaXNzdWVkLiAgVGhpcyBjbGFpbSBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGFnZSBvZiB0aGUgSldULiAgSXRzXG4gICAgICogICB2YWx1ZSBNVVNUIGJlIGEgbnVtYmVyIGNvbnRhaW5pbmcgYSBOdW1lcmljRGF0ZSB2YWx1ZS4gIFVzZSBvZiB0aGlzXG4gICAgICogICBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBpYXQ6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZm9ybWF0OiAnTnVtZXJpY0RhdGUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGp0aVxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS43XG4gICAgICpcbiAgICAgKiA0LjEuNy4gIFwianRpXCIgKEpXVCBJRCkgQ2xhaW1cbiAgICAgKlxuICAgICAqICAgVGhlIFwianRpXCIgKEpXVCBJRCkgY2xhaW0gcHJvdmlkZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIEpXVC5cbiAgICAgKiAgIFRoZSBpZGVudGlmaWVyIHZhbHVlIE1VU1QgYmUgYXNzaWduZWQgaW4gYSBtYW5uZXIgdGhhdCBlbnN1cmVzIHRoYXRcbiAgICAgKiAgIHRoZXJlIGlzIGEgbmVnbGlnaWJsZSBwcm9iYWJpbGl0eSB0aGF0IHRoZSBzYW1lIHZhbHVlIHdpbGwgYmVcbiAgICAgKiAgIGFjY2lkZW50YWxseSBhc3NpZ25lZCB0byBhIGRpZmZlcmVudCBkYXRhIG9iamVjdDsgaWYgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogICB1c2VzIG11bHRpcGxlIGlzc3VlcnMsIGNvbGxpc2lvbnMgTVVTVCBiZSBwcmV2ZW50ZWQgYW1vbmcgdmFsdWVzXG4gICAgICogICBwcm9kdWNlZCBieSBkaWZmZXJlbnQgaXNzdWVycyBhcyB3ZWxsLiAgVGhlIFwianRpXCIgY2xhaW0gY2FuIGJlIHVzZWRcbiAgICAgKiAgIHRvIHByZXZlbnQgdGhlIEpXVCBmcm9tIGJlaW5nIHJlcGxheWVkLiAgVGhlIFwianRpXCIgdmFsdWUgaXMgYSBjYXNlLVxuICAgICAqICAgc2Vuc2l0aXZlIHN0cmluZy4gIFVzZSBvZiB0aGlzIGNsYWltIGlzIE9QVElPTkFMLlxuICAgICAqL1xuICAgIGp0aToge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpXVENsYWltc1NldFNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgSldLU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG4vKipcbiAqIEpPU0VIZWFkZXJTY2hlbWFcbiAqXG4gKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi01XG4gKlxuICogNS4gIEpPU0UgSGVhZGVyXG4gKlxuICogICBGb3IgYSBKV1Qgb2JqZWN0LCB0aGUgbWVtYmVycyBvZiB0aGUgSlNPTiBvYmplY3QgcmVwcmVzZW50ZWQgYnkgdGhlXG4gKiAgIEpPU0UgSGVhZGVyIGRlc2NyaWJlIHRoZSBjcnlwdG9ncmFwaGljIG9wZXJhdGlvbnMgYXBwbGllZCB0byB0aGUgSldUXG4gKiAgIGFuZCBvcHRpb25hbGx5LCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb2YgdGhlIEpXVC4gIERlcGVuZGluZyB1cG9uXG4gKiAgIHdoZXRoZXIgdGhlIEpXVCBpcyBhIEpXUyBvciBKV0UsIHRoZSBjb3JyZXNwb25kaW5nIHJ1bGVzIGZvciB0aGUgSk9TRVxuICogICBIZWFkZXIgdmFsdWVzIGFwcGx5LlxuICovXG5cblxudmFyIEpPU0VIZWFkZXJTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiB0eXBcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi01LjFcbiAgICAgKlxuICAgICAqIDUuMS4gIFwidHlwXCIgKFR5cGUpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwidHlwXCIgKHR5cGUpIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBieSBbSldTXSBhbmQgW0pXRV0gaXMgdXNlZFxuICAgICAqICAgYnkgSldUIGFwcGxpY2F0aW9ucyB0byBkZWNsYXJlIHRoZSBtZWRpYSB0eXBlIFtJQU5BLk1lZGlhVHlwZXNdIG9mXG4gICAgICogICB0aGlzIGNvbXBsZXRlIEpXVC4gIFRoaXMgaXMgaW50ZW5kZWQgZm9yIHVzZSBieSB0aGUgSldUIGFwcGxpY2F0aW9uXG4gICAgICogICB3aGVuIHZhbHVlcyB0aGF0IGFyZSBub3QgSldUcyBjb3VsZCBhbHNvIGJlIHByZXNlbnQgaW4gYW4gYXBwbGljYXRpb25cbiAgICAgKiAgIGRhdGEgc3RydWN0dXJlIHRoYXQgY2FuIGNvbnRhaW4gYSBKV1Qgb2JqZWN0OyB0aGUgYXBwbGljYXRpb24gY2FuIHVzZVxuICAgICAqICAgdGhpcyB2YWx1ZSB0byBkaXNhbWJpZ3VhdGUgYW1vbmcgdGhlIGRpZmZlcmVudCBraW5kcyBvZiBvYmplY3RzIHRoYXRcbiAgICAgKiAgIG1pZ2h0IGJlIHByZXNlbnQuICBJdCB3aWxsIHR5cGljYWxseSBub3QgYmUgdXNlZCBieSBhcHBsaWNhdGlvbnMgd2hlblxuICAgICAqICAgaXQgaXMgYWxyZWFkeSBrbm93biB0aGF0IHRoZSBvYmplY3QgaXMgYSBKV1QuICBUaGlzIHBhcmFtZXRlciBpc1xuICAgICAqICAgaWdub3JlZCBieSBKV1QgaW1wbGVtZW50YXRpb25zOyBhbnkgcHJvY2Vzc2luZyBvZiB0aGlzIHBhcmFtZXRlciBpc1xuICAgICAqICAgcGVyZm9ybWVkIGJ5IHRoZSBKV1QgYXBwbGljYXRpb24uICBJZiBwcmVzZW50LCBpdCBpcyBSRUNPTU1FTkRFRCB0aGF0XG4gICAgICogICBpdHMgdmFsdWUgYmUgXCJKV1RcIiB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIGEgSldULiAgV2hpbGVcbiAgICAgKiAgIG1lZGlhIHR5cGUgbmFtZXMgYXJlIG5vdCBjYXNlIHNlbnNpdGl2ZSwgaXQgaXMgUkVDT01NRU5ERUQgdGhhdCBcIkpXVFwiXG4gICAgICogICBhbHdheXMgYmUgc3BlbGxlZCB1c2luZyB1cHBlcmNhc2UgY2hhcmFjdGVycyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoXG4gICAgICogICBsZWdhY3kgaW1wbGVtZW50YXRpb25zLiAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjlcbiAgICAgKlxuICAgICAqIDQuMS45LiAgXCJ0eXBcIiAoVHlwZSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJ0eXBcIiAodHlwZSkgSGVhZGVyIFBhcmFtZXRlciBpcyB1c2VkIGJ5IEpXUyBhcHBsaWNhdGlvbnMgdG9cbiAgICAgKiAgIGRlY2xhcmUgdGhlIG1lZGlhIHR5cGUgW0lBTkEuTWVkaWFUeXBlc10gb2YgdGhpcyBjb21wbGV0ZSBKV1MuICBUaGlzXG4gICAgICogICBpcyBpbnRlbmRlZCBmb3IgdXNlIGJ5IHRoZSBhcHBsaWNhdGlvbiB3aGVuIG1vcmUgdGhhbiBvbmUga2luZCBvZlxuICAgICAqICAgb2JqZWN0IGNvdWxkIGJlIHByZXNlbnQgaW4gYW4gYXBwbGljYXRpb24gZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjYW5cbiAgICAgKiAgIGNvbnRhaW4gYSBKV1M7IHRoZSBhcHBsaWNhdGlvbiBjYW4gdXNlIHRoaXMgdmFsdWUgdG8gZGlzYW1iaWd1YXRlXG4gICAgICogICBhbW9uZyB0aGUgZGlmZmVyZW50IGtpbmRzIG9mIG9iamVjdHMgdGhhdCBtaWdodCBiZSBwcmVzZW50LiAgSXQgd2lsbFxuICAgICAqICAgdHlwaWNhbGx5IG5vdCBiZSB1c2VkIGJ5IGFwcGxpY2F0aW9ucyB3aGVuIHRoZSBraW5kIG9mIG9iamVjdCBpc1xuICAgICAqICAgYWxyZWFkeSBrbm93bi4gIFRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQgYnkgSldTIGltcGxlbWVudGF0aW9uczsgYW55XG4gICAgICogICBwcm9jZXNzaW5nIG9mIHRoaXMgcGFyYW1ldGVyIGlzIHBlcmZvcm1lZCBieSB0aGUgSldTIGFwcGxpY2F0aW9uLlxuICAgICAqICAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqICAgUGVyIFJGQyAyMDQ1IFtSRkMyMDQ1XSwgYWxsIG1lZGlhIHR5cGUgdmFsdWVzLCBzdWJ0eXBlIHZhbHVlcywgYW5kXG4gICAgICogICBwYXJhbWV0ZXIgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUuICBIb3dldmVyLCBwYXJhbWV0ZXIgdmFsdWVzIGFyZVxuICAgICAqICAgY2FzZSBzZW5zaXRpdmUgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQgZm9yIHRoZSBzcGVjaWZpYyBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiAgIFRvIGtlZXAgbWVzc2FnZXMgY29tcGFjdCBpbiBjb21tb24gc2l0dWF0aW9ucywgaXQgaXMgUkVDT01NRU5ERUQgdGhhdFxuICAgICAqICAgcHJvZHVjZXJzIG9taXQgYW4gXCJhcHBsaWNhdGlvbi9cIiBwcmVmaXggb2YgYSBtZWRpYSB0eXBlIHZhbHVlIGluIGFcbiAgICAgKiAgIFwidHlwXCIgSGVhZGVyIFBhcmFtZXRlciB3aGVuIG5vIG90aGVyICcvJyBhcHBlYXJzIGluIHRoZSBtZWRpYSB0eXBlXG4gICAgICogICB2YWx1ZS4gIEEgcmVjaXBpZW50IHVzaW5nIHRoZSBtZWRpYSB0eXBlIHZhbHVlIE1VU1QgdHJlYXQgaXQgYXMgaWZcbiAgICAgKiAgIFwiYXBwbGljYXRpb24vXCIgd2VyZSBwcmVwZW5kZWQgdG8gYW55IFwidHlwXCIgdmFsdWUgbm90IGNvbnRhaW5pbmcgYVxuICAgICAqICAgJy8nLiAgRm9yIGluc3RhbmNlLCBhIFwidHlwXCIgdmFsdWUgb2YgXCJleGFtcGxlXCIgU0hPVUxEIGJlIHVzZWQgdG9cbiAgICAgKiAgIHJlcHJlc2VudCB0aGUgXCJhcHBsaWNhdGlvbi9leGFtcGxlXCIgbWVkaWEgdHlwZSwgd2hlcmVhcyB0aGUgbWVkaWFcbiAgICAgKiAgIHR5cGUgXCJhcHBsaWNhdGlvbi9leGFtcGxlO3BhcnQ9XCIxLzJcIlwiIGNhbm5vdCBiZSBzaG9ydGVuZWQgdG9cbiAgICAgKiAgIFwiZXhhbXBsZTtwYXJ0PVwiMS8yXCJcIi5cbiAgICAgKlxuICAgICAqICAgVGhlIFwidHlwXCIgdmFsdWUgXCJKT1NFXCIgY2FuIGJlIHVzZWQgYnkgYXBwbGljYXRpb25zIHRvIGluZGljYXRlIHRoYXRcbiAgICAgKiAgIHRoaXMgb2JqZWN0IGlzIGEgSldTIG9yIEpXRSB1c2luZyB0aGUgSldTIENvbXBhY3QgU2VyaWFsaXphdGlvbiBvclxuICAgICAqICAgdGhlIEpXRSBDb21wYWN0IFNlcmlhbGl6YXRpb24uICBUaGUgXCJ0eXBcIiB2YWx1ZSBcIkpPU0UrSlNPTlwiIGNhbiBiZVxuICAgICAqICAgdXNlZCBieSBhcHBsaWNhdGlvbnMgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIG9iamVjdCBpcyBhIEpXUyBvciBKV0VcbiAgICAgKiAgIHVzaW5nIHRoZSBKV1MgSlNPTiBTZXJpYWxpemF0aW9uIG9yIHRoZSBKV0UgSlNPTiBTZXJpYWxpemF0aW9uLlxuICAgICAqICAgT3RoZXIgdHlwZSB2YWx1ZXMgY2FuIGFsc28gYmUgdXNlZCBieSBhcHBsaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMTFcbiAgICAgKlxuICAgICAqIDQuMS4xMS4gIFwidHlwXCIgKFR5cGUpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHRoZSBzYW1lIG1lYW5pbmcsIHN5bnRheCwgYW5kIHByb2Nlc3NpbmcgcnVsZXMgYXNcbiAgICAgKiAgIHRoZSBcInR5cFwiIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS45IG9mIFtKV1NdLCBleGNlcHRcbiAgICAgKiAgIHRoYXQgdGhlIHR5cGUgaXMgdGhhdCBvZiB0aGlzIGNvbXBsZXRlIEpXRS5cbiAgICAgKi9cbiAgICB0eXA6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGN0eVxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTUuMlxuICAgICAqXG4gICAgICogNS4yLiAgXCJjdHlcIiAoQ29udGVudCBUeXBlKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImN0eVwiIChjb250ZW50IHR5cGUpIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBieSBbSldTXSBhbmQgW0pXRV1cbiAgICAgKiAgIGlzIHVzZWQgYnkgdGhpcyBzcGVjaWZpY2F0aW9uIHRvIGNvbnZleSBzdHJ1Y3R1cmFsIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICogICB0aGUgSldULlxuICAgICAqXG4gICAgICogICBJbiB0aGUgbm9ybWFsIGNhc2UgaW4gd2hpY2ggbmVzdGVkIHNpZ25pbmcgb3IgZW5jcnlwdGlvbiBvcGVyYXRpb25zXG4gICAgICogICBhcmUgbm90IGVtcGxveWVkLCB0aGUgdXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBOT1RcbiAgICAgKiAgIFJFQ09NTUVOREVELiAgSW4gdGhlIGNhc2UgdGhhdCBuZXN0ZWQgc2lnbmluZyBvciBlbmNyeXB0aW9uIGlzXG4gICAgICogICBlbXBsb3llZCwgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIE1VU1QgYmUgcHJlc2VudDsgaW4gdGhpcyBjYXNlLCB0aGVcbiAgICAgKiAgIHZhbHVlIE1VU1QgYmUgXCJKV1RcIiwgdG8gaW5kaWNhdGUgdGhhdCBhIE5lc3RlZCBKV1QgaXMgY2FycmllZCBpbiB0aGlzXG4gICAgICogICBKV1QuICBXaGlsZSBtZWRpYSB0eXBlIG5hbWVzIGFyZSBub3QgY2FzZSBzZW5zaXRpdmUsIGl0IGlzXG4gICAgICogICBSRUNPTU1FTkRFRCB0aGF0IFwiSldUXCIgYWx3YXlzIGJlIHNwZWxsZWQgdXNpbmcgdXBwZXJjYXNlIGNoYXJhY3RlcnNcbiAgICAgKiAgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbGVnYWN5IGltcGxlbWVudGF0aW9ucy4gIFNlZSBBcHBlbmRpeCBBLjIgZm9yXG4gICAgICogICBhbiBleGFtcGxlIG9mIGEgTmVzdGVkIEpXVC5cbiAgICAgKlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuMTBcbiAgICAgKlxuICAgICAqIDQuMS4xMC4gIFwiY3R5XCIgKENvbnRlbnQgVHlwZSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJjdHlcIiAoY29udGVudCB0eXBlKSBIZWFkZXIgUGFyYW1ldGVyIGlzIHVzZWQgYnkgSldTIGFwcGxpY2F0aW9uc1xuICAgICAqICAgdG8gZGVjbGFyZSB0aGUgbWVkaWEgdHlwZSBbSUFOQS5NZWRpYVR5cGVzXSBvZiB0aGUgc2VjdXJlZCBjb250ZW50XG4gICAgICogICAodGhlIHBheWxvYWQpLiAgVGhpcyBpcyBpbnRlbmRlZCBmb3IgdXNlIGJ5IHRoZSBhcHBsaWNhdGlvbiB3aGVuIG1vcmVcbiAgICAgKiAgIHRoYW4gb25lIGtpbmQgb2Ygb2JqZWN0IGNvdWxkIGJlIHByZXNlbnQgaW4gdGhlIEpXUyBQYXlsb2FkOyB0aGVcbiAgICAgKiAgIGFwcGxpY2F0aW9uIGNhbiB1c2UgdGhpcyB2YWx1ZSB0byBkaXNhbWJpZ3VhdGUgYW1vbmcgdGhlIGRpZmZlcmVudFxuICAgICAqICAga2luZHMgb2Ygb2JqZWN0cyB0aGF0IG1pZ2h0IGJlIHByZXNlbnQuICBJdCB3aWxsIHR5cGljYWxseSBub3QgYmVcbiAgICAgKiAgIHVzZWQgYnkgYXBwbGljYXRpb25zIHdoZW4gdGhlIGtpbmQgb2Ygb2JqZWN0IGlzIGFscmVhZHkga25vd24uICBUaGlzXG4gICAgICogICBwYXJhbWV0ZXIgaXMgaWdub3JlZCBieSBKV1MgaW1wbGVtZW50YXRpb25zOyBhbnkgcHJvY2Vzc2luZyBvZiB0aGlzXG4gICAgICogICBwYXJhbWV0ZXIgaXMgcGVyZm9ybWVkIGJ5IHRoZSBKV1MgYXBwbGljYXRpb24uICBVc2Ugb2YgdGhpcyBIZWFkZXJcbiAgICAgKiAgIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqICAgUGVyIFJGQyAyMDQ1IFtSRkMyMDQ1XSwgYWxsIG1lZGlhIHR5cGUgdmFsdWVzLCBzdWJ0eXBlIHZhbHVlcywgYW5kXG4gICAgICogICBwYXJhbWV0ZXIgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUuICBIb3dldmVyLCBwYXJhbWV0ZXIgdmFsdWVzIGFyZVxuICAgICAqICAgY2FzZSBzZW5zaXRpdmUgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQgZm9yIHRoZSBzcGVjaWZpYyBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiAgIFRvIGtlZXAgbWVzc2FnZXMgY29tcGFjdCBpbiBjb21tb24gc2l0dWF0aW9ucywgaXQgaXMgUkVDT01NRU5ERUQgdGhhdFxuICAgICAqICAgcHJvZHVjZXJzIG9taXQgYW4gXCJhcHBsaWNhdGlvbi9cIiBwcmVmaXggb2YgYSBtZWRpYSB0eXBlIHZhbHVlIGluIGFcbiAgICAgKiAgIFwiY3R5XCIgSGVhZGVyIFBhcmFtZXRlciB3aGVuIG5vIG90aGVyICcvJyBhcHBlYXJzIGluIHRoZSBtZWRpYSB0eXBlXG4gICAgICogICB2YWx1ZS4gIEEgcmVjaXBpZW50IHVzaW5nIHRoZSBtZWRpYSB0eXBlIHZhbHVlIE1VU1QgdHJlYXQgaXQgYXMgaWZcbiAgICAgKiAgIFwiYXBwbGljYXRpb24vXCIgd2VyZSBwcmVwZW5kZWQgdG8gYW55IFwiY3R5XCIgdmFsdWUgbm90IGNvbnRhaW5pbmcgYVxuICAgICAqICAgJy8nLiAgRm9yIGluc3RhbmNlLCBhIFwiY3R5XCIgdmFsdWUgb2YgXCJleGFtcGxlXCIgU0hPVUxEIGJlIHVzZWQgdG9cbiAgICAgKiAgIHJlcHJlc2VudCB0aGUgXCJhcHBsaWNhdGlvbi9leGFtcGxlXCIgbWVkaWEgdHlwZSwgd2hlcmVhcyB0aGUgbWVkaWFcbiAgICAgKiAgIHR5cGUgXCJhcHBsaWNhdGlvbi9leGFtcGxlO3BhcnQ9XCIxLzJcIlwiIGNhbm5vdCBiZSBzaG9ydGVuZWQgdG9cbiAgICAgKiAgIFwiZXhhbXBsZTtwYXJ0PVwiMS8yXCJcIi5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS4xMlxuICAgICAqXG4gICAgICogNC4xLjEyLiAgXCJjdHlcIiAoQ29udGVudCBUeXBlKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJjdHlcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuMTAgb2YgW0pXU10sIGV4Y2VwdFxuICAgICAqICAgdGhhdCB0aGUgdHlwZSBpcyB0aGF0IG9mIHRoZSBzZWN1cmVkIGNvbnRlbnQgKHRoZSBwbGFpbnRleHQpLlxuICAgICAqL1xuICAgIGN0eToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ0pXVCddXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFsZ1xuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuMVxuICAgICAqXG4gICAgICogNC4xLjEuICBcImFsZ1wiIChBbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwiYWxnXCIgKGFsZ29yaXRobSkgSGVhZGVyIFBhcmFtZXRlciBpZGVudGlmaWVzIHRoZSBjcnlwdG9ncmFwaGljXG4gICAgICogICBhbGdvcml0aG0gdXNlZCB0byBzZWN1cmUgdGhlIEpXUy4gIFRoZSBKV1MgU2lnbmF0dXJlIHZhbHVlIGlzIG5vdFxuICAgICAqICAgdmFsaWQgaWYgdGhlIFwiYWxnXCIgdmFsdWUgZG9lcyBub3QgcmVwcmVzZW50IGEgc3VwcG9ydGVkIGFsZ29yaXRobSBvclxuICAgICAqICAgaWYgdGhlcmUgaXMgbm90IGEga2V5IGZvciB1c2Ugd2l0aCB0aGF0IGFsZ29yaXRobSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICBwYXJ0eSB0aGF0IGRpZ2l0YWxseSBzaWduZWQgb3IgTUFDZWQgdGhlIGNvbnRlbnQuICBcImFsZ1wiIHZhbHVlc1xuICAgICAqICAgc2hvdWxkIGVpdGhlciBiZSByZWdpc3RlcmVkIGluIHRoZSBJQU5BIFwiSlNPTiBXZWIgU2lnbmF0dXJlIGFuZFxuICAgICAqICAgRW5jcnlwdGlvbiBBbGdvcml0aG1zXCIgcmVnaXN0cnkgZXN0YWJsaXNoZWQgYnkgW0pXQV0gb3IgYmUgYSB2YWx1ZVxuICAgICAqICAgdGhhdCBjb250YWlucyBhIENvbGxpc2lvbi1SZXNpc3RhbnQgTmFtZS4gIFRoZSBcImFsZ1wiIHZhbHVlIGlzIGEgY2FzZS1cbiAgICAgKiAgIHNlbnNpdGl2ZSBBU0NJSSBzdHJpbmcgY29udGFpbmluZyBhIFN0cmluZ09yVVJJIHZhbHVlLiAgVGhpcyBIZWFkZXJcbiAgICAgKiAgIFBhcmFtZXRlciBNVVNUIGJlIHByZXNlbnQgYW5kIE1VU1QgYmUgdW5kZXJzdG9vZCBhbmQgcHJvY2Vzc2VkIGJ5XG4gICAgICogICBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICpcbiAgICAgKiAgIEEgbGlzdCBvZiBkZWZpbmVkIFwiYWxnXCIgdmFsdWVzIGZvciB0aGlzIHVzZSBjYW4gYmUgZm91bmQgaW4gdGhlIElBTkFcbiAgICAgKiAgIFwiSlNPTiBXZWIgU2lnbmF0dXJlIGFuZCBFbmNyeXB0aW9uIEFsZ29yaXRobXNcIiByZWdpc3RyeSBlc3RhYmxpc2hlZFxuICAgICAqICAgYnkgW0pXQV07IHRoZSBpbml0aWFsIGNvbnRlbnRzIG9mIHRoaXMgcmVnaXN0cnkgYXJlIHRoZSB2YWx1ZXNcbiAgICAgKiAgIGRlZmluZWQgaW4gU2VjdGlvbiAzLjEgb2YgW0pXQV0uXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMVxuICAgICAqXG4gICAgICogNC4xLjEuICBcImFsZ1wiIChBbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHRoZSBzYW1lIG1lYW5pbmcsIHN5bnRheCwgYW5kIHByb2Nlc3NpbmcgcnVsZXMgYXNcbiAgICAgKiAgIHRoZSBcImFsZ1wiIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS4xIG9mIFtKV1NdLCBleGNlcHRcbiAgICAgKiAgIHRoYXQgdGhlIEhlYWRlciBQYXJhbWV0ZXIgaWRlbnRpZmllcyB0aGUgY3J5cHRvZ3JhcGhpYyBhbGdvcml0aG0gdXNlZFxuICAgICAqICAgdG8gZW5jcnlwdCBvciBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBDRUsuICBUaGUgZW5jcnlwdGVkIGNvbnRlbnRcbiAgICAgKiAgIGlzIG5vdCB1c2FibGUgaWYgdGhlIFwiYWxnXCIgdmFsdWUgZG9lcyBub3QgcmVwcmVzZW50IGEgc3VwcG9ydGVkXG4gICAgICogICBhbGdvcml0aG0sIG9yIGlmIHRoZSByZWNpcGllbnQgZG9lcyBub3QgaGF2ZSBhIGtleSB0aGF0IGNhbiBiZSB1c2VkXG4gICAgICogICB3aXRoIHRoYXQgYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogICBBIGxpc3Qgb2YgZGVmaW5lZCBcImFsZ1wiIHZhbHVlcyBmb3IgdGhpcyB1c2UgY2FuIGJlIGZvdW5kIGluIHRoZSBJQU5BXG4gICAgICogICBcIkpTT04gV2ViIFNpZ25hdHVyZSBhbmQgRW5jcnlwdGlvbiBBbGdvcml0aG1zXCIgcmVnaXN0cnkgZXN0YWJsaXNoZWRcbiAgICAgKiAgIGJ5IFtKV0FdOyB0aGUgaW5pdGlhbCBjb250ZW50cyBvZiB0aGlzIHJlZ2lzdHJ5IGFyZSB0aGUgdmFsdWVzXG4gICAgICogICBkZWZpbmVkIGluIFNlY3Rpb24gNC4xIG9mIFtKV0FdLlxuICAgICAqL1xuICAgIGFsZzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogamt1XG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS4yXG4gICAgICpcbiAgICAgKiA0LjEuMi4gIFwiamt1XCIgKEpXSyBTZXQgVVJMKSBIZWFkZXIgUGFyYW1ldGVyIChKV1MpXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImprdVwiIChKV0sgU2V0IFVSTCkgSGVhZGVyIFBhcmFtZXRlciBpcyBhIFVSSSBbUkZDMzk4Nl0gdGhhdFxuICAgICAqICAgcmVmZXJzIHRvIGEgcmVzb3VyY2UgZm9yIGEgc2V0IG9mIEpTT04tZW5jb2RlZCBwdWJsaWMga2V5cywgb25lIG9mXG4gICAgICogICB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUga2V5IHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlIEpXUy4gIFRoZVxuICAgICAqICAga2V5cyBNVVNUIGJlIGVuY29kZWQgYXMgYSBKV0sgU2V0IFtKV0tdLiAgVGhlIHByb3RvY29sIHVzZWQgdG9cbiAgICAgKiAgIGFjcXVpcmUgdGhlIHJlc291cmNlIE1VU1QgcHJvdmlkZSBpbnRlZ3JpdHkgcHJvdGVjdGlvbjsgYW4gSFRUUCBHRVRcbiAgICAgKiAgIHJlcXVlc3QgdG8gcmV0cmlldmUgdGhlIEpXSyBTZXQgTVVTVCB1c2UgVHJhbnNwb3J0IExheWVyIFNlY3VyaXR5XG4gICAgICogICAoVExTKSBbUkZDMjgxOF0gW1JGQzUyNDZdOyBhbmQgdGhlIGlkZW50aXR5IG9mIHRoZSBzZXJ2ZXIgTVVTVCBiZVxuICAgICAqICAgdmFsaWRhdGVkLCBhcyBwZXIgU2VjdGlvbiA2IG9mIFJGQyA2MTI1IFtSRkM2MTI1XS4gIEFsc28sIHNlZVxuICAgICAqICAgU2VjdGlvbiA4IG9uIFRMUyByZXF1aXJlbWVudHMuICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzXG4gICAgICogICBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS40XG4gICAgICpcbiAgICAgKiA0LjEuNC4gIFwiamt1XCIgKEpXSyBTZXQgVVJMKSBIZWFkZXIgUGFyYW1ldGVyIChKV0UpXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJqa3VcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuMiBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBKV0sgU2V0IHJlc291cmNlIGNvbnRhaW5zIHRoZSBwdWJsaWMga2V5IHRvIHdoaWNoIHRoZSBKV0VcbiAgICAgKiAgIHdhcyBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcml2YXRlIGtleSBuZWVkZWRcbiAgICAgKiAgIHRvIGRlY3J5cHQgdGhlIEpXRS5cbiAgICAgKi9cbiAgICBqa3U6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnVVJJJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqd2tcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjNcbiAgICAgKlxuICAgICAqIDQuMS4zLiAgXCJqd2tcIiAoSlNPTiBXZWIgS2V5KSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImp3a1wiIChKU09OIFdlYiBLZXkpIEhlYWRlciBQYXJhbWV0ZXIgaXMgdGhlIHB1YmxpYyBrZXkgdGhhdFxuICAgICAqICAgY29ycmVzcG9uZHMgdG8gdGhlIGtleSB1c2VkIHRvIGRpZ2l0YWxseSBzaWduIHRoZSBKV1MuICBUaGlzIGtleSBpc1xuICAgICAqICAgcmVwcmVzZW50ZWQgYXMgYSBKU09OIFdlYiBLZXkgW0pXS10uICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzXG4gICAgICogICBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS41XG4gICAgICpcbiAgICAgKiA0LjEuNS4gIFwiandrXCIgKEpTT04gV2ViIEtleSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwiandrXCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjMgb2YgW0pXU10sIGV4Y2VwdFxuICAgICAqICAgdGhhdCB0aGUga2V5IGlzIHRoZSBwdWJsaWMga2V5IHRvIHdoaWNoIHRoZSBKV0Ugd2FzIGVuY3J5cHRlZDsgdGhpc1xuICAgICAqICAgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcml2YXRlIGtleSBuZWVkZWQgdG8gZGVjcnlwdCB0aGUgSldFLlxuICAgICAqL1xuICAgIC8vandrOiBKV0tTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiBraWRcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjRcbiAgICAgKlxuICAgICAqIDQuMS40LiAgXCJraWRcIiAoS2V5IElEKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImtpZFwiIChrZXkgSUQpIEhlYWRlciBQYXJhbWV0ZXIgaXMgYSBoaW50IGluZGljYXRpbmcgd2hpY2gga2V5XG4gICAgICogICB3YXMgdXNlZCB0byBzZWN1cmUgdGhlIEpXUy4gIFRoaXMgcGFyYW1ldGVyIGFsbG93cyBvcmlnaW5hdG9ycyB0b1xuICAgICAqICAgZXhwbGljaXRseSBzaWduYWwgYSBjaGFuZ2Ugb2Yga2V5IHRvIHJlY2lwaWVudHMuICBUaGUgc3RydWN0dXJlIG9mXG4gICAgICogICB0aGUgXCJraWRcIiB2YWx1ZSBpcyB1bnNwZWNpZmllZC4gIEl0cyB2YWx1ZSBNVVNUIGJlIGEgY2FzZS1zZW5zaXRpdmVcbiAgICAgKiAgIHN0cmluZy4gIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiAgIFdoZW4gdXNlZCB3aXRoIGEgSldLLCB0aGUgXCJraWRcIiB2YWx1ZSBpcyB1c2VkIHRvIG1hdGNoIGEgSldLIFwia2lkXCJcbiAgICAgKiAgIHBhcmFtZXRlciB2YWx1ZS5cbiAgICAgKlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjZcbiAgICAgKlxuICAgICAqIDQuMS42LiAgXCJraWRcIiAoS2V5IElEKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJraWRcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuNCBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBrZXkgaGludCByZWZlcmVuY2VzIHRoZSBwdWJsaWMga2V5IHRvIHdoaWNoIHRoZSBKV0Ugd2FzXG4gICAgICogICBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcml2YXRlIGtleSBuZWVkZWQgdG9cbiAgICAgKiAgIGRlY3J5cHQgdGhlIEpXRS4gIFRoaXMgcGFyYW1ldGVyIGFsbG93cyBvcmlnaW5hdG9ycyB0byBleHBsaWNpdGx5XG4gICAgICogICBzaWduYWwgYSBjaGFuZ2Ugb2Yga2V5IHRvIEpXRSByZWNpcGllbnRzLlxuICAgICAqL1xuICAgIGtpZDoge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogeDV1XG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS41XG4gICAgICpcbiAgICAgKiA0LjEuNS4gIFwieDV1XCIgKFguNTA5IFVSTCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJ4NXVcIiAoWC41MDkgVVJMKSBIZWFkZXIgUGFyYW1ldGVyIGlzIGEgVVJJIFtSRkMzOTg2XSB0aGF0IHJlZmVyc1xuICAgICAqICAgdG8gYSByZXNvdXJjZSBmb3IgdGhlIFguNTA5IHB1YmxpYyBrZXkgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGVcbiAgICAgKiAgIGNoYWluIFtSRkM1MjgwXSBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXkgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiB0aGVcbiAgICAgKiAgIEpXUy4gIFRoZSBpZGVudGlmaWVkIHJlc291cmNlIE1VU1QgcHJvdmlkZSBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAqICAgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gdGhhdCBjb25mb3JtcyB0byBSRkMgNTI4MCBbUkZDNTI4MF1cbiAgICAgKiAgIGluIFBFTS1lbmNvZGVkIGZvcm0sIHdpdGggZWFjaCBjZXJ0aWZpY2F0ZSBkZWxpbWl0ZWQgYXMgc3BlY2lmaWVkIGluXG4gICAgICogICBTZWN0aW9uIDYuMSBvZiBSRkMgNDk0NSBbUkZDNDk0NV0uICBUaGUgY2VydGlmaWNhdGUgY29udGFpbmluZyB0aGVcbiAgICAgKiAgIHB1YmxpYyBrZXkgY29ycmVzcG9uZGluZyB0byB0aGUga2V5IHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlIEpXU1xuICAgICAqICAgTVVTVCBiZSB0aGUgZmlyc3QgY2VydGlmaWNhdGUuICBUaGlzIE1BWSBiZSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsXG4gICAgICogICBjZXJ0aWZpY2F0ZXMsIHdpdGggZWFjaCBzdWJzZXF1ZW50IGNlcnRpZmljYXRlIGJlaW5nIHRoZSBvbmUgdXNlZCB0b1xuICAgICAqICAgY2VydGlmeSB0aGUgcHJldmlvdXMgb25lLiAgVGhlIHByb3RvY29sIHVzZWQgdG8gYWNxdWlyZSB0aGUgcmVzb3VyY2VcbiAgICAgKiAgIE1VU1QgcHJvdmlkZSBpbnRlZ3JpdHkgcHJvdGVjdGlvbjsgYW4gSFRUUCBHRVQgcmVxdWVzdCB0byByZXRyaWV2ZVxuICAgICAqICAgdGhlIGNlcnRpZmljYXRlIE1VU1QgdXNlIFRMUyBbUkZDMjgxOF0gW1JGQzUyNDZdOyBhbmQgdGhlIGlkZW50aXR5IG9mXG4gICAgICogICB0aGUgc2VydmVyIE1VU1QgYmUgdmFsaWRhdGVkLCBhcyBwZXIgU2VjdGlvbiA2IG9mIFJGQyA2MTI1IFtSRkM2MTI1XS5cbiAgICAgKiAgIEFsc28sIHNlZSBTZWN0aW9uIDggb24gVExTIHJlcXVpcmVtZW50cy4gIFVzZSBvZiB0aGlzIEhlYWRlclxuICAgICAqICAgUGFyYW1ldGVyIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjdcbiAgICAgKlxuICAgICAqIDQuMS43LiAgXCJ4NXVcIiAoWC41MDkgVVJMKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJ4NXVcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuNSBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBYLjUwOSBwdWJsaWMga2V5IGNlcnRpZmljYXRlIG9yIGNlcnRpZmljYXRlIGNoYWluIFtSRkM1MjgwXVxuICAgICAqICAgY29udGFpbnMgdGhlIHB1YmxpYyBrZXkgdG8gd2hpY2ggdGhlIEpXRSB3YXMgZW5jcnlwdGVkOyB0aGlzIGNhbiBiZVxuICAgICAqICAgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHByaXZhdGUga2V5IG5lZWRlZCB0byBkZWNyeXB0IHRoZSBKV0UuXG4gICAgICovXG4gICAgeDV1OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGZvcm1hdDogJ1VSSSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogeDVjXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS42XG4gICAgICpcbiAgICAgKiA0LjEuNi4gIFwieDVjXCIgKFguNTA5IENlcnRpZmljYXRlIENoYWluKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcIng1Y1wiIChYLjUwOSBjZXJ0aWZpY2F0ZSBjaGFpbikgSGVhZGVyIFBhcmFtZXRlciBjb250YWlucyB0aGVcbiAgICAgKiAgIFguNTA5IHB1YmxpYyBrZXkgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gW1JGQzUyODBdXG4gICAgICogICBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXkgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiB0aGUgSldTLiAgVGhlXG4gICAgICogICBjZXJ0aWZpY2F0ZSBvciBjZXJ0aWZpY2F0ZSBjaGFpbiBpcyByZXByZXNlbnRlZCBhcyBhIEpTT04gYXJyYXkgb2ZcbiAgICAgKiAgIGNlcnRpZmljYXRlIHZhbHVlIHN0cmluZ3MuICBFYWNoIHN0cmluZyBpbiB0aGUgYXJyYXkgaXMgYVxuICAgICAqICAgYmFzZTY0LWVuY29kZWQgKFNlY3Rpb24gNCBvZiBbUkZDNDY0OF0gLS0gbm90IGJhc2U2NHVybC1lbmNvZGVkKSBERVJcbiAgICAgKiAgIFtJVFUuWDY5MC4yMDA4XSBQS0lYIGNlcnRpZmljYXRlIHZhbHVlLiAgVGhlIGNlcnRpZmljYXRlIGNvbnRhaW5pbmdcbiAgICAgKiAgIHRoZSBwdWJsaWMga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleSB1c2VkIHRvIGRpZ2l0YWxseSBzaWduIHRoZVxuICAgICAqICAgSldTIE1VU1QgYmUgdGhlIGZpcnN0IGNlcnRpZmljYXRlLiAgVGhpcyBNQVkgYmUgZm9sbG93ZWQgYnlcbiAgICAgKiAgIGFkZGl0aW9uYWwgY2VydGlmaWNhdGVzLCB3aXRoIGVhY2ggc3Vic2VxdWVudCBjZXJ0aWZpY2F0ZSBiZWluZyB0aGVcbiAgICAgKiAgIG9uZSB1c2VkIHRvIGNlcnRpZnkgdGhlIHByZXZpb3VzIG9uZS4gIFRoZSByZWNpcGllbnQgTVVTVCB2YWxpZGF0ZVxuICAgICAqICAgdGhlIGNlcnRpZmljYXRlIGNoYWluIGFjY29yZGluZyB0byBSRkMgNTI4MCBbUkZDNTI4MF0gYW5kIGNvbnNpZGVyXG4gICAgICogICB0aGUgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gdG8gYmUgaW52YWxpZCBpZiBhbnkgdmFsaWRhdGlvblxuICAgICAqICAgZmFpbHVyZSBvY2N1cnMuICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjhcbiAgICAgKlxuICAgICAqIDQuMS44LiAgXCJ4NWNcIiAoWC41MDkgQ2VydGlmaWNhdGUgQ2hhaW4pIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHRoZSBzYW1lIG1lYW5pbmcsIHN5bnRheCwgYW5kIHByb2Nlc3NpbmcgcnVsZXMgYXNcbiAgICAgKiAgIHRoZSBcIng1Y1wiIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS42IG9mIFtKV1NdLCBleGNlcHRcbiAgICAgKiAgIHRoYXQgdGhlIFguNTA5IHB1YmxpYyBrZXkgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gW1JGQzUyODBdXG4gICAgICogICBjb250YWlucyB0aGUgcHVibGljIGtleSB0byB3aGljaCB0aGUgSldFIHdhcyBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlXG4gICAgICogICB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvIGRlY3J5cHQgdGhlIEpXRS5cbiAgICAgKi9cbiAgICB4NWM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZm9ybWF0OiAnYmFzZTY0J1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB4NXRcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjdcbiAgICAgKlxuICAgICAqIDQuMS43LiAgXCJ4NXRcIiAoWC41MDkgQ2VydGlmaWNhdGUgU0hBLTEgVGh1bWJwcmludCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJ4NXRcIiAoWC41MDkgY2VydGlmaWNhdGUgU0hBLTEgdGh1bWJwcmludCkgSGVhZGVyIFBhcmFtZXRlciBpcyBhXG4gICAgICogICBiYXNlNjR1cmwtZW5jb2RlZCBTSEEtMSB0aHVtYnByaW50IChhLmsuYS4gZGlnZXN0KSBvZiB0aGUgREVSXG4gICAgICogICBlbmNvZGluZyBvZiB0aGUgWC41MDkgY2VydGlmaWNhdGUgW1JGQzUyODBdIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleVxuICAgICAqICAgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiB0aGUgSldTLiAgTm90ZSB0aGF0IGNlcnRpZmljYXRlIHRodW1icHJpbnRzXG4gICAgICogICBhcmUgYWxzbyBzb21ldGltZXMga25vd24gYXMgY2VydGlmaWNhdGUgZmluZ2VycHJpbnRzLiAgVXNlIG9mIHRoaXNcbiAgICAgKiAgIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuOVxuICAgICAqXG4gICAgICogNC4xLjkuICBcIng1dFwiIChYLjUwOSBDZXJ0aWZpY2F0ZSBTSEEtMSBUaHVtYnByaW50KSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJ4NXRcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuNyBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSByZWZlcmVuY2VkIGJ5IHRoZSB0aHVtYnByaW50IGNvbnRhaW5zIHRoZSBwdWJsaWNcbiAgICAgKiAgIGtleSB0byB3aGljaCB0aGUgSldFIHdhcyBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZVxuICAgICAqICAgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvIGRlY3J5cHQgdGhlIEpXRS4gIE5vdGUgdGhhdCBjZXJ0aWZpY2F0ZVxuICAgICAqICAgdGh1bWJwcmludHMgYXJlIGFsc28gc29tZXRpbWVzIGtub3duIGFzIGNlcnRpZmljYXRlIGZpbmdlcnByaW50cy5cbiAgICAgKi9cbiAgICB4NXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnYmFzZTY0dXJsJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB4NXQjUzI1NlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuOFxuICAgICAqXG4gICAgICogNC4xLjguICBcIng1dCNTMjU2XCIgKFguNTA5IENlcnRpZmljYXRlIFNIQS0yNTYgVGh1bWJwcmludCkgSGVhZGVyXG4gICAgICogICAgICAgICBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwieDV0I1MyNTZcIiAoWC41MDkgY2VydGlmaWNhdGUgU0hBLTI1NiB0aHVtYnByaW50KSBIZWFkZXJcbiAgICAgKiAgIFBhcmFtZXRlciBpcyBhIGJhc2U2NHVybC1lbmNvZGVkIFNIQS0yNTYgdGh1bWJwcmludCAoYS5rLmEuIGRpZ2VzdClcbiAgICAgKiAgIG9mIHRoZSBERVIgZW5jb2Rpbmcgb2YgdGhlIFguNTA5IGNlcnRpZmljYXRlIFtSRkM1MjgwXSBjb3JyZXNwb25kaW5nXG4gICAgICogICB0byB0aGUga2V5IHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlIEpXUy4gIE5vdGUgdGhhdCBjZXJ0aWZpY2F0ZVxuICAgICAqICAgdGh1bWJwcmludHMgYXJlIGFsc28gc29tZXRpbWVzIGtub3duIGFzIGNlcnRpZmljYXRlIGZpbmdlcnByaW50cy5cbiAgICAgKiAgIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS4xMFxuICAgICAqXG4gICAgICogNC4xLjEwLiAgXCJ4NXQjUzI1NlwiIChYLjUwOSBDZXJ0aWZpY2F0ZSBTSEEtMjU2IFRodW1icHJpbnQpIEhlYWRlclxuICAgICAqICAgICAgICAgIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwieDV0I1MyNTZcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuOCBvZiBbSldTXSxcbiAgICAgKiAgIGV4Y2VwdCB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSByZWZlcmVuY2VkIGJ5IHRoZSB0aHVtYnByaW50IGNvbnRhaW5zIHRoZVxuICAgICAqICAgcHVibGljIGtleSB0byB3aGljaCB0aGUgSldFIHdhcyBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiAgIGRldGVybWluZSB0aGUgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvIGRlY3J5cHQgdGhlIEpXRS4gIE5vdGUgdGhhdFxuICAgICAqICAgY2VydGlmaWNhdGUgdGh1bWJwcmludHMgYXJlIGFsc28gc29tZXRpbWVzIGtub3duIGFzIGNlcnRpZmljYXRlXG4gICAgICogICBmaW5nZXJwcmludHMuXG4gICAgICovXG4gICAgLy8neDV0I1MyNTYnOiB7XG4gICAgLy8gIHR5cGU6ICdzdHJpbmcnLFxuICAgIC8vICBmb3JtYXQ6ICdiYXNlNjR1cmwnXG4gICAgLy99LFxuXG4gICAgLyoqXG4gICAgICogY3JpdFxuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuMTFcbiAgICAgKlxuICAgICAqIDQuMS4xMS4gIFwiY3JpdFwiIChDcml0aWNhbCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJjcml0XCIgKGNyaXRpY2FsKSBIZWFkZXIgUGFyYW1ldGVyIGluZGljYXRlcyB0aGF0IGV4dGVuc2lvbnMgdG9cbiAgICAgKiAgIHRoaXMgc3BlY2lmaWNhdGlvbiBhbmQvb3IgW0pXQV0gYXJlIGJlaW5nIHVzZWQgdGhhdCBNVVNUIGJlXG4gICAgICogICB1bmRlcnN0b29kIGFuZCBwcm9jZXNzZWQuICBJdHMgdmFsdWUgaXMgYW4gYXJyYXkgbGlzdGluZyB0aGUgSGVhZGVyXG4gICAgICogICBQYXJhbWV0ZXIgbmFtZXMgcHJlc2VudCBpbiB0aGUgSk9TRSBIZWFkZXIgdGhhdCB1c2UgdGhvc2UgZXh0ZW5zaW9ucy5cbiAgICAgKiAgIElmIGFueSBvZiB0aGUgbGlzdGVkIGV4dGVuc2lvbiBIZWFkZXIgUGFyYW1ldGVycyBhcmUgbm90IHVuZGVyc3Rvb2RcbiAgICAgKiAgIGFuZCBzdXBwb3J0ZWQgYnkgdGhlIHJlY2lwaWVudCwgdGhlbiB0aGUgSldTIGlzIGludmFsaWQuICBQcm9kdWNlcnNcbiAgICAgKiAgIE1VU1QgTk9UIGluY2x1ZGUgSGVhZGVyIFBhcmFtZXRlciBuYW1lcyBkZWZpbmVkIGJ5IHRoaXMgc3BlY2lmaWNhdGlvblxuICAgICAqICAgb3IgW0pXQV0gZm9yIHVzZSB3aXRoIEpXUywgZHVwbGljYXRlIG5hbWVzLCBvciBuYW1lcyB0aGF0IGRvIG5vdFxuICAgICAqICAgb2NjdXIgYXMgSGVhZGVyIFBhcmFtZXRlciBuYW1lcyB3aXRoaW4gdGhlIEpPU0UgSGVhZGVyIGluIHRoZSBcImNyaXRcIlxuICAgICAqICAgbGlzdC4gIFByb2R1Y2VycyBNVVNUIE5PVCB1c2UgdGhlIGVtcHR5IGxpc3QgXCJbXVwiIGFzIHRoZSBcImNyaXRcIlxuICAgICAqICAgdmFsdWUuICBSZWNpcGllbnRzIE1BWSBjb25zaWRlciB0aGUgSldTIHRvIGJlIGludmFsaWQgaWYgdGhlIGNyaXRpY2FsXG4gICAgICogICBsaXN0IGNvbnRhaW5zIGFueSBIZWFkZXIgUGFyYW1ldGVyIG5hbWVzIGRlZmluZWQgYnkgdGhpc1xuICAgICAqICAgc3BlY2lmaWNhdGlvbiBvciBbSldBXSBmb3IgdXNlIHdpdGggSldTIG9yIGlmIGFueSBvdGhlciBjb25zdHJhaW50c1xuICAgICAqICAgb24gaXRzIHVzZSBhcmUgdmlvbGF0ZWQuICBXaGVuIHVzZWQsIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBNVVNUIGJlXG4gICAgICogICBpbnRlZ3JpdHkgcHJvdGVjdGVkOyB0aGVyZWZvcmUsIGl0IE1VU1Qgb2NjdXIgb25seSB3aXRoaW4gdGhlIEpXU1xuICAgICAqICAgUHJvdGVjdGVkIEhlYWRlci4gIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuICBUaGlzXG4gICAgICogICBIZWFkZXIgUGFyYW1ldGVyIE1VU1QgYmUgdW5kZXJzdG9vZCBhbmQgcHJvY2Vzc2VkIGJ5IGltcGxlbWVudGF0aW9ucy5cbiAgICAgKlxuICAgICAqICAgQW4gZXhhbXBsZSB1c2UsIGFsb25nIHdpdGggYSBoeXBvdGhldGljYWwgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKVxuICAgICAqICAgZmllbGQgaXM6XG4gICAgICpcbiAgICAgKiAgICAge1wiYWxnXCI6XCJFUzI1NlwiLFxuICAgICAqICAgICBcImNyaXRcIjpbXCJleHBcIl0sXG4gICAgICogICAgIFwiZXhwXCI6MTM2MzI4NDAwMFxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMTNcbiAgICAgKlxuICAgICAqICAgNC4xLjEzLiAgXCJjcml0XCIgKENyaXRpY2FsKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJjcml0XCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjExIG9mIFtKV1NdLFxuICAgICAqICAgZXhjZXB0IHRoYXQgSGVhZGVyIFBhcmFtZXRlcnMgZm9yIGEgSldFIGFyZSBiZWluZyByZWZlcnJlZCB0bywgcmF0aGVyXG4gICAgICogICB0aGFuIEhlYWRlciBQYXJhbWV0ZXJzIGZvciBhIEpXUy5cbiAgICAgKi9cbiAgICBjcml0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIH0sXG4gICAgICBtaW5JdGVtczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbmNcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS4yXG4gICAgICpcbiAgICAgKiA0LjEuMi4gIFwiZW5jXCIgKEVuY3J5cHRpb24gQWxnb3JpdGhtKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImVuY1wiIChlbmNyeXB0aW9uIGFsZ29yaXRobSkgSGVhZGVyIFBhcmFtZXRlciBpZGVudGlmaWVzIHRoZVxuICAgICAqICAgY29udGVudCBlbmNyeXB0aW9uIGFsZ29yaXRobSB1c2VkIHRvIHBlcmZvcm0gYXV0aGVudGljYXRlZCBlbmNyeXB0aW9uXG4gICAgICogICBvbiB0aGUgcGxhaW50ZXh0IHRvIHByb2R1Y2UgdGhlIGNpcGhlcnRleHQgYW5kIHRoZSBBdXRoZW50aWNhdGlvblxuICAgICAqICAgVGFnLiAgVGhpcyBhbGdvcml0aG0gTVVTVCBiZSBhbiBBRUFEIGFsZ29yaXRobSB3aXRoIGEgc3BlY2lmaWVkIGtleVxuICAgICAqICAgbGVuZ3RoLiAgVGhlIGVuY3J5cHRlZCBjb250ZW50IGlzIG5vdCB1c2FibGUgaWYgdGhlIFwiZW5jXCIgdmFsdWUgZG9lc1xuICAgICAqICAgbm90IHJlcHJlc2VudCBhIHN1cHBvcnRlZCBhbGdvcml0aG0uICBcImVuY1wiIHZhbHVlcyBzaG91bGQgZWl0aGVyIGJlXG4gICAgICogICByZWdpc3RlcmVkIGluIHRoZSBJQU5BIFwiSlNPTiBXZWIgU2lnbmF0dXJlIGFuZCBFbmNyeXB0aW9uIEFsZ29yaXRobXNcIlxuICAgICAqICAgcmVnaXN0cnkgZXN0YWJsaXNoZWQgYnkgW0pXQV0gb3IgYmUgYSB2YWx1ZSB0aGF0IGNvbnRhaW5zIGFcbiAgICAgKiAgIENvbGxpc2lvbi1SZXNpc3RhbnQgTmFtZS4gIFRoZSBcImVuY1wiIHZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgQVNDSUlcbiAgICAgKiAgIHN0cmluZyBjb250YWluaW5nIGEgU3RyaW5nT3JVUkkgdmFsdWUuICBUaGlzIEhlYWRlciBQYXJhbWV0ZXIgTVVTVCBiZVxuICAgICAqICAgcHJlc2VudCBhbmQgTVVTVCBiZSB1bmRlcnN0b29kIGFuZCBwcm9jZXNzZWQgYnkgaW1wbGVtZW50YXRpb25zLlxuICAgICAqXG4gICAgICogICBBIGxpc3Qgb2YgZGVmaW5lZCBcImVuY1wiIHZhbHVlcyBmb3IgdGhpcyB1c2UgY2FuIGJlIGZvdW5kIGluIHRoZSBJQU5BXG4gICAgICogICBcIkpTT04gV2ViIFNpZ25hdHVyZSBhbmQgRW5jcnlwdGlvbiBBbGdvcml0aG1zXCIgcmVnaXN0cnkgZXN0YWJsaXNoZWRcbiAgICAgKiAgIGJ5IFtKV0FdOyB0aGUgaW5pdGlhbCBjb250ZW50cyBvZiB0aGlzIHJlZ2lzdHJ5IGFyZSB0aGUgdmFsdWVzXG4gICAgICogICBkZWZpbmVkIGluIFNlY3Rpb24gNS4xIG9mIFtKV0FdLlxuICAgICAqL1xuICAgIGVuYzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogemlwXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuM1xuICAgICAqXG4gICAgICogNC4xLjMuICBcInppcFwiIChDb21wcmVzc2lvbiBBbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwiemlwXCIgKGNvbXByZXNzaW9uIGFsZ29yaXRobSkgYXBwbGllZCB0byB0aGUgcGxhaW50ZXh0IGJlZm9yZVxuICAgICAqICAgZW5jcnlwdGlvbiwgaWYgYW55LiAgVGhlIFwiemlwXCIgdmFsdWUgZGVmaW5lZCBieSB0aGlzIHNwZWNpZmljYXRpb25cbiAgICAgKiAgIGlzOlxuICAgICAqXG4gICAgICogICBvICBcIkRFRlwiIC0gQ29tcHJlc3Npb24gd2l0aCB0aGUgREVGTEFURSBbUkZDMTk1MV0gYWxnb3JpdGhtXG4gICAgICpcbiAgICAgKiAgIE90aGVyIHZhbHVlcyBNQVkgYmUgdXNlZC4gIENvbXByZXNzaW9uIGFsZ29yaXRobSB2YWx1ZXMgY2FuIGJlXG4gICAgICogICByZWdpc3RlcmVkIGluIHRoZSBJQU5BIFwiSlNPTiBXZWIgRW5jcnlwdGlvbiBDb21wcmVzc2lvbiBBbGdvcml0aG1zXCJcbiAgICAgKiAgIHJlZ2lzdHJ5IGVzdGFibGlzaGVkIGJ5IFtKV0FdLiAgVGhlIFwiemlwXCIgdmFsdWUgaXMgYSBjYXNlLXNlbnNpdGl2ZVxuICAgICAqICAgc3RyaW5nLiAgSWYgbm8gXCJ6aXBcIiBwYXJhbWV0ZXIgaXMgcHJlc2VudCwgbm8gY29tcHJlc3Npb24gaXMgYXBwbGllZFxuICAgICAqICAgdG8gdGhlIHBsYWludGV4dCBiZWZvcmUgZW5jcnlwdGlvbi4gIFdoZW4gdXNlZCwgdGhpcyBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICogICBNVVNUIGJlIGludGVncml0eSBwcm90ZWN0ZWQ7IHRoZXJlZm9yZSwgaXQgTVVTVCBvY2N1ciBvbmx5IHdpdGhpbiB0aGVcbiAgICAgKiAgIEpXRSBQcm90ZWN0ZWQgSGVhZGVyLiAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKiAgIFRoaXMgSGVhZGVyIFBhcmFtZXRlciBNVVNUIGJlIHVuZGVyc3Rvb2QgYW5kIHByb2Nlc3NlZCBieVxuICAgICAqICAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqL1xuICAgIHppcDoge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpPU0VIZWFkZXJTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgSldBID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpLFxuICAgIERhdGFFcnJvciA9IF9yZXF1aXJlLkRhdGFFcnJvcjtcblxuLyoqXG4gKiBKV1NcbiAqL1xuXG5cbnZhciBKV1MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEpXUygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSldTKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKV1MsIG51bGwsIFt7XG4gICAga2V5OiAnc2lnbicsXG5cblxuICAgIC8qKlxuICAgICAqIHNpZ25cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEVuY29kZSBhIEpXVCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24odG9rZW4pIHtcbiAgICAgIHZhciBwYXlsb2FkID0gYmFzZTY0dXJsKEpTT04uc3RyaW5naWZ5KHRva2VuLnBheWxvYWQpKTtcblxuICAgICAgLy8gY29tcGFjdCBzZXJpYWxpemF0aW9uXG4gICAgICBpZiAodG9rZW4uc2VyaWFsaXphdGlvbiA9PT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b2tlbi5rZXksXG4gICAgICAgICAgICBhbGcgPSB0b2tlbi5oZWFkZXIuYWxnO1xuXG4gICAgICAgIHZhciBoZWFkZXIgPSBiYXNlNjR1cmwoSlNPTi5zdHJpbmdpZnkodG9rZW4uaGVhZGVyKSk7XG4gICAgICAgIHZhciBkYXRhID0gaGVhZGVyICsgJy4nICsgcGF5bG9hZDtcblxuICAgICAgICByZXR1cm4gSldBLnNpZ24oYWxnLCBrZXksIGRhdGEpLnRoZW4oZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICAgIHJldHVybiBkYXRhICsgJy4nICsgc2lnbmF0dXJlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gSlNPTiBzZXJpYWxpemF0aW9uXG4gICAgICBpZiAodG9rZW4uc2VyaWFsaXphdGlvbiA9PT0gJ2pzb24nKSB7fVxuXG4gICAgICAvLyBGbGF0dGVuZWQgc2VyaWFsaXphdGlvblxuICAgICAgaWYgKHRva2VuLnNlcmlhbGl6YXRpb24gPT09ICdmbGF0dGVuZWQnKSB7fVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERhdGFFcnJvcignVW5zdXBwb3J0ZWQgc2VyaWFsaXphdGlvbicpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB2ZXJpZnlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmVyaWZ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5KGp3dCkge1xuICAgICAgLy8gbXVsdGlwbGUgc2lnbmF0dXJlc1xuICAgICAgaWYgKGp3dC5zaWduYXR1cmVzKSB7XG4gICAgICAgIC8vIC4uLlxuICAgICAgfVxuXG4gICAgICB2YXIga2V5ID0gand0LmtleSxcbiAgICAgICAgICBzaWduYXR1cmUgPSBqd3Quc2lnbmF0dXJlLFxuICAgICAgICAgIGFsZyA9IGp3dC5oZWFkZXIuYWxnO1xuXG4gICAgICAvLyBvbmUgc2lnbmF0dXJlXG5cbiAgICAgIGlmIChqd3Quc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBfand0JHNlZ21lbnRzID0gX3NsaWNlZFRvQXJyYXkoand0LnNlZ21lbnRzLCAyKSxcbiAgICAgICAgICAgIGhlYWRlciA9IF9qd3Qkc2VnbWVudHNbMF0sXG4gICAgICAgICAgICBwYXlsb2FkID0gX2p3dCRzZWdtZW50c1sxXTtcblxuICAgICAgICB2YXIgZGF0YSA9IGhlYWRlciArICcuJyArIHBheWxvYWQ7XG5cbiAgICAgICAgaWYgKGFsZyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBEYXRhRXJyb3IoJ1NpZ25hdHVyZSBwcm92aWRlZCB0byB2ZXJpZnkgd2l0aCBhbGc6IG5vbmUnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSldBLnZlcmlmeShhbGcsIGtleSwgc2lnbmF0dXJlLCBkYXRhKS50aGVuKGZ1bmN0aW9uICh2ZXJpZmllZCkge1xuICAgICAgICAgIGp3dC52ZXJpZmllZCA9IHZlcmlmaWVkO1xuICAgICAgICAgIHJldHVybiB2ZXJpZmllZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGcgPT09ICdub25lJykge1xuICAgICAgICBpZiAoIWtleSAmJiAhc2lnbmF0dXJlKSB7XG4gICAgICAgICAgand0LnZlcmlmaWVkID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBEYXRhRXJyb3IoJ0tleSBwcm92aWRlZCB0byB2ZXJpZnkgc2lnbmF0dXJlIHdpdGggYWxnOiBub25lJykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIHNpZ25hdHVyZXMgdG8gdmVyaWZ5XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERhdGFFcnJvcignTWlzc2luZyBzaWduYXR1cmUocyknKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpXUztcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSldTO1xuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHsvKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5jb25zdCBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxuY29uc3QgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbmNvbnN0IGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG5jb25zdCB7XG4gIEpXVFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG5jb25zdCBGb3JtVXJsRW5jb2RlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuXG5jb25zdCB7XG4gIFVSTFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuLyoqXG4gKiBBdXRoZW50aWNhdGlvbiBSZXF1ZXN0XG4gKi9cblxuXG5jbGFzcyBBdXRoZW50aWNhdGlvblJlcXVlc3Qge1xuICAvKipcbiAgICogY3JlYXRlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDcmVhdGUgYSBuZXcgYXV0aGVudGljYXRpb24gcmVxdWVzdCB3aXRoIGdlbmVyYXRlZCBzdGF0ZSBhbmQgbm9uY2UsXG4gICAqIHZhbGlkYXRlIHByZXNlbmNlIG9mIHJlcXVpcmVkIHBhcmFtZXRlcnMsIHNlcmlhbGl6ZSB0aGUgcmVxdWVzdCBkYXRhIGFuZFxuICAgKiBwZXJzaXN0IGl0IHRvIHRoZSBzZXNzaW9uLCBhbmQgcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXV0aGVudGljYXRpb25cbiAgICogcmVxdWVzdCBVUkkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVseWluZ1BhcnR5fSBycCDigJMgaW5zdGFuY2Ugb2YgUmVseWluZ1BhcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uYWwgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uIOKAkyByZWZlcmVuY2UgdG8gbG9jYWxTdG9yYWdlIG9yIG90aGVyIHNlc3Npb24gb2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShycCwgb3B0aW9ucywgc2Vzc2lvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgZGVmYXVsdHMsXG4gICAgICByZWdpc3RyYXRpb25cbiAgICB9ID0gcnA7XG4gICAgbGV0IGlzc3VlciwgZW5kcG9pbnQsIGNsaWVudCwgcGFyYW1zO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIHZhbGlkYXRlIHByZXNlbmNlIG9mIE9QIGNvbmZpZ3VyYXRpb24sIFJQIGNsaWVudCByZWdpc3RyYXRpb24sXG4gICAgICAvLyBhbmQgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgICBhc3NlcnQocHJvdmlkZXIuY29uZmlndXJhdGlvbiwgJ1JlbHlpbmdQYXJ0eSBwcm92aWRlciBPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBtaXNzaW5nJyk7XG4gICAgICBhc3NlcnQoZGVmYXVsdHMuYXV0aGVudGljYXRlLCAnUmVseWluZ1BhcnR5IGRlZmF1bHQgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyBhcmUgbWlzc2luZycpO1xuICAgICAgYXNzZXJ0KHJlZ2lzdHJhdGlvbiwgJ1JlbHlpbmdQYXJ0eSBjbGllbnQgcmVnaXN0cmF0aW9uIGlzIG1pc3NpbmcnKTsgLy8gZGVmaW5lIGJhc2ljIGVsZW1lbnRzIG9mIHRoZSByZXF1ZXN0XG5cbiAgICAgIGlzc3VlciA9IHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24uaXNzdWVyO1xuICAgICAgZW5kcG9pbnQgPSBwcm92aWRlci5jb25maWd1cmF0aW9uLmF1dGhvcml6YXRpb25fZW5kcG9pbnQ7XG4gICAgICBjbGllbnQgPSB7XG4gICAgICAgIGNsaWVudF9pZDogcmVnaXN0cmF0aW9uLmNsaWVudF9pZFxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMuYXV0aGVudGljYXRlLCBjbGllbnQsIG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBwcmVzZW5jZSBvZiByZXF1aXJlZCBjb25maWd1cmF0aW9uIGFuZCBwYXJhbWV0ZXJzXG5cbiAgICAgIGFzc2VydChpc3N1ZXIsICdNaXNzaW5nIGlzc3VlciBpbiBwcm92aWRlciBPcGVuSUQgQ29uZmlndXJhdGlvbicpO1xuICAgICAgYXNzZXJ0KGVuZHBvaW50LCAnTWlzc2luZyBhdXRob3JpemF0aW9uX2VuZHBvaW50IGluIHByb3ZpZGVyIE9wZW5JRCBDb25maWd1cmF0aW9uJyk7XG4gICAgICBhc3NlcnQocGFyYW1zLnNjb3BlLCAnTWlzc2luZyBzY29wZSBwYXJhbWV0ZXIgaW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCcpO1xuICAgICAgYXNzZXJ0KHBhcmFtcy5yZXNwb25zZV90eXBlLCAnTWlzc2luZyByZXNwb25zZV90eXBlIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0Jyk7XG4gICAgICBhc3NlcnQocGFyYW1zLmNsaWVudF9pZCwgJ01pc3NpbmcgY2xpZW50X2lkIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0Jyk7XG4gICAgICBhc3NlcnQocGFyYW1zLnJlZGlyZWN0X3VyaSwgJ01pc3NpbmcgcmVkaXJlY3RfdXJpIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0Jyk7IC8vIGdlbmVyYXRlIHN0YXRlIGFuZCBub25jZSByYW5kb20gb2N0ZXRzXG5cbiAgICAgIHBhcmFtcy5zdGF0ZSA9IEFycmF5LmZyb20oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpKTtcbiAgICAgIHBhcmFtcy5ub25jZSA9IEFycmF5LmZyb20oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpKTsgLy8gaGFzaCB0aGUgc3RhdGUgYW5kIG5vbmNlIHBhcmFtZXRlciB2YWx1ZXNcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtjcnlwdG8uc3VidGxlLmRpZ2VzdCh7XG4gICAgICAgIG5hbWU6ICdTSEEtMjU2J1xuICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkocGFyYW1zLnN0YXRlKSksIGNyeXB0by5zdWJ0bGUuZGlnZXN0KHtcbiAgICAgICAgbmFtZTogJ1NIQS0yNTYnXG4gICAgICB9LCBuZXcgVWludDhBcnJheShwYXJhbXMubm9uY2UpKV0pO1xuICAgIH0pIC8vIHNlcmlhbGl6ZSB0aGUgcmVxdWVzdCB3aXRoIG9yaWdpbmFsIHZhbHVlcywgc3RvcmUgaW4gc2Vzc2lvbiBieVxuICAgIC8vIGVuY29kZWQgc3RhdGUgcGFyYW0sIGFuZCByZXBsYWNlIHN0YXRlL25vbmNlIG9jdGV0cyB3aXRoIGVuY29kZWRcbiAgICAvLyBkaWdlc3RzXG4gICAgLnRoZW4oZGlnZXN0cyA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBiYXNlNjR1cmwoQnVmZmVyLmZyb20oZGlnZXN0c1swXSkpO1xuICAgICAgbGV0IG5vbmNlID0gYmFzZTY0dXJsKEJ1ZmZlci5mcm9tKGRpZ2VzdHNbMV0pKTtcbiAgICAgIGxldCBrZXkgPSBgJHtpc3N1ZXJ9L3JlcXVlc3RIaXN0b3J5LyR7c3RhdGV9YDsgLy8gc3RvcmUgdGhlIHJlcXVlc3QgcGFyYW1zIGZvciByZXNwb25zZSB2YWxpZGF0aW9uXG4gICAgICAvLyB3aXRoIHNlcmlhbGl6ZWQgb2N0ZXQgdmFsdWVzIGZvciBzdGF0ZSBhbmQgbm9uY2VcblxuICAgICAgc2Vzc2lvbltrZXldID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTsgLy8gcmVwbGFjZSBzdGF0ZSBhbmQgbm9uY2Ugb2N0ZXRzIHdpdGggYmFzZTY0dXJsIGVuY29kZWQgZGlnZXN0c1xuXG4gICAgICBwYXJhbXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHBhcmFtcy5ub25jZSA9IG5vbmNlO1xuICAgIH0pLnRoZW4oKCkgPT4gQXV0aGVudGljYXRpb25SZXF1ZXN0LmdlbmVyYXRlU2Vzc2lvbktleXMoKSkudGhlbihzZXNzaW9uS2V5cyA9PiB7XG4gICAgICBBdXRoZW50aWNhdGlvblJlcXVlc3Quc3RvcmVTZXNzaW9uS2V5cyhzZXNzaW9uS2V5cywgcGFyYW1zLCBzZXNzaW9uKTtcbiAgICB9KSAvLyBvcHRpb25hbGx5IGVuY29kZSBhIEpXVCB3aXRoIHRoZSByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAvLyBhbmQgcmVwbGFjZSBwYXJhbXMgd2l0aCBgeyByZXF1ZXN0OiA8and0PiB9XG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ucmVxdWVzdF9wYXJhbWV0ZXJfc3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybiBBdXRoZW50aWNhdGlvblJlcXVlc3QuZW5jb2RlUmVxdWVzdFBhcmFtcyhwYXJhbXMpLnRoZW4oZW5jb2RlZFBhcmFtcyA9PiB7XG4gICAgICAgICAgcGFyYW1zID0gZW5jb2RlZFBhcmFtcztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkgLy8gcmVuZGVyIHRoZSByZXF1ZXN0IFVSSSBhbmQgdGVybWluYXRlIHRoZSBhbGdvcml0aG1cbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChlbmRwb2ludCk7XG4gICAgICB1cmwuc2VhcmNoID0gRm9ybVVybEVuY29kZWQuZW5jb2RlKHBhcmFtcyk7XG4gICAgICByZXR1cm4gdXJsLmhyZWY7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVTZXNzaW9uS2V5cygpIHtcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICBuYW1lOiBcIlJTQVNTQS1QS0NTMS12MV81XCIsXG4gICAgICBtb2R1bHVzTGVuZ3RoOiAyMDQ4LFxuICAgICAgcHVibGljRXhwb25lbnQ6IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAwLCAweDAxXSksXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IFwiU0hBLTI1NlwiXG4gICAgICB9XG4gICAgfSwgdHJ1ZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSkudGhlbihrZXlQYWlyID0+IHtcbiAgICAgIC8vIHJldHVybnMgYSBrZXlwYWlyIG9iamVjdFxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5UGFpci5wdWJsaWNLZXkpLCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5UGFpci5wcml2YXRlS2V5KV0pO1xuICAgIH0pLnRoZW4oandrUGFpciA9PiB7XG4gICAgICBsZXQgW3B1YmxpY0p3aywgcHJpdmF0ZUp3a10gPSBqd2tQYWlyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHVibGljOiBwdWJsaWNKd2ssXG4gICAgICAgIHByaXZhdGU6IHByaXZhdGVKd2tcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgc3RvcmVTZXNzaW9uS2V5cyhzZXNzaW9uS2V5cywgcGFyYW1zLCBzZXNzaW9uKSB7XG4gICAgLy8gc3RvcmUgdGhlIHByaXZhdGUgb25lIGluIHNlc3Npb24sIHB1YmxpYyBvbmUgZ29lcyBpbnRvIHBhcmFtc1xuICAgIHNlc3Npb25bJ29pZGMuc2Vzc2lvbi5wcml2YXRlS2V5J10gPSBKU09OLnN0cmluZ2lmeShzZXNzaW9uS2V5cy5wcml2YXRlKTtcbiAgICBwYXJhbXMua2V5ID0gc2Vzc2lvbktleXMucHVibGljO1xuICB9XG5cbiAgc3RhdGljIGVuY29kZVJlcXVlc3RQYXJhbXMocGFyYW1zKSB7XG4gICAgY29uc3QgZXhjbHVkZVBhcmFtcyA9IFsnc2NvcGUnLCAnY2xpZW50X2lkJywgJ3Jlc3BvbnNlX3R5cGUnLCAnc3RhdGUnXTtcbiAgICBjb25zdCBrZXlzVG9FbmNvZGUgPSBPYmplY3Qua2V5cyhwYXJhbXMpLmZpbHRlcihrZXkgPT4gIWV4Y2x1ZGVQYXJhbXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICBrZXlzVG9FbmNvZGUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgcGF5bG9hZFtrZXldID0gcGFyYW1zW2tleV07XG4gICAgfSk7XG4gICAgbGV0IHJlcXVlc3RQYXJhbUp3dCA9IG5ldyBKV1Qoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIGFsZzogJ25vbmUnXG4gICAgICB9LFxuICAgICAgcGF5bG9hZFxuICAgIH0sIHtcbiAgICAgIGZpbHRlcjogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gcmVxdWVzdFBhcmFtSnd0LmVuY29kZSgpLnRoZW4ocmVxdWVzdFBhcmFtQ29tcGFjdCA9PiB7XG4gICAgICBsZXQgbmV3UGFyYW1zID0ge1xuICAgICAgICBzY29wZTogcGFyYW1zWydzY29wZSddLFxuICAgICAgICBjbGllbnRfaWQ6IHBhcmFtc1snY2xpZW50X2lkJ10sXG4gICAgICAgIHJlc3BvbnNlX3R5cGU6IHBhcmFtc1sncmVzcG9uc2VfdHlwZSddLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0UGFyYW1Db21wYWN0LFxuICAgICAgICBzdGF0ZTogcGFyYW1zWydzdGF0ZSddXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoZW50aWNhdGlvblJlcXVlc3Q7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkuQnVmZmVyKSlcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbi8qKlxuICogRm9ybVVybEVuY29kZWRcbiAqL1xuY2xhc3MgRm9ybVVybEVuY29kZWQge1xuICAvKipcbiAgICogRW5jb2RlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXByZXNlbnQgYW4gb2JqZWN0IGFzIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZW5jb2RlKGRhdGEpIHtcbiAgICBsZXQgcGFpcnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVtrZXldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbiAgfVxuICAvKipcbiAgICogRGVjb2RlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBQYXJzZSBhIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBpbnRvIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG5cblxuICBzdGF0aWMgZGVjb2RlKGRhdGEpIHtcbiAgICBsZXQgb2JqID0ge307XG4gICAgZGF0YS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBsZXQgcGFpciA9IHByb3BlcnR5LnNwbGl0KCc9Jyk7XG4gICAgICBsZXQga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pO1xuICAgICAgbGV0IHZhbCA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgIG9ialtrZXldID0gdmFsO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxufVxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybVVybEVuY29kZWQ7XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCwgQnVmZmVyKSB7LyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuY29uc3Qge1xuICBVUkxcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuY29uc3QgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbmNvbnN0IGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG5jb25zdCBiYXNlNjR1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxuY29uc3QgZmV0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5jb25zdCBIZWFkZXJzID0gZmV0Y2guSGVhZGVycyA/IGZldGNoLkhlYWRlcnMgOiBnbG9iYWwuSGVhZGVycztcblxuY29uc3QgRm9ybVVybEVuY29kZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxuY29uc3QgSURUb2tlbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5jb25zdCBTZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cbmNvbnN0IG9uSHR0cEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbmNvbnN0IEh0dHBFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuLyoqXG4gKiBBdXRoZW50aWNhdGlvblJlc3BvbnNlXG4gKi9cblxuXG5jbGFzcyBBdXRoZW50aWNhdGlvblJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBycCB7UmVseWluZ1BhcnR5fVxuICAgKiBAcGFyYW0gW3JlZGlyZWN0XSB7c3RyaW5nfSByZXEucXVlcnlcbiAgICogQHBhcmFtIFtib2R5XSB7c3RyaW5nfSByZXEuYm9keS50ZXh0XG4gICAqIEBwYXJhbSBzZXNzaW9uIHtTZXNzaW9ufFN0b3JhZ2V9IHJlcS5zZXNzaW9uIG9yIGxvY2FsU3RvcmFnZSBvciBzaW1pbGFyXG4gICAqIEBwYXJhbSBwYXJhbXMge29iamVjdH0gaGFzaG1hcFxuICAgKiBAcGFyYW0gbW9kZSB7c3RyaW5nfSAncXVlcnknLydmcmFnbWVudCcvJ2Zvcm1fcG9zdCcsXG4gICAqICAgZGV0ZXJtaW5lZCBpbiBgcGFyc2VSZXNwb25zZSgpYFxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHJwLFxuICAgIHJlZGlyZWN0LFxuICAgIGJvZHksXG4gICAgc2Vzc2lvbixcbiAgICBtb2RlLFxuICAgIHBhcmFtcyA9IHt9XG4gIH0pIHtcbiAgICB0aGlzLnJwID0gcnA7XG4gICAgdGhpcy5yZWRpcmVjdCA9IHJlZGlyZWN0O1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZVJlc3BvbnNlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBdXRoZW50aWNhdGlvbiByZXNwb25zZSB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHJlc3BvbnNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNlc3Npb24+fVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSkudGhlbih0aGlzLnBhcnNlUmVzcG9uc2UpLnRoZW4odGhpcy5lcnJvclJlc3BvbnNlKS50aGVuKHRoaXMubWF0Y2hSZXF1ZXN0KS50aGVuKHRoaXMudmFsaWRhdGVTdGF0ZVBhcmFtKS50aGVuKHRoaXMudmFsaWRhdGVSZXNwb25zZU1vZGUpLnRoZW4odGhpcy52YWxpZGF0ZVJlc3BvbnNlUGFyYW1zKS50aGVuKHRoaXMuZXhjaGFuZ2VBdXRob3JpemF0aW9uQ29kZSkudGhlbih0aGlzLnZhbGlkYXRlSURUb2tlbikudGhlbihTZXNzaW9uLmZyb21BdXRoUmVzcG9uc2UpO1xuICB9XG4gIC8qKlxuICAgKiBwYXJzZVJlc3BvbnNlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cblxuXG4gIHN0YXRpYyBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgbGV0IHtcbiAgICAgIHJlZGlyZWN0LFxuICAgICAgYm9keVxuICAgIH0gPSByZXNwb25zZTsgLy8gcmVzcG9uc2UgbXVzdCBiZSBlaXRoZXIgYSByZWRpcmVjdCB1cmkgb3IgcmVxdWVzdCBib2R5LCBidXQgbm90IGJvdGhcblxuICAgIGlmIChyZWRpcmVjdCAmJiBib2R5IHx8ICFyZWRpcmVjdCAmJiAhYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcig0MDAsICdJbnZhbGlkIHJlc3BvbnNlIG1vZGUnKTtcbiAgICB9IC8vIHBhcnNlIHJlZGlyZWN0IHVyaVxuXG5cbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlZGlyZWN0KTtcbiAgICAgIGxldCB7XG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgaGFzaFxuICAgICAgfSA9IHVybDtcblxuICAgICAgaWYgKHNlYXJjaCAmJiBoYXNoIHx8ICFzZWFyY2ggJiYgIWhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcig0MDAsICdJbnZhbGlkIHJlc3BvbnNlIG1vZGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICByZXNwb25zZS5wYXJhbXMgPSBGb3JtVXJsRW5jb2RlZC5kZWNvZGUoc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgIHJlc3BvbnNlLm1vZGUgPSAncXVlcnknO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzaCkge1xuICAgICAgICByZXNwb25zZS5wYXJhbXMgPSBGb3JtVXJsRW5jb2RlZC5kZWNvZGUoaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICByZXNwb25zZS5tb2RlID0gJ2ZyYWdtZW50JztcbiAgICAgIH1cbiAgICB9IC8vIHBhcnNlIHJlcXVlc3QgZm9ybSBib2R5XG5cblxuICAgIGlmIChib2R5KSB7XG4gICAgICByZXNwb25zZS5wYXJhbXMgPSBGb3JtVXJsRW5jb2RlZC5kZWNvZGUoYm9keSk7XG4gICAgICByZXNwb25zZS5tb2RlID0gJ2Zvcm1fcG9zdCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBlcnJvclJlc3BvbnNlXG4gICAqXG4gICAqIEBwYXJhbSB7QXV0aGVudGljYXRpb25SZXNwb25zZX0gcmVzcG9uc2VcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHJlc3BvbnNlIHBhcmFtcyBpbmNsdWRlIHRoZSBPQXV0aDIgJ2Vycm9yJyBwYXJhbSxcbiAgICogICB0aHJvd3MgYW4gZXJyb3IgYmFzZWQgb24gaXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBdXRoZW50aWNhdGlvblJlc3BvbnNlfSBDaGFpbmFibGVcbiAgICpcbiAgICogQHRvZG8gRmlndXJlIG91dCBIVFRQIHN0YXR1cyBjb2RlICh0eXBpY2FsbHkgNDAwLCA0MDEgb3IgNDAzKVxuICAgKiAgIGJhc2VkIG9uIHRoZSBPQXV0aDIvT0lEQyBgZXJyb3JgIGNvZGUsIHByb2JhYmx5IHVzaW5nIGFuIGV4dGVybmFsIGxpYnJhcnlcbiAgICovXG5cblxuICBzdGF0aWMgZXJyb3JSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHJlc3BvbnNlLnBhcmFtcy5lcnJvcjtcblxuICAgIGlmIChlcnJvckNvZGUpIHtcbiAgICAgIGNvbnN0IGVycm9yUGFyYW1zID0ge307XG4gICAgICBlcnJvclBhcmFtc1snZXJyb3InXSA9IGVycm9yQ29kZTtcbiAgICAgIGVycm9yUGFyYW1zWydlcnJvcl9kZXNjcmlwdGlvbiddID0gcmVzcG9uc2UucGFyYW1zWydlcnJvcl9kZXNjcmlwdGlvbiddO1xuICAgICAgZXJyb3JQYXJhbXNbJ2Vycm9yX3VyaSddID0gcmVzcG9uc2UucGFyYW1zWydlcnJvcl91cmknXTtcbiAgICAgIGVycm9yUGFyYW1zWydzdGF0ZSddID0gcmVzcG9uc2UucGFyYW1zWydzdGF0ZSddO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JDb2RlfWApO1xuICAgICAgZXJyb3IuaW5mbyA9IGVycm9yUGFyYW1zO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBtYXRjaFJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyBtYXRjaFJlcXVlc3QocmVzcG9uc2UpIHtcbiAgICBsZXQge1xuICAgICAgcnAsXG4gICAgICBwYXJhbXMsXG4gICAgICBzZXNzaW9uXG4gICAgfSA9IHJlc3BvbnNlO1xuICAgIGxldCBzdGF0ZSA9IHBhcmFtcy5zdGF0ZTtcbiAgICBsZXQgaXNzdWVyID0gcnAucHJvdmlkZXIuY29uZmlndXJhdGlvbi5pc3N1ZXI7XG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc3RhdGUgcGFyYW1ldGVyIGluIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlJyk7XG4gICAgfVxuXG4gICAgbGV0IGtleSA9IGAke2lzc3Vlcn0vcmVxdWVzdEhpc3RvcnkvJHtzdGF0ZX1gO1xuICAgIGxldCByZXF1ZXN0ID0gc2Vzc2lvbltrZXldO1xuXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc21hdGNoaW5nIHN0YXRlIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXNwb25zZScpO1xuICAgIH1cblxuICAgIHJlc3BvbnNlLnJlcXVlc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVTdGF0ZVBhcmFtXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVTdGF0ZVBhcmFtKHJlc3BvbnNlKSB7XG4gICAgbGV0IG9jdGV0cyA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLnJlcXVlc3Quc3RhdGUpO1xuICAgIGxldCBlbmNvZGVkID0gcmVzcG9uc2UucGFyYW1zLnN0YXRlO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRpZ2VzdCh7XG4gICAgICBuYW1lOiAnU0hBLTI1NidcbiAgICB9LCBvY3RldHMpLnRoZW4oZGlnZXN0ID0+IHtcbiAgICAgIGlmIChlbmNvZGVkICE9PSBiYXNlNjR1cmwoQnVmZmVyLmZyb20oZGlnZXN0KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBzdGF0ZSBwYXJhbWV0ZXIgaW4gYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZVJlc3BvbnNlTW9kZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlUmVzcG9uc2VNb2RlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnJlcXVlc3QucmVzcG9uc2VfdHlwZSAhPT0gJ2NvZGUnICYmIHJlc3BvbnNlLm1vZGUgPT09ICdxdWVyeScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBtb2RlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZVJlc3BvbnNlUGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVSZXNwb25zZVBhcmFtcyhyZXNwb25zZSkge1xuICAgIGxldCB7XG4gICAgICByZXF1ZXN0LFxuICAgICAgcGFyYW1zXG4gICAgfSA9IHJlc3BvbnNlO1xuICAgIGxldCBleHBlY3RlZFBhcmFtcyA9IHJlcXVlc3QucmVzcG9uc2VfdHlwZS5zcGxpdCgnICcpO1xuXG4gICAgaWYgKGV4cGVjdGVkUGFyYW1zLmluY2x1ZGVzKCdjb2RlJykpIHtcbiAgICAgIGFzc2VydChwYXJhbXMuY29kZSwgJ01pc3NpbmcgYXV0aG9yaXphdGlvbiBjb2RlIGluIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlJyk7IC8vIFRPRE8gYXNzZXJ0IG5vdmVsdHkgb2YgY29kZVxuICAgIH1cblxuICAgIGlmIChleHBlY3RlZFBhcmFtcy5pbmNsdWRlcygnaWRfdG9rZW4nKSkge1xuICAgICAgYXNzZXJ0KHBhcmFtcy5pZF90b2tlbiwgJ01pc3NpbmcgaWRfdG9rZW4gaW4gYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0ZWRQYXJhbXMuaW5jbHVkZXMoJ3Rva2VuJykpIHtcbiAgICAgIGFzc2VydChwYXJhbXMuYWNjZXNzX3Rva2VuLCAnTWlzc2luZyBhY2Nlc3NfdG9rZW4gaW4gYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKTtcbiAgICAgIGFzc2VydChwYXJhbXMudG9rZW5fdHlwZSwgJ01pc3NpbmcgdG9rZW5fdHlwZSBpbiBhdXRoZW50aWNhdGlvbiByZXNwb25zZScpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogZXhjaGFuZ2VBdXRob3JpemF0aW9uQ29kZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3BvbnNlIG9iamVjdFxuICAgKi9cblxuXG4gIHN0YXRpYyBleGNoYW5nZUF1dGhvcml6YXRpb25Db2RlKHJlc3BvbnNlKSB7XG4gICAgbGV0IHtcbiAgICAgIHJwLFxuICAgICAgcGFyYW1zLFxuICAgICAgcmVxdWVzdFxuICAgIH0gPSByZXNwb25zZTtcbiAgICBsZXQgY29kZSA9IHBhcmFtcy5jb2RlOyAvLyBvbmx5IGV4Y2hhbmdlIHRoZSBhdXRob3JpemF0aW9uIGNvZGUgd2hlbiB0aGUgcmVzcG9uc2UgdHlwZSBpcyBcImNvZGVcIlxuXG4gICAgaWYgKCFjb2RlIHx8IHJlcXVlc3RbJ3Jlc3BvbnNlX3R5cGUnXSAhPT0gJ2NvZGUnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBsZXQge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICByZWdpc3RyYXRpb25cbiAgICB9ID0gcnA7XG4gICAgbGV0IGlkID0gcmVnaXN0cmF0aW9uWydjbGllbnRfaWQnXTtcbiAgICBsZXQgc2VjcmV0ID0gcmVnaXN0cmF0aW9uWydjbGllbnRfc2VjcmV0J107IC8vIHZlcmlmeSB0aGUgY2xpZW50IGlzIG5vdCBwdWJsaWNcblxuICAgIGlmICghc2VjcmV0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDbGllbnQgY2Fubm90IGV4Y2hhbmdlIGF1dGhvcml6YXRpb24gY29kZSBiZWNhdXNlICcgKyAnaXQgaXMgbm90IGEgY29uZmlkZW50aWFsIGNsaWVudCcpKTtcbiAgICB9IC8vIGluaXRpYWxpemUgdG9rZW4gcmVxdWVzdCBhcmd1bWVudHNcblxuXG4gICAgbGV0IGVuZHBvaW50ID0gcHJvdmlkZXIuY29uZmlndXJhdGlvbi50b2tlbl9lbmRwb2ludDtcbiAgICBsZXQgbWV0aG9kID0gJ1BPU1QnOyAvLyBpbml0aWFsaXplIGhlYWRlcnNcblxuICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgfSk7IC8vIGluaXRpYWxpemUgdGhlIHRva2VuIHJlcXVlc3QgcGFyYW1ldGVyc1xuXG4gICAgbGV0IGJvZHlDb250ZW50cyA9IHtcbiAgICAgICdncmFudF90eXBlJzogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAnY29kZSc6IGNvZGUsXG4gICAgICAncmVkaXJlY3RfdXJpJzogcmVxdWVzdFsncmVkaXJlY3RfdXJpJ10gLy8gZGV0ZXJtaW5lIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2RcblxuICAgIH07XG4gICAgbGV0IGF1dGhNZXRob2QgPSByZWdpc3RyYXRpb25bJ3Rva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kJ10gfHwgJ2NsaWVudF9zZWNyZXRfYmFzaWMnOyAvLyBjbGllbnQgc2VjcmV0IGJhc2ljIGF1dGhlbnRpY2F0aW9uXG5cbiAgICBpZiAoYXV0aE1ldGhvZCA9PT0gJ2NsaWVudF9zZWNyZXRfYmFzaWMnKSB7XG4gICAgICBsZXQgY3JlZGVudGlhbHMgPSBuZXcgQnVmZmVyKGAke2lkfToke3NlY3JldH1gKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2NyZWRlbnRpYWxzfWApO1xuICAgIH0gLy8gY2xpZW50IHNlY3JldCBwb3N0IGF1dGhlbnRpY2F0aW9uXG5cblxuICAgIGlmIChhdXRoTWV0aG9kID09PSAnY2xpZW50X3NlY3JldF9wb3N0Jykge1xuICAgICAgYm9keUNvbnRlbnRzWydjbGllbnRfaWQnXSA9IGlkO1xuICAgICAgYm9keUNvbnRlbnRzWydjbGllbnRfc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgfVxuXG4gICAgbGV0IGJvZHkgPSBGb3JtVXJsRW5jb2RlZC5lbmNvZGUoYm9keUNvbnRlbnRzKTsgLy8gVE9ET1xuICAgIC8vIGNsaWVudF9zZWNyZXRfand0IGF1dGhlbnRpY2F0aW9uXG4gICAgLy8gcHJpdmF0ZV9rZXlfand0XG4gICAgLy8gbWFrZSB0aGUgdG9rZW4gcmVxdWVzdFxuXG4gICAgcmV0dXJuIGZldGNoKGVuZHBvaW50LCB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH0pLnRoZW4ob25IdHRwRXJyb3IoJ0Vycm9yIGV4Y2hhbmdpbmcgYXV0aG9yaXphdGlvbiBjb2RlJykpLnRoZW4odG9rZW5SZXNwb25zZSA9PiB0b2tlblJlc3BvbnNlLmpzb24oKSkudGhlbih0b2tlblJlc3BvbnNlID0+IHtcbiAgICAgIGFzc2VydCh0b2tlblJlc3BvbnNlWydhY2Nlc3NfdG9rZW4nXSwgJ01pc3NpbmcgYWNjZXNzX3Rva2VuIGluIHRva2VuIHJlc3BvbnNlJyk7XG4gICAgICBhc3NlcnQodG9rZW5SZXNwb25zZVsndG9rZW5fdHlwZSddLCAnTWlzc2luZyB0b2tlbl90eXBlIGluIHRva2VuIHJlc3BvbnNlJyk7XG4gICAgICBhc3NlcnQodG9rZW5SZXNwb25zZVsnaWRfdG9rZW4nXSwgJ01pc3NpbmcgaWRfdG9rZW4gaW4gdG9rZW4gcmVzcG9uc2UnKTsgLy8gYW55dGhpbmcgZWxzZT9cbiAgICAgIC8vIElTIFRISVMgVEhFIFJJR0hUIFRISU5HIFRPIERPIEhFUkU/XG5cbiAgICAgIHJlc3BvbnNlLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24ocmVzcG9uc2UucGFyYW1zLCB0b2tlblJlc3BvbnNlKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVJRFRva2VuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVJRFRva2VuKHJlc3BvbnNlKSB7XG4gICAgLy8gb25seSB2YWxpZGF0ZSB0aGUgSUQgVG9rZW4gaWYgcHJlc2VudCBpbiB0aGUgcmVzcG9uc2VcbiAgICBpZiAoIXJlc3BvbnNlLnBhcmFtcy5pZF90b2tlbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSkudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLmRlY3J5cHRJRFRva2VuKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UuZGVjb2RlSURUb2tlbikudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlSXNzdWVyKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmFsaWRhdGVBdWRpZW5jZSkudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnJlc29sdmVLZXlzKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmVyaWZ5U2lnbmF0dXJlKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmFsaWRhdGVFeHBpcmVzKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmVyaWZ5Tm9uY2UpLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS52YWxpZGF0ZUFjcikudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlQXV0aFRpbWUpLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS52YWxpZGF0ZUFjY2Vzc1Rva2VuSGFzaCkudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlQXV0aG9yaXphdGlvbkNvZGVIYXNoKTtcbiAgfVxuICAvKipcbiAgICogZGVjcnlwdElEVG9rZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyBkZWNyeXB0SURUb2tlbihyZXNwb25zZSkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogZGVjb2RlSURUb2tlblxuICAgKlxuICAgKiBOb3RlOiBJZiB0aGUgYGlkX3Rva2VuYCBpcyBub3QgcHJlc2VudCBpbiBwYXJhbXMsIHRoaXMgbWV0aG9kIGRvZXMgbm90XG4gICAqIGdldCBjYWxsZWQgKHNob3J0LWNpcmN1aXRlZCBpbiBgdmFsaWRhdGVJRFRva2VuKClgKS5cbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlIHtBdXRoZW50aWNhdGlvblJlc3BvbnNlfVxuICAgKiBAcGFyYW0gcmVzcG9uc2UucGFyYW1zIHtvYmplY3R9XG4gICAqIEBwYXJhbSBbcmVzcG9uc2UucGFyYW1zLmlkX3Rva2VuXSB7c3RyaW5nfSBJRFRva2VuIGVuY29kZWQgYXMgYSBKV1RcbiAgICpcbiAgICogQHJldHVybnMge0F1dGhlbnRpY2F0aW9uUmVzcG9uc2V9IENoYWluYWJsZVxuICAgKi9cblxuXG4gIHN0YXRpYyBkZWNvZGVJRFRva2VuKHJlc3BvbnNlKSB7XG4gICAgbGV0IGp3dCA9IHJlc3BvbnNlLnBhcmFtcy5pZF90b2tlbjtcblxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZS5kZWNvZGVkID0gSURUb2tlbi5kZWNvZGUoand0KTtcbiAgICB9IGNhdGNoIChkZWNvZGVFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSHR0cEVycm9yKDQwMCwgJ0Vycm9yIGRlY29kaW5nIElEIFRva2VuJyk7XG4gICAgICBlcnJvci5jYXVzZSA9IGRlY29kZUVycm9yO1xuICAgICAgZXJyb3IuaW5mbyA9IHtcbiAgICAgICAgaWRfdG9rZW46IGp3dFxuICAgICAgfTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVJc3N1ZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUlzc3VlcihyZXNwb25zZSkge1xuICAgIGxldCBjb25maWd1cmF0aW9uID0gcmVzcG9uc2UucnAucHJvdmlkZXIuY29uZmlndXJhdGlvbjtcbiAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRlY29kZWQucGF5bG9hZDsgLy8gdmFsaWRhdGUgaXNzdWVyIG9mIHRva2VuIG1hdGNoZXMgdGhpcyByZWx5aW5nIHBhcnR5J3MgcHJvdmlkZXJcblxuICAgIGlmIChwYXlsb2FkLmlzcyAhPT0gY29uZmlndXJhdGlvbi5pc3N1ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgaXNzdWVyIGluIElEIFRva2VuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZUF1ZGllbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVBdWRpZW5jZShyZXNwb25zZSkge1xuICAgIGxldCByZWdpc3RyYXRpb24gPSByZXNwb25zZS5ycC5yZWdpc3RyYXRpb247XG4gICAgbGV0IHtcbiAgICAgIGF1ZCxcbiAgICAgIGF6cFxuICAgIH0gPSByZXNwb25zZS5kZWNvZGVkLnBheWxvYWQ7IC8vIHZhbGlkYXRlIGF1ZGllbmNlIGluY2x1ZGVzIHRoaXMgcmVseWluZyBwYXJ0eVxuXG4gICAgaWYgKHR5cGVvZiBhdWQgPT09ICdzdHJpbmcnICYmIGF1ZCAhPT0gcmVnaXN0cmF0aW9uWydjbGllbnRfaWQnXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBhdWRpZW5jZSBpbiBpZF90b2tlbicpO1xuICAgIH0gLy8gdmFsaWRhdGUgYXVkaWVuY2UgaW5jbHVkZXMgdGhpcyByZWx5aW5nIHBhcnR5XG5cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGF1ZCkgJiYgIWF1ZC5pbmNsdWRlcyhyZWdpc3RyYXRpb25bJ2NsaWVudF9pZCddKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBhdWRpZW5jZSBpbiBpZF90b2tlbicpO1xuICAgIH0gLy8gdmFsaWRhdGUgYXV0aG9yaXplZCBwYXJ0eSBpcyBwcmVzZW50IGlmIHJlcXVpcmVkXG5cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGF1ZCkgJiYgIWF6cCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGF6cCBjbGFpbSBpbiBpZF90b2tlbicpO1xuICAgIH0gLy8gdmFsaWRhdGUgYXV0aG9yaXplZCBwYXJ0eSBpcyB0aGlzIHJlbHlpbmcgcGFydHlcblxuXG4gICAgaWYgKGF6cCAmJiBhenAgIT09IHJlZ2lzdHJhdGlvblsnY2xpZW50X2lkJ10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgYXpwIGNsYWltIGluIGlkX3Rva2VuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiByZXNvbHZlS2V5c1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHJlc29sdmVLZXlzKHJlc3BvbnNlKSB7XG4gICAgbGV0IHJwID0gcmVzcG9uc2UucnA7XG4gICAgbGV0IHByb3ZpZGVyID0gcnAucHJvdmlkZXI7XG4gICAgbGV0IGRlY29kZWQgPSByZXNwb25zZS5kZWNvZGVkO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvdmlkZXIuandrcykudGhlbihqd2tzID0+IGp3a3MgPyBqd2tzIDogcnAuandrcygpKS50aGVuKGp3a3MgPT4ge1xuICAgICAgaWYgKGRlY29kZWQucmVzb2x2ZUtleXMoandrcykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIHNpZ25pbmcga2V5IGZvciBJRCBUb2tlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiB2ZXJpZnlTaWduYXR1cmVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2ZXJpZnlTaWduYXR1cmUocmVzcG9uc2UpIHtcbiAgICBsZXQgYWxnID0gcmVzcG9uc2UuZGVjb2RlZC5oZWFkZXIuYWxnO1xuICAgIGxldCByZWdpc3RyYXRpb24gPSByZXNwb25zZS5ycC5yZWdpc3RyYXRpb247XG4gICAgbGV0IGV4cGVjdGVkQWxnb3JpdGhtID0gcmVnaXN0cmF0aW9uWydpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnJ10gfHwgJ1JTMjU2JzsgLy8gdmFsaWRhdGUgc2lnbmluZyBhbGdvcml0aG0gbWF0Y2hlcyBleHBlY3RhdGlvblxuXG4gICAgaWYgKGFsZyAhPT0gZXhwZWN0ZWRBbGdvcml0aG0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgSUQgVG9rZW4gdG8gYmUgc2lnbmVkIHdpdGggJHtleHBlY3RlZEFsZ29yaXRobX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGVjb2RlZC52ZXJpZnkoKS50aGVuKHZlcmlmaWVkID0+IHtcbiAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElEIFRva2VuIHNpZ25hdHVyZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlRXhwaXJlc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlRXhwaXJlcyhyZXNwb25zZSkge1xuICAgIGxldCBleHAgPSByZXNwb25zZS5kZWNvZGVkLnBheWxvYWQuZXhwOyAvLyB2YWxpZGF0ZSBleHBpcmF0aW9uIG9mIHRva2VuXG5cbiAgICBpZiAoZXhwIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGlyZWQgSUQgVG9rZW4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZlcmlmeU5vbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmVyaWZ5Tm9uY2UocmVzcG9uc2UpIHtcbiAgICBsZXQgb2N0ZXRzID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UucmVxdWVzdC5ub25jZSk7XG4gICAgbGV0IG5vbmNlID0gcmVzcG9uc2UuZGVjb2RlZC5wYXlsb2FkLm5vbmNlO1xuXG4gICAgaWYgKCFub25jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIG5vbmNlIGluIElEIFRva2VuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGlnZXN0KHtcbiAgICAgIG5hbWU6ICdTSEEtMjU2J1xuICAgIH0sIG9jdGV0cykudGhlbihkaWdlc3QgPT4ge1xuICAgICAgaWYgKG5vbmNlICE9PSBiYXNlNjR1cmwoQnVmZmVyLmZyb20oZGlnZXN0KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBub25jZSBpbiBJRCBUb2tlbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlQWNyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUFjcihyZXNwb25zZSkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlQXV0aFRpbWVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUF1dGhUaW1lKHJlc3BvbnNlKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVBY2Nlc3NUb2tlbkhhc2hcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUFjY2Vzc1Rva2VuSGFzaChyZXNwb25zZSkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlQXV0aG9yaXphdGlvbkNvZGVIYXNoXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVBdXRob3JpemF0aW9uQ29kZUhhc2gocmVzcG9uc2UpIHtcbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbn1cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhlbnRpY2F0aW9uUmVzcG9uc2U7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCksIF9fd2VicGFja19yZXF1aXJlX18oNDEpLkJ1ZmZlcikpXG5cbi8qKiovIH0pLFxuLyogNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuY29uc3Qge1xuICBKV1Rcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuY29uc3QgSURUb2tlblNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuLyoqXG4gKiBJRFRva2VuXG4gKi9cblxuXG5jbGFzcyBJRFRva2VuIGV4dGVuZHMgSldUIHtcbiAgLyoqXG4gICAqIFNjaGVtYVxuICAgKi9cbiAgc3RhdGljIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIElEVG9rZW5TY2hlbWE7XG4gIH1cblxufVxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSURUb2tlbjtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5jb25zdCB7XG4gIEpXVFNjaGVtYVxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuLyoqXG4gKiBJRFRva2VuIFNjaGVtYVxuICovXG5cblxuY29uc3QgSURUb2tlblNjaGVtYSA9IEpXVFNjaGVtYS5leHRlbmQoe1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogaGVhZGVyXG4gICAgICogaHR0cDovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNJRFRva2VuXG4gICAgICogSUQgVG9rZW5zIFNIT1VMRCBOT1QgdXNlIHRoZSBKV1Mgb3IgSldFIHg1dSwgeDVjLCBqa3UsIG9yIGp3ayBIZWFkZXJcbiAgICAgKiBQYXJhbWV0ZXIgZmllbGRzLiBJbnN0ZWFkLCByZWZlcmVuY2VzIHRvIGtleXMgdXNlZCBhcmUgY29tbXVuaWNhdGVkIGluXG4gICAgICogYWR2YW5jZSB1c2luZyBEaXNjb3ZlcnkgYW5kIFJlZ2lzdHJhdGlvbiBwYXJhbWV0ZXJzLCBwZXIgU2VjdGlvbiAxMC5cbiAgICAgKi9cbiAgICBoZWFkZXI6IHsvL25vdDogeyByZXF1aXJlZDogWyd4NXUnLCAneDVjJywgJ2prdScsICdqd2snXSB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBheWxvYWRcbiAgICAgKi9cbiAgICBwYXlsb2FkOiB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpc3NcbiAgICAgICAgICpcbiAgICAgICAgICogUkVRVUlSRUQuIElzc3VlciBJZGVudGlmaWVyIGZvciB0aGUgSXNzdWVyIG9mIHRoZSByZXNwb25zZS5cbiAgICAgICAgICogVGhlIGlzcyB2YWx1ZSBpcyBhIGNhc2Ugc2Vuc2l0aXZlIFVSTCB1c2luZyB0aGUgaHR0cHMgc2NoZW1lXG4gICAgICAgICAqIHRoYXQgY29udGFpbnMgc2NoZW1lLCBob3N0LCBhbmQgb3B0aW9uYWxseSwgcG9ydCBudW1iZXIgYW5kXG4gICAgICAgICAqIHBhdGggY29tcG9uZW50cyBhbmQgbm8gcXVlcnkgb3IgZnJhZ21lbnQgY29tcG9uZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIGlzczoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGZvcm1hdDogJ3VybCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3ViXG4gICAgICAgICAqXG4gICAgICAgICAqIFJFUVVJUkVELiBTdWJqZWN0IElkZW50aWZpZXIuIEEgbG9jYWxseSB1bmlxdWUgYW5kIG5ldmVyXG4gICAgICAgICAqIHJlYXNzaWduZWQgaWRlbnRpZmllciB3aXRoaW4gdGhlIElzc3VlciBmb3IgdGhlIEVuZC1Vc2VyLCB3aGljaFxuICAgICAgICAgKiBpcyBpbnRlbmRlZCB0byBiZSBjb25zdW1lZCBieSB0aGUgQ2xpZW50LCBlLmcuLCAyNDQwMDMyMCBvclxuICAgICAgICAgKiBBSXRPYXdtd3RXd2NUMGs1MUJheWV3TnZ1dHJKVXFzdmw2cXM3QTQuIEl0IE1VU1QgTk9UIGV4Y2VlZCAyNTVcbiAgICAgICAgICogQVNDSUkgY2hhcmFjdGVycyBpbiBsZW5ndGguIFRoZSBzdWIgdmFsdWUgaXMgYSBjYXNlIHNlbnNpdGl2ZVxuICAgICAgICAgKiBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzdWI6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBtYXhMZW5ndGg6IDI1NVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhdWRcbiAgICAgICAgICpcbiAgICAgICAgICogUkVRVUlSRUQuIEF1ZGllbmNlKHMpIHRoYXQgdGhpcyBJRCBUb2tlbiBpcyBpbnRlbmRlZCBmb3IuIEl0XG4gICAgICAgICAqIE1VU1QgY29udGFpbiB0aGUgT0F1dGggMi4wIGNsaWVudF9pZCBvZiB0aGUgUmVseWluZyBQYXJ0eSBhcyBhblxuICAgICAgICAgKiBhdWRpZW5jZSB2YWx1ZS4gSXQgTUFZIGFsc28gY29udGFpbiBpZGVudGlmaWVycyBmb3Igb3RoZXIgYXVkaWVuY2VzLlxuICAgICAgICAgKiBJbiB0aGUgZ2VuZXJhbCBjYXNlLCB0aGUgYXVkIHZhbHVlIGlzIGFuIGFycmF5IG9mIGNhc2Ugc2Vuc2l0aXZlXG4gICAgICAgICAqIHN0cmluZ3MuIEluIHRoZSBjb21tb24gc3BlY2lhbCBjYXNlIHdoZW4gdGhlcmUgaXMgb25lIGF1ZGllbmNlLFxuICAgICAgICAgKiB0aGUgYXVkIHZhbHVlIE1BWSBiZSBhIHNpbmdsZSBjYXNlIHNlbnNpdGl2ZSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBpbmhlcml0ZWQgZnJvbSBKV1RDbGFpbXNTZXRTY2hlbWFcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwXG4gICAgICAgICAqXG4gICAgICAgICAqIFJFUVVJUkVELiBFeHBpcmF0aW9uIHRpbWUgb24gb3IgYWZ0ZXIgd2hpY2ggdGhlIElEIFRva2VuIE1VU1QgTk9UXG4gICAgICAgICAqIGJlIGFjY2VwdGVkIGZvciBwcm9jZXNzaW5nLiBUaGUgcHJvY2Vzc2luZyBvZiB0aGlzIHBhcmFtZXRlclxuICAgICAgICAgKiByZXF1aXJlcyB0aGF0IHRoZSBjdXJyZW50IGRhdGUvdGltZSBNVVNUIGJlIGJlZm9yZSB0aGUgZXhwaXJhdGlvblxuICAgICAgICAgKiBkYXRlL3RpbWUgbGlzdGVkIGluIHRoZSB2YWx1ZS4gSW1wbGVtZW50ZXJzIE1BWSBwcm92aWRlIGZvciBzb21lXG4gICAgICAgICAqIHNtYWxsIGxlZXdheSwgdXN1YWxseSBubyBtb3JlIHRoYW4gYSBmZXcgbWludXRlcywgdG8gYWNjb3VudCBmb3JcbiAgICAgICAgICogY2xvY2sgc2tldy4gSXRzIHZhbHVlIGlzIGEgSlNPTiBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICogc2Vjb25kcyBmcm9tIDE5NzAtMDEtMDFUMDowOjBaIGFzIG1lYXN1cmVkIGluIFVUQyB1bnRpbCB0aGVcbiAgICAgICAgICogZGF0ZS90aW1lLiBTZWUgUkZDIDMzMzkgW1JGQzMzMzldIGZvciBkZXRhaWxzIHJlZ2FyZGluZyBkYXRlL3RpbWVzXG4gICAgICAgICAqIGluIGdlbmVyYWwgYW5kIFVUQyBpbiBwYXJ0aWN1bGFyLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gaW5oZXJpdGVkIGZyb20gSldUQ2xhaW1zU2V0U2NoZW1hXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlhdFxuICAgICAgICAgKlxuICAgICAgICAgKiBSRVFVSVJFRC4gVGltZSBhdCB3aGljaCB0aGUgSldUIHdhcyBpc3N1ZWQuIEl0cyB2YWx1ZSBpcyBhXG4gICAgICAgICAqIEpTT04gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgZnJvbVxuICAgICAgICAgKiAxOTcwLTAxLTAxVDA6MDowWiBhcyBtZWFzdXJlZCBpbiBVVEMgdW50aWwgdGhlIGRhdGUvdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGluaGVyaXRlZCBmcm9tIEpXVENsYWltc1NldFNjaGVtYVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhdXRoX3RpbWVcbiAgICAgICAgICpcbiAgICAgICAgICogVGltZSB3aGVuIHRoZSBFbmQtVXNlciBhdXRoZW50aWNhdGlvbiBvY2N1cnJlZC4gSXRzIHZhbHVlIGlzIGFcbiAgICAgICAgICogSlNPTiBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBmcm9tXG4gICAgICAgICAqIDE5NzAtMDEtMDFUMDowOjBaIGFzIG1lYXN1cmVkIGluIFVUQyB1bnRpbCB0aGUgZGF0ZS90aW1lLiBXaGVuIGFcbiAgICAgICAgICogbWF4X2FnZSByZXF1ZXN0IGlzIG1hZGUgb3Igd2hlbiBhdXRoX3RpbWUgaXMgcmVxdWVzdGVkIGFzIGFuXG4gICAgICAgICAqIEVzc2VudGlhbCBDbGFpbSwgdGhlbiB0aGlzIENsYWltIGlzIFJFUVVJUkVEOyBvdGhlcndpc2UsIGl0c1xuICAgICAgICAgKiBpbmNsdXNpb24gaXMgT1BUSU9OQUwuIChUaGUgYXV0aF90aW1lIENsYWltIHNlbWFudGljYWxseVxuICAgICAgICAgKiBjb3JyZXNwb25kcyB0byB0aGUgT3BlbklEIDIuMCBQQVBFIFtPcGVuSUQuUEFQRV0gYXV0aF90aW1lXG4gICAgICAgICAqIHJlc3BvbnNlIHBhcmFtZXRlci4pXG4gICAgICAgICAqL1xuICAgICAgICBhdXRoX3RpbWU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZm9ybWF0OiAnTnVtZXJpY0RhdGUnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5vbmNlXG4gICAgICAgICAqXG4gICAgICAgICAqIFN0cmluZyB2YWx1ZSB1c2VkIHRvIGFzc29jaWF0ZSBhIENsaWVudCBzZXNzaW9uIHdpdGggYW4gSUQgVG9rZW4sXG4gICAgICAgICAqIGFuZCB0byBtaXRpZ2F0ZSByZXBsYXkgYXR0YWNrcy4gVGhlIHZhbHVlIGlzIHBhc3NlZCB0aHJvdWdoXG4gICAgICAgICAqIHVubW9kaWZpZWQgZnJvbSB0aGUgQXV0aGVudGljYXRpb24gUmVxdWVzdCB0byB0aGUgSUQgVG9rZW4uIElmXG4gICAgICAgICAqIHByZXNlbnQgaW4gdGhlIElEIFRva2VuLCBDbGllbnRzIE1VU1QgdmVyaWZ5IHRoYXQgdGhlIG5vbmNlIENsYWltXG4gICAgICAgICAqIFZhbHVlIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiB0aGUgbm9uY2UgcGFyYW1ldGVyIHNlbnQgaW4gdGhlXG4gICAgICAgICAqIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QuIElmIHByZXNlbnQgaW4gdGhlIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QsXG4gICAgICAgICAqIEF1dGhvcml6YXRpb24gU2VydmVycyBNVVNUIGluY2x1ZGUgYSBub25jZSBDbGFpbSBpbiB0aGUgSUQgVG9rZW5cbiAgICAgICAgICogd2l0aCB0aGUgQ2xhaW0gVmFsdWUgYmVpbmcgdGhlIG5vbmNlIHZhbHVlIHNlbnQgaW4gdGhlXG4gICAgICAgICAqIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QuIEF1dGhvcml6YXRpb24gU2VydmVycyBTSE9VTEQgcGVyZm9ybSBub1xuICAgICAgICAgKiBvdGhlciBwcm9jZXNzaW5nIG9uIG5vbmNlIHZhbHVlcyB1c2VkLiBUaGUgbm9uY2UgdmFsdWUgaXMgYSBjYXNlXG4gICAgICAgICAqIHNlbnNpdGl2ZSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBub25jZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFjclxuICAgICAgICAgKlxuICAgICAgICAgKiBPUFRJT05BTC4gQXV0aGVudGljYXRpb24gQ29udGV4dCBDbGFzcyBSZWZlcmVuY2UuIFN0cmluZ1xuICAgICAgICAgKiBzcGVjaWZ5aW5nIGFuIEF1dGhlbnRpY2F0aW9uIENvbnRleHQgQ2xhc3MgUmVmZXJlbmNlIHZhbHVlIHRoYXRcbiAgICAgICAgICogaWRlbnRpZmllcyB0aGUgQXV0aGVudGljYXRpb24gQ29udGV4dCBDbGFzcyB0aGF0IHRoZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgKiBwZXJmb3JtZWQgc2F0aXNmaWVkLiBUaGUgdmFsdWUgXCIwXCIgaW5kaWNhdGVzIHRoZSBFbmQtVXNlclxuICAgICAgICAgKiBhdXRoZW50aWNhdGlvbiBkaWQgbm90IG1lZXQgdGhlIHJlcXVpcmVtZW50cyBvZiBJU08vSUVDIDI5MTE1XG4gICAgICAgICAqIFtJU08yOTExNV0gbGV2ZWwgMS4gQXV0aGVudGljYXRpb24gdXNpbmcgYSBsb25nLWxpdmVkIGJyb3dzZXJcbiAgICAgICAgICogY29va2llLCBmb3IgaW5zdGFuY2UsIGlzIG9uZSBleGFtcGxlIHdoZXJlIHRoZSB1c2Ugb2YgXCJsZXZlbCAwXCIgaXNcbiAgICAgICAgICogYXBwcm9wcmlhdGUuIEF1dGhlbnRpY2F0aW9ucyB3aXRoIGxldmVsIDAgU0hPVUxEIE5PVCBiZSB1c2VkIHRvXG4gICAgICAgICAqIGF1dGhvcml6ZSBhY2Nlc3MgdG8gYW55IHJlc291cmNlIG9mIGFueSBtb25ldGFyeSB2YWx1ZS4gKFRoaXNcbiAgICAgICAgICogY29ycmVzcG9uZHMgdG8gdGhlIE9wZW5JRCAyLjAgUEFQRSBbT3BlbklELlBBUEVdIG5pc3RfYXV0aF9sZXZlbFxuICAgICAgICAgKiAwLikgQW4gYWJzb2x1dGUgVVJJIG9yIGFuIFJGQyA2NzExIFtSRkM2NzExXSByZWdpc3RlcmVkIG5hbWVcbiAgICAgICAgICogU0hPVUxEIGJlIHVzZWQgYXMgdGhlIGFjciB2YWx1ZTsgcmVnaXN0ZXJlZCBuYW1lcyBNVVNUIE5PVCBiZSB1c2VkXG4gICAgICAgICAqIHdpdGggYSBkaWZmZXJlbnQgbWVhbmluZyB0aGFuIHRoYXQgd2hpY2ggaXMgcmVnaXN0ZXJlZC4gUGFydGllc1xuICAgICAgICAgKiB1c2luZyB0aGlzIGNsYWltIHdpbGwgbmVlZCB0byBhZ3JlZSB1cG9uIHRoZSBtZWFuaW5ncyBvZiB0aGVcbiAgICAgICAgICogdmFsdWVzIHVzZWQsIHdoaWNoIG1heSBiZSBjb250ZXh0LXNwZWNpZmljLiBUaGUgYWNyIHZhbHVlIGlzIGFcbiAgICAgICAgICogY2FzZSBzZW5zaXRpdmUgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYWNyOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYW1yXG4gICAgICAgICAqIE9QVElPTkFMLiBBdXRoZW50aWNhdGlvbiBNZXRob2RzIFJlZmVyZW5jZXMuIEpTT04gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICAgKiB0aGF0IGFyZSBpZGVudGlmaWVycyBmb3IgYXV0aGVudGljYXRpb24gbWV0aG9kcyB1c2VkIGluIHRoZVxuICAgICAgICAgKiBhdXRoZW50aWNhdGlvbi4gRm9yIGluc3RhbmNlLCB2YWx1ZXMgbWlnaHQgaW5kaWNhdGUgdGhhdCBib3RoXG4gICAgICAgICAqIHBhc3N3b3JkIGFuZCBPVFAgYXV0aGVudGljYXRpb24gbWV0aG9kcyB3ZXJlIHVzZWQuIFRoZSBkZWZpbml0aW9uXG4gICAgICAgICAqIG9mIHBhcnRpY3VsYXIgdmFsdWVzIHRvIGJlIHVzZWQgaW4gdGhlIGFtciBDbGFpbSBpcyBiZXlvbmQgdGhlXG4gICAgICAgICAqIHNjb3BlIG9mIHRoaXMgc3BlY2lmaWNhdGlvbi4gUGFydGllcyB1c2luZyB0aGlzIGNsYWltIHdpbGwgbmVlZCB0b1xuICAgICAgICAgKiBhZ3JlZSB1cG9uIHRoZSBtZWFuaW5ncyBvZiB0aGUgdmFsdWVzIHVzZWQsIHdoaWNoIG1heSBiZSBjb250ZXh0LVxuICAgICAgICAgKiBzcGVjaWZpYy4gVGhlIGFtciB2YWx1ZSBpcyBhbiBhcnJheSBvZiBjYXNlIHNlbnNpdGl2ZSBzdHJpbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgYW1yOiB7XG4gICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGF6cFxuICAgICAgICAgKiBPUFRJT05BTC4gQXV0aG9yaXplZCBwYXJ0eSAtIHRoZSBwYXJ0eSB0byB3aGljaCB0aGUgSUQgVG9rZW4gd2FzXG4gICAgICAgICAqIGlzc3VlZC4gSWYgcHJlc2VudCwgaXQgTVVTVCBjb250YWluIHRoZSBPQXV0aCAyLjAgQ2xpZW50IElEIG9mIHRoaXNcbiAgICAgICAgICogcGFydHkuIFRoaXMgQ2xhaW0gaXMgb25seSBuZWVkZWQgd2hlbiB0aGUgSUQgVG9rZW4gaGFzIGEgc2luZ2xlXG4gICAgICAgICAqIGF1ZGllbmNlIHZhbHVlIGFuZCB0aGF0IGF1ZGllbmNlIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBhdXRob3JpemVkXG4gICAgICAgICAqIHBhcnR5LiBJdCBNQVkgYmUgaW5jbHVkZWQgZXZlbiB3aGVuIHRoZSBhdXRob3JpemVkIHBhcnR5IGlzIHRoZVxuICAgICAgICAgKiBzYW1lIGFzIHRoZSBzb2xlIGF1ZGllbmNlLiBUaGUgYXpwIHZhbHVlIGlzIGEgY2FzZSBzZW5zaXRpdmUgc3RyaW5nXG4gICAgICAgICAqIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGF6cDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGZvcm1hdDogJ1N0cmluZ09yVVJJJ1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlcXVpcmVkIENsYWltc1xuICAgICAgICovXG4gICAgICByZXF1aXJlZDogWydpc3MnLCAnc3ViJywgJ2F1ZCcsICdleHAnLCAnaWF0J11cbiAgICB9XG4gIH1cbn0pO1xuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IElEVG9rZW5TY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuY29uc3QgZmV0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5jb25zdCBvbkh0dHBFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5jb25zdCBQb1BUb2tlbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5jbGFzcyBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNyZWRlbnRpYWxUeXBlIHtzdHJpbmd9ICdhY2Nlc3NfdG9rZW4nIG9yICdwb3BfdG9rZW4nXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlzc3VlciB7c3RyaW5nfSBJZGVudGl0eSBwcm92aWRlciAoaXNzdWVyIG9mIElEL0FjY2VzcyBUb2tlbilcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aG9yaXphdGlvbiB7b2JqZWN0fVxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRob3JpemF0aW9uLmNsaWVudF9pZCB7c3RyaW5nfSBPSURDL09BdXRoMiBjbGllbnQgaWRcbiAgICogQHBhcmFtIFtvcHRpb25zLmF1dGhvcml6YXRpb24uaWRfdG9rZW5dIHtzdHJpbmd9IENvbXBhY3Qtc2VyaWFsaXplZCBpZF90b2tlbiBwYXJhbVxuICAgKiBAcGFyYW0gW29wdGlvbnMuYXV0aG9yaXphdGlvbi5hY2Nlc3NfdG9rZW5dIHtzdHJpbmd9IENvbXBhY3Qtc2VyaWFsaXplZCBhY2Nlc3NfdG9rZW4gcGFyYW1cbiAgICogQHBhcmFtIFtvcHRpb25zLmF1dGhvcml6YXRpb24ucmVmcmVzaF90b2tlbl0ge3N0cmluZ30gQ29tcGFjdC1zZXJpYWxpemVkIHJlZnJlc2hfdG9rZW5cbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zLnNlc3Npb25LZXldIHtzdHJpbmd9IFNlcmlhbGl6ZWQgY2xpZW50IHNlc3Npb24ga2V5IGdlbmVyYXRlZFxuICAgKiAgIGR1cmluZyB0aGUgQXV0aGVudGljYXRpb24gUmVxdWVzdCwgdXNlZCB0byBpc3N1ZSBQb1BUb2tlbnNcbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zLmlkQ2xhaW1zXSB7b2JqZWN0fSBEZWNvZGVkL3ZlcmlmaWVkIElEIFRva2VuIEpXVCBwYXlsb2FkXG4gICAqXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5hY2Nlc3NDbGFpbXNdIHtvYmplY3R9IERlY29kZWQvdmVyaWZpZWQgQWNjZXNzIFRva2VuIEpXVCBwYXlsb2FkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5jcmVkZW50aWFsVHlwZSA9IG9wdGlvbnMuY3JlZGVudGlhbFR5cGUgfHwgJ2FjY2Vzc190b2tlbic7XG4gICAgdGhpcy5pc3N1ZXIgPSBvcHRpb25zLmlzc3VlcjtcbiAgICB0aGlzLmF1dGhvcml6YXRpb24gPSBvcHRpb25zLmF1dGhvcml6YXRpb24gfHwge307XG4gICAgdGhpcy5zZXNzaW9uS2V5ID0gb3B0aW9ucy5zZXNzaW9uS2V5O1xuICAgIHRoaXMuaWRDbGFpbXMgPSBvcHRpb25zLmlkQ2xhaW1zO1xuICAgIHRoaXMuYWNjZXNzQ2xhaW1zID0gb3B0aW9ucy5hY2Nlc3NDbGFpbXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVzcG9uc2Uge0F1dGhlbnRpY2F0aW9uUmVzcG9uc2V9XG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXNzaW9ufSBSZWx5aW5nUGFydHkgU2Vzc2lvbiBvYmplY3RcbiAgICovXG5cblxuICBzdGF0aWMgZnJvbUF1dGhSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IFJlbHlpbmdQYXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpOyAvLyBpbXBvcnQgaGVyZSBkdWUgdG8gY2lyY3VsYXIgZGVwXG5cblxuICAgIGxldCBpZENsYWltcyA9IHJlc3BvbnNlLmRlY29kZWQgJiYgcmVzcG9uc2UuZGVjb2RlZC5wYXlsb2FkIHx8IHt9O1xuICAgIGxldCB7XG4gICAgICBycFxuICAgIH0gPSByZXNwb25zZTtcbiAgICBsZXQgcmVnaXN0cmF0aW9uID0gcnAucmVnaXN0cmF0aW9uO1xuICAgIGxldCBycEF1dGhPcHRpb25zID0gcnAuZGVmYXVsdHMuYXV0aGVudGljYXRlIHx8IHt9O1xuICAgIGxldCBjcmVkZW50aWFsVHlwZSA9IHJwQXV0aE9wdGlvbnNbJ2NyZWRlbnRpYWxfdHlwZSddIHx8IHJwLmRlZmF1bHRzLnBvcFRva2VuID8gJ3BvcF90b2tlbicgOiAnYWNjZXNzX3Rva2VuJztcbiAgICBsZXQgc2Vzc2lvbktleSA9IHJlc3BvbnNlLnNlc3Npb25bUmVseWluZ1BhcnR5LlNFU1NJT05fUFJJVkFURV9LRVldO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgY3JlZGVudGlhbFR5cGUsXG4gICAgICBzZXNzaW9uS2V5LFxuICAgICAgaXNzdWVyOiBpZENsYWltcy5pc3MsXG4gICAgICBpZENsYWltcyxcbiAgICAgIGF1dGhvcml6YXRpb246IHtcbiAgICAgICAgY2xpZW50X2lkOiByZWdpc3RyYXRpb25bJ2NsaWVudF9pZCddLFxuICAgICAgICBhY2Nlc3NfdG9rZW46IHJlc3BvbnNlLnBhcmFtc1snYWNjZXNzX3Rva2VuJ10sXG4gICAgICAgIGlkX3Rva2VuOiByZXNwb25zZS5wYXJhbXNbJ2lkX3Rva2VuJ10sXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHJlc3BvbnNlLnBhcmFtc1sncmVmcmVzaF90b2tlbiddXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2Vzc2lvbi5mcm9tKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGVkIGZldGNoKCkgZ2V0dGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICovXG5cblxuICBnZXQgZmV0Y2goKSB7XG4gICAgLyoqXG4gICAgICogZmV0Y2goKSBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwge1JlcXVlc3RJbmZvfHN0cmluZ31cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9uPFByb21pc2U8UmVzcG9uc2U+Pn1cbiAgICAgKi9cbiAgICByZXR1cm4gKHVybCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5oYXNDcmVkZW50aWFscygpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hXaXRoQ3JlZGVudGlhbHModXJsLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihvbkh0dHBFcnJvcignRXJyb3Igd2hpbGUgZmV0Y2hpbmcgcmVzb3VyY2UnKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogYmVhcmVyVG9rZW5Gb3JcbiAgICpcbiAgICogQHBhcmFtIHVybCB7c3RyaW5nfVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKi9cblxuXG4gIGJlYXJlclRva2VuRm9yKHVybCkge1xuICAgIHN3aXRjaCAodGhpcy5jcmVkZW50aWFsVHlwZSkge1xuICAgICAgY2FzZSAncG9wX3Rva2VuJzpcbiAgICAgICAgcmV0dXJuIFBvUFRva2VuLmlzc3VlRm9yKHVybCwgdGhpcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vICdhY2Nlc3NfdG9rZW4nIGV0Y1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYXV0aG9yaXphdGlvblt0aGlzLmNyZWRlbnRpYWxUeXBlXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBoYXNDcmVkZW50aWFsc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBoYXNDcmVkZW50aWFscygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuY3JlZGVudGlhbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3BvcF90b2tlbic6XG4gICAgICAgIHJldHVybiAhIXRoaXMuYXV0aG9yaXphdGlvblsnaWRfdG9rZW4nXTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gJ2FjY2Vzc190b2tlbicgZXRjXG4gICAgICAgIHJldHVybiAhIXRoaXMuYXV0aG9yaXphdGlvblt0aGlzLmNyZWRlbnRpYWxUeXBlXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGZldGNoV2l0aENyZWRlbnRpYWxzXG4gICAqXG4gICAqIEBwYXJhbSB1cmwge1JlcXVlc3RJbmZvfHN0cmluZ31cbiAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgKi9cblxuXG4gIGZldGNoV2l0aENyZWRlbnRpYWxzKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLmJlYXJlclRva2VuRm9yKHVybCkudGhlbih0b2tlbiA9PiB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlc3Npb247XG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIHdoZW4gYSBmZXRjaCByZXNwb25zZSBzdGF0dXMgY29kZSBpbmRpY2F0ZXMgYSA0MDAgb3IgNTAwXG4gKiBIVFRQIGVycm9yLiAoVGhlIHdoYXR3ZyBmZXRjaCBhcGkgZG9lcyBub3Qgbm9ybWFsbHkgcmVqZWN0IG9uIGh0dHAgZXJyb3JcbiAqIHJlc3BvbnNlcykuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogYGBgXG4gKiByZXR1cm4gZmV0Y2godXJsKVxuICogICAudGhlbihvbkh0dHBFcnJvcignRXJyb3Igd2hpbGUgZmV0Y2hpbmcgcmVzb3VyY2UnKVxuICogICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpXG4gKlxuICogLy8gLT4gJ0Vycm9yIHdoaWxlIGZldGNoaW5nIHJlc291cmNlOiA0MDQgTm90IEZvdW5kJyBlcnJvclxuICogLy8gaWYgYSA0MDQgcmVzcG9uc2UgaXMgZW5jb3VudGVyZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBbbWVzc2FnZV0ge3N0cmluZ30gT3B0aW9uYWwgZXJyb3IgbWVzc2FnZSB0byBjbGFyaWZ5IGNvbnRleHRcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gRm9yIGh0dHAgc3RhdHVzIGNvZGVzID4gMzAwXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBmZXRjaCByZXNwb25zZSBvYmplY3QgKHBhc3NlZCB0aHJvdWdoIGlmIG5vIGVycm9yKVxuICovXG5cbmZ1bmN0aW9uIG9uSHR0cEVycm9yKG1lc3NhZ2UgPSAnZmV0Y2ggZXJyb3InKSB7XG4gIHJldHVybiByZXNwb25zZSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IGAke21lc3NhZ2V9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gICAgbGV0IGVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIHRocm93IGVycm9yO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9uSHR0cEVycm9yO1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmNvbnN0IHtcbiAgVVJMXG59ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbmNvbnN0IHtcbiAgSldULFxuICBKV0tcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuY29uc3QgREVGQVVMVF9NQVhfQUdFID0gMzYwMDsgLy8gRGVmYXVsdCB0b2tlbiBleHBpcmF0aW9uLCBpbiBzZWNvbmRzXG5cbmNsYXNzIFBvUFRva2VuIGV4dGVuZHMgSldUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZXNvdXJjZVNlcnZlclVyaSB7c3RyaW5nfSBSUyBVUkkgZm9yIHdoaWNoIHRoaXMgdG9rZW4gaXMgaW50ZW5kZWRcbiAgICpcbiAgICogQHBhcmFtIHNlc3Npb24ge1Nlc3Npb259XG4gICAqIEBwYXJhbSBzZXNzaW9uLnNlc3Npb25LZXkge3N0cmluZ31cbiAgICogQHBhcmFtIHNlc3Npb24uYXV0aG9yaXphdGlvbi5jbGllbnRfaWQge3N0cmluZ31cbiAgICogQHBhcmFtIHNlc3Npb24uYXV0aG9yaXphdGlvbi5pZF90b2tlbiB7c3RyaW5nfVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQb1BUb2tlbiwgZW5jb2RlZCBhcyBjb21wYWN0IEpXVFxuICAgKi9cbiAgc3RhdGljIGlzc3VlRm9yKHJlc291cmNlU2VydmVyVXJpLCBzZXNzaW9uKSB7XG4gICAgaWYgKCFyZXNvdXJjZVNlcnZlclVyaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXNzdWUgUG9QVG9rZW4gLSBtaXNzaW5nIHJlc291cmNlIHNlcnZlciBVUkknKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlc3Npb24uc2Vzc2lvbktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXNzdWUgUG9QVG9rZW4gLSBtaXNzaW5nIHNlc3Npb24ga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFzZXNzaW9uLmF1dGhvcml6YXRpb24uaWRfdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGlzc3VlIFBvUFRva2VuIC0gbWlzc2luZyBpZCB0b2tlbicpO1xuICAgIH1cblxuICAgIGxldCBqd2sgPSBKU09OLnBhcnNlKHNlc3Npb24uc2Vzc2lvbktleSk7XG4gICAgcmV0dXJuIEpXSy5pbXBvcnRLZXkoandrKS50aGVuKGltcG9ydGVkU2Vzc2lvbkp3ayA9PiB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgYXVkOiBuZXcgVVJMKHJlc291cmNlU2VydmVyVXJpKS5vcmlnaW4sXG4gICAgICAgIGtleTogaW1wb3J0ZWRTZXNzaW9uSndrLFxuICAgICAgICBpc3M6IHNlc3Npb24uYXV0aG9yaXphdGlvbi5jbGllbnRfaWQsXG4gICAgICAgIGlkX3Rva2VuOiBzZXNzaW9uLmF1dGhvcml6YXRpb24uaWRfdG9rZW5cbiAgICAgIH07XG4gICAgICByZXR1cm4gUG9QVG9rZW4uaXNzdWUob3B0aW9ucyk7XG4gICAgfSkudGhlbihqd3QgPT4ge1xuICAgICAgcmV0dXJuIGp3dC5lbmNvZGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogaXNzdWVcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogQHBhcmFtIG9wdGlvbnMuaXNzIHtzdHJpbmd9IFRva2VuIGlzc3VlciAoUlAgY2xpZW50X2lkKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdWQge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBBdWRpZW5jZSBmb3IgdGhlIHRva2VuXG4gICAqICAgKHN1Y2ggYXMgdGhlIFJlc291cmNlIFNlcnZlciB1cmwpXG4gICAqIEBwYXJhbSBvcHRpb25zLmtleSB7SldLfSBQcm9vZiBvZiBQb3NzZXNzaW9uIChwcml2YXRlKSBzaWduaW5nIGtleSwgc2VlXG4gICAqICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc4MDAjc2VjdGlvbi0zLjFcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuaWRfdG9rZW4ge3N0cmluZ30gSldUIGNvbXBhY3QgZW5jb2RlZCBJRCBUb2tlblxuICAgKlxuICAgKiBPcHRpb25hbDpcbiAgICogQHBhcmFtIFtvcHRpb25zLmlhdF0ge251bWJlcn0gSXNzdWVkIGF0IHRpbWVzdGFtcCAoaW4gc2Vjb25kcylcbiAgICogQHBhcmFtIFtvcHRpb25zLm1heF0ge251bWJlcn0gTWF4IHRva2VuIGxpZmV0aW1lIGluIHNlY29uZHNcbiAgICpcbiAgICogQHJldHVybnMge1BvUFRva2VufSBQcm9vZiBvZiBQb3NzZXNzaW9uIFRva2VuIChKV1QgaW5zdGFuY2UpXG4gICAqL1xuXG5cbiAgc3RhdGljIGlzc3VlKG9wdGlvbnMpIHtcbiAgICBsZXQge1xuICAgICAgYXVkLFxuICAgICAgaXNzLFxuICAgICAga2V5XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGFsZyA9IGtleS5hbGc7XG4gICAgbGV0IGlhdCA9IG9wdGlvbnMuaWF0IHx8IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIGxldCBtYXggPSBvcHRpb25zLm1heCB8fCBERUZBVUxUX01BWF9BR0U7XG4gICAgbGV0IGV4cCA9IGlhdCArIG1heDsgLy8gdG9rZW4gZXhwaXJhdGlvblxuXG4gICAgbGV0IGhlYWRlciA9IHtcbiAgICAgIGFsZ1xuICAgIH07XG4gICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICBpc3MsXG4gICAgICBhdWQsXG4gICAgICBleHAsXG4gICAgICBpYXQsXG4gICAgICBpZF90b2tlbjogb3B0aW9ucy5pZF90b2tlbixcbiAgICAgIHRva2VuX3R5cGU6ICdwb3AnXG4gICAgfTtcbiAgICBsZXQgand0ID0gbmV3IFBvUFRva2VuKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIHBheWxvYWQsXG4gICAgICBrZXk6IGtleS5jcnlwdG9LZXlcbiAgICB9LCB7XG4gICAgICBmaWx0ZXI6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIGp3dDtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9QVG9rZW47XG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSHR0cEVycm9yXG52YXIgU3RhbmRhcmRFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpXG52YXIgU1RBVFVTX0NPREVfVE9fTkFNRSA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpXG52YXIgU1RBVFVTX05BTUVfVE9fQ09ERSA9IGV4cG9ydHNcblxuZnVuY3Rpb24gSHR0cEVycm9yKGNvZGUsIG1zZywgcHJvcHMpIHtcbiAgaWYgKHR5cGVvZiBjb2RlID09IFwic3RyaW5nXCIpIGNvZGUgPSBTVEFUVVNfTkFNRV9UT19DT0RFW2NvZGVdXG4gIGlmICh0eXBlb2YgY29kZSAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm9uLW51bWVyaWMgSFRUUCBjb2RlXCIpXG4gIGlmICh0eXBlb2YgbXNnID09IFwib2JqZWN0XCIgJiYgbXNnICE9IG51bGwpIHsgcHJvcHMgPSBtc2c7IG1zZyA9IG51bGwgfVxuICBTdGFuZGFyZEVycm9yLmNhbGwodGhpcywgbXNnIHx8IFNUQVRVU19DT0RFX1RPX05BTUVbY29kZV0sIHByb3BzKVxuICB0aGlzLmNvZGUgPSBjb2RlXG59XG5cbkh0dHBFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0YW5kYXJkRXJyb3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7dmFsdWU6IEh0dHBFcnJvciwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZX1cbn0pXG5cbi8vIFNldCBuYW1lIGV4cGxpY2l0bHkgZm9yIHdoZW4gdGhlIGNvZGUgZ2V0cyBtaW5pZmllZC5cbkh0dHBFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiSHR0cEVycm9yXCJcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSHR0cEVycm9yLnByb3RvdHlwZSwge1xuICBzdGF0dXNDb2RlOiBhbGlhcyhcImNvZGVcIiksXG4gIHN0YXR1c01lc3NhZ2U6IGFsaWFzKFwibWVzc2FnZVwiKSxcblxuICBzdGF0dXM6IHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29kZSB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pXG5cbkh0dHBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMuY29kZSArIFwiIFwiICsgdGhpcy5tZXNzYWdlXG59XG5cbmZvciAodmFyIGNvZGUgaW4gU1RBVFVTX0NPREVfVE9fTkFNRSkge1xuICB2YXIgbmFtZSA9IFNUQVRVU19DT0RFX1RPX05BTUVbY29kZV1cbiAgZXhwb3J0c1tuYW1lLnJlcGxhY2UoXCInXCIsIFwiXCIpLnJlcGxhY2UoL1stIF0vZywgXCJfXCIpLnRvVXBwZXJDYXNlKCldID0gK2NvZGVcbn1cblxuZnVuY3Rpb24gYWxpYXMobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpc1tuYW1lXSB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHRoaXNbbmFtZV0gPSB2YWx1ZSB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBoYXMgPSBPYmplY3QuaGFzT3duUHJvcGVydHlcbnZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxudmFyIHRyYWNlID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Vcbm1vZHVsZS5leHBvcnRzID0gU3RhbmRhcmRFcnJvclxuXG5mdW5jdGlvbiBTdGFuZGFyZEVycm9yKG1zZywgcHJvcHMpIHtcbiAgLy8gTGV0IGFsbCBwcm9wZXJ0aWVzIGJlIGVudW1lcmFibGUgZm9yIGVhc2llciBzZXJpYWxpemF0aW9uLlxuICBpZiAobXNnICYmIHR5cGVvZiBtc2cgPT0gXCJvYmplY3RcIikgcHJvcHMgPSBtc2csIG1zZyA9IHVuZGVmaW5lZFxuICBlbHNlIHRoaXMubWVzc2FnZSA9IG1zZ1xuXG4gIC8vIE5hbWUgaGFzIHRvIGJlIGFuIG93biBwcm9wZXJ0eSAob3Igb24gdGhlIHByb3RvdHlwZSBhIHNpbmdsZSBzdGVwIHVwKSBmb3JcbiAgLy8gdGhlIHN0YWNrIHRvIGJlIHByaW50ZWQgd2l0aCB0aGUgY29ycmVjdCBuYW1lLlxuICBpZiAocHJvcHMpIGZvciAodmFyIGtleSBpbiBwcm9wcykgdGhpc1trZXldID0gcHJvcHNba2V5XVxuICBpZiAoIWhhcy5jYWxsKHRoaXMsIFwibmFtZVwiKSlcbiAgICB0aGlzLm5hbWUgPSBoYXMuY2FsbChwcm90byh0aGlzKSwgXCJuYW1lXCIpPyB0aGlzLm5hbWUgOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWVcblxuICBpZiAodHJhY2UgJiYgIShcInN0YWNrXCIgaW4gdGhpcykpIHRyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpXG59XG5cblN0YW5kYXJkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHt2YWx1ZTogU3RhbmRhcmRFcnJvciwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZX1cbn0pXG5cbi8vIFNldCBuYW1lIGV4cGxpY2l0bHkgZm9yIHdoZW4gdGhlIGNvZGUgZ2V0cyBtaW5pZmllZC5cblN0YW5kYXJkRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlN0YW5kYXJkRXJyb3JcIlxuXG5cbi8qKiovIH0pLFxuLyogNzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OLnBhcnNlKFwie1xcXCIxMDBcXFwiOlxcXCJDb250aW51ZVxcXCIsXFxcIjEwMVxcXCI6XFxcIlN3aXRjaGluZyBQcm90b2NvbHNcXFwiLFxcXCIxMDJcXFwiOlxcXCJQcm9jZXNzaW5nXFxcIixcXFwiMjAwXFxcIjpcXFwiT0tcXFwiLFxcXCIyMDFcXFwiOlxcXCJDcmVhdGVkXFxcIixcXFwiMjAyXFxcIjpcXFwiQWNjZXB0ZWRcXFwiLFxcXCIyMDNcXFwiOlxcXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblxcXCIsXFxcIjIwNFxcXCI6XFxcIk5vIENvbnRlbnRcXFwiLFxcXCIyMDVcXFwiOlxcXCJSZXNldCBDb250ZW50XFxcIixcXFwiMjA2XFxcIjpcXFwiUGFydGlhbCBDb250ZW50XFxcIixcXFwiMjA3XFxcIjpcXFwiTXVsdGktU3RhdHVzXFxcIixcXFwiMjA4XFxcIjpcXFwiQWxyZWFkeSBSZXBvcnRlZFxcXCIsXFxcIjIyNlxcXCI6XFxcIklNIFVzZWRcXFwiLFxcXCIzMDBcXFwiOlxcXCJNdWx0aXBsZSBDaG9pY2VzXFxcIixcXFwiMzAxXFxcIjpcXFwiTW92ZWQgUGVybWFuZW50bHlcXFwiLFxcXCIzMDJcXFwiOlxcXCJGb3VuZFxcXCIsXFxcIjMwM1xcXCI6XFxcIlNlZSBPdGhlclxcXCIsXFxcIjMwNFxcXCI6XFxcIk5vdCBNb2RpZmllZFxcXCIsXFxcIjMwNVxcXCI6XFxcIlVzZSBQcm94eVxcXCIsXFxcIjMwN1xcXCI6XFxcIlRlbXBvcmFyeSBSZWRpcmVjdFxcXCIsXFxcIjMwOFxcXCI6XFxcIlBlcm1hbmVudCBSZWRpcmVjdFxcXCIsXFxcIjQwMFxcXCI6XFxcIkJhZCBSZXF1ZXN0XFxcIixcXFwiNDAxXFxcIjpcXFwiVW5hdXRob3JpemVkXFxcIixcXFwiNDAyXFxcIjpcXFwiUGF5bWVudCBSZXF1aXJlZFxcXCIsXFxcIjQwM1xcXCI6XFxcIkZvcmJpZGRlblxcXCIsXFxcIjQwNFxcXCI6XFxcIk5vdCBGb3VuZFxcXCIsXFxcIjQwNVxcXCI6XFxcIk1ldGhvZCBOb3QgQWxsb3dlZFxcXCIsXFxcIjQwNlxcXCI6XFxcIk5vdCBBY2NlcHRhYmxlXFxcIixcXFwiNDA3XFxcIjpcXFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcXFwiLFxcXCI0MDhcXFwiOlxcXCJSZXF1ZXN0IFRpbWVvdXRcXFwiLFxcXCI0MDlcXFwiOlxcXCJDb25mbGljdFxcXCIsXFxcIjQxMFxcXCI6XFxcIkdvbmVcXFwiLFxcXCI0MTFcXFwiOlxcXCJMZW5ndGggUmVxdWlyZWRcXFwiLFxcXCI0MTJcXFwiOlxcXCJQcmVjb25kaXRpb24gRmFpbGVkXFxcIixcXFwiNDEzXFxcIjpcXFwiUGF5bG9hZCBUb28gTGFyZ2VcXFwiLFxcXCI0MTRcXFwiOlxcXCJVUkkgVG9vIExvbmdcXFwiLFxcXCI0MTVcXFwiOlxcXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXFxcIixcXFwiNDE2XFxcIjpcXFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXFxcIixcXFwiNDE3XFxcIjpcXFwiRXhwZWN0YXRpb24gRmFpbGVkXFxcIixcXFwiNDE4XFxcIjpcXFwiSSdtIGEgdGVhcG90XFxcIixcXFwiNDIxXFxcIjpcXFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFxcXCIsXFxcIjQyMlxcXCI6XFxcIlVucHJvY2Vzc2FibGUgRW50aXR5XFxcIixcXFwiNDIzXFxcIjpcXFwiTG9ja2VkXFxcIixcXFwiNDI0XFxcIjpcXFwiRmFpbGVkIERlcGVuZGVuY3lcXFwiLFxcXCI0MjVcXFwiOlxcXCJVbm9yZGVyZWQgQ29sbGVjdGlvblxcXCIsXFxcIjQyNlxcXCI6XFxcIlVwZ3JhZGUgUmVxdWlyZWRcXFwiLFxcXCI0MjhcXFwiOlxcXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcXFwiLFxcXCI0MjlcXFwiOlxcXCJUb28gTWFueSBSZXF1ZXN0c1xcXCIsXFxcIjQzMVxcXCI6XFxcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcXFwiLFxcXCI1MDBcXFwiOlxcXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcXFwiLFxcXCI1MDFcXFwiOlxcXCJOb3QgSW1wbGVtZW50ZWRcXFwiLFxcXCI1MDJcXFwiOlxcXCJCYWQgR2F0ZXdheVxcXCIsXFxcIjUwM1xcXCI6XFxcIlNlcnZpY2UgVW5hdmFpbGFibGVcXFwiLFxcXCI1MDRcXFwiOlxcXCJHYXRld2F5IFRpbWVvdXRcXFwiLFxcXCI1MDVcXFwiOlxcXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFxcXCIsXFxcIjUwNlxcXCI6XFxcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXFxcIixcXFwiNTA3XFxcIjpcXFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcXFwiLFxcXCI1MDhcXFwiOlxcXCJMb29wIERldGVjdGVkXFxcIixcXFwiNTA5XFxcIjpcXFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXFxcIixcXFwiNTEwXFxcIjpcXFwiTm90IEV4dGVuZGVkXFxcIixcXFwiNTExXFxcIjpcXFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFxcXCJ9XCIpO1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbmNvbnN0IHtcbiAgSlNPTlNjaGVtYVxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuLyoqXG4gKiBSZWx5aW5nUGFydHkgU2NoZW1hXG4gKlxuICogVGhpcyBzY2hlbWEgaW5pdGlhbGl6ZXMgYW5kIHZlcmlmaWVzIFJlbHlpbmcgUGFydHkgY2xpZW50IGNvbmZpZ3VyYXRpb24uXG4gKiBSZWx5aW5nUGFydHkgb2JqZWN0cyBjYW4gYmUgcGVyc2lzdGVkIGFuZCByZWh5ZHJhdGVkLiBCeSBlbmNhcHN1bGF0aW5nIHRoaXMgZGF0YSBpblxuICogaXQncyBvd24gY2xhc3MsIGl0J3MgcG9zc2libGUgdG8gaGF2ZSBtdWx0aXBsZSBSUCBjb25maWd1cmF0aW9ucyBydW5uaW5nXG4gKiBzaW11bHRhbmVvdXNseS5cbiAqL1xuXG5cbmNvbnN0IFJlbHlpbmdQYXJ0eVNjaGVtYSA9IG5ldyBKU09OU2NoZW1hKHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBwcm92aWRlclxuICAgICAqXG4gICAgICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb3ZpZGVyLCBpbmNsdWRpbmcgaXNzdWVyIFVSTCwgaHVtYW4gcmVhZGFibGUgbmFtZSxcbiAgICAgKiBhbmQgYW55IGNvbmZpZ3VyYXRpb24gb3IgcHJvdmlkZXIgbWV0YWRhdGEgcmV0cmlldmVkIGZyb20gdGhlIE9QLlxuICAgICAqL1xuICAgIHByb3ZpZGVyOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIHVybDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGZvcm1hdDogJ3VyaSdcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTk9URTpcbiAgICAgICAgLy8gT3BlbklEIENvbmZpZ3VyYXRpb24gKGRpc2NvdmVyeSByZXNwb25zZSkgYW5kIEpTT04gV2ViIEtleXMgU2V0IGZvciBhblxuICAgICAgICAvLyBpc3N1ZXIgY2FuIGJlIGNhY2hlZCBoZXJlLiBIb3dldmVyIHRoZSBjYWNoZSBzaG91bGQgbm90IGJlIHBlcnNpc3RlZCBvclxuICAgICAgICAvLyByZWxpZWQgdXBvbi5cbiAgICAgICAgLy9cbiAgICAgICAgY29uZmlndXJhdGlvbjoge30sXG4gICAgICAgIC8vIC53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uXG4gICAgICAgIGp3a3M6IHt9IC8vIC9qd2tzXG5cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWyd1cmwnXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZWZhdWx0c1xuICAgICAqXG4gICAgICogRGVmYXVsdCByZXF1ZXN0IHBhcmFtZXRlcnMgZm9yIGF1dGhlbnRpY2F0aW9uIGFuZCBkeW5hbWljIHJlZ2lzdHJhdGlvbiByZXF1ZXN0cy5cbiAgICAgKiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGV4dGVuZGVkIG9yIG92ZXJyaWRkZW4gdmlhIGFyZ3VtZW50cyB0byB0aGUgcmVzcGVjdGl2ZVxuICAgICAqIHJlcXVlc3QgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZXNlIGFyZSBwYXJ0IG9mIHRoZSByZWx5aW5nIHBhcnR5IGNsaWVudCBjb25maWd1cmF0aW9uIGFuZCBjYW4gYmUgc2VyaWFsaXplZFxuICAgICAqIGFuZCBwZXJzaXN0ZWQuXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIFByb29mIG9mIFBvc3Nlc3Npb24gdG9rZW4gc2VtYW50aWNzIGZvciB0aGUgSUQgVG9rZW5cbiAgICAgICAgICovXG4gICAgICAgIHBvcFRva2VuOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgYXV0aGVudGljYXRpb24gcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBhdXRoZW50aWNhdGU6IHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICByZWRpcmVjdF91cmk6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGZvcm1hdDogJ3VyaSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zZV90eXBlOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBkZWZhdWx0OiAnaWRfdG9rZW4gdG9rZW4nLFxuICAgICAgICAgICAgICAvLyBicm93c2VyIGRldGVjdGlvblxuICAgICAgICAgICAgICBlbnVtOiBbJ2NvZGUnLCAndG9rZW4nLCAnaWRfdG9rZW4gdG9rZW4nLCAnaWRfdG9rZW4gdG9rZW4gY29kZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgZGVmYXVsdDogJ3BhZ2UnLFxuICAgICAgICAgICAgICBlbnVtOiBbJ3BhZ2UnLCAncG9wdXAnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2FycmF5J10sXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IFsnb3BlbmlkJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgY2xpZW50IHJlZ2lzdHJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3Rlcjoge31cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVnaXN0cmF0aW9uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBjbGllbnQgcmVnaXN0cmF0aW9uIHJlc3BvbnNlIGZyb20gZHluYW1pYyByZWdpc3RyYXRpb24uIEl0IHNob3VsZFxuICAgICAqIGFsd2F5cyByZWZsZWN0IHRoZSBjbGllbnQgY29uZmlndXJhdGlvbiBvbiB0aGUgb3BlbmlkIHByb3ZpZGVyLiBBIGNsaWVudCBhY2Nlc3NcbiAgICAgKiB0b2tlbiBpcyBzdG9yZWQgaGVyZVxuICAgICAqL1xuICAgIHJlZ2lzdHJhdGlvbjoge30sXG4gICAgLy8gQ2xpZW50TWV0YWRhdGFTY2hlbWFcblxuICAgIC8qKlxuICAgICAqIHN0b3JlXG4gICAgICovXG4gICAgc3RvcmU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgZGVmYXVsdDoge31cbiAgICB9XG4gIH1cbn0pO1xuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbHlpbmdQYXJ0eVNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA4MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpLFxuICAgIFVSTCA9IF9yZXF1aXJlLlVSTDtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpLFxuICAgIEpXVCA9IF9yZXF1aXJlMi5KV1QsXG4gICAgSldLID0gX3JlcXVpcmUyLkpXSztcblxudmFyIERFRkFVTFRfTUFYX0FHRSA9IDM2MDA7IC8vIERlZmF1bHQgdG9rZW4gZXhwaXJhdGlvbiwgaW4gc2Vjb25kc1xuXG52YXIgUG9QVG9rZW4gPSBmdW5jdGlvbiAoX0pXVCkge1xuICBfaW5oZXJpdHMoUG9QVG9rZW4sIF9KV1QpO1xuXG4gIGZ1bmN0aW9uIFBvUFRva2VuKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb1BUb2tlbik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBvUFRva2VuLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9QVG9rZW4pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb1BUb2tlbiwgbnVsbCwgW3tcbiAgICBrZXk6ICdpc3N1ZUZvcicsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVzb3VyY2VTZXJ2ZXJVcmkge3N0cmluZ30gUlMgVVJJIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIGludGVuZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiB7U2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gc2Vzc2lvbi5zZXNzaW9uS2V5IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHNlc3Npb24uYXV0aG9yaXphdGlvbi5jbGllbnRfaWQge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gc2Vzc2lvbi5hdXRob3JpemF0aW9uLmlkX3Rva2VuIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQb1BUb2tlbiwgZW5jb2RlZCBhcyBjb21wYWN0IEpXVFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpc3N1ZUZvcihyZXNvdXJjZVNlcnZlclVyaSwgc2Vzc2lvbikge1xuICAgICAgaWYgKCFyZXNvdXJjZVNlcnZlclVyaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpc3N1ZSBQb1BUb2tlbiAtIG1pc3NpbmcgcmVzb3VyY2Ugc2VydmVyIFVSSScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlc3Npb24uc2Vzc2lvbktleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpc3N1ZSBQb1BUb2tlbiAtIG1pc3Npbmcgc2Vzc2lvbiBrZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZXNzaW9uLmF1dGhvcml6YXRpb24uaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXNzdWUgUG9QVG9rZW4gLSBtaXNzaW5nIGlkIHRva2VuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBqd2sgPSBKU09OLnBhcnNlKHNlc3Npb24uc2Vzc2lvbktleSk7XG4gICAgICByZXR1cm4gSldLLmltcG9ydEtleShqd2spLnRoZW4oZnVuY3Rpb24gKGltcG9ydGVkU2Vzc2lvbkp3aykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBhdWQ6IG5ldyBVUkwocmVzb3VyY2VTZXJ2ZXJVcmkpLm9yaWdpbixcbiAgICAgICAgICBrZXk6IGltcG9ydGVkU2Vzc2lvbkp3ayxcbiAgICAgICAgICBpc3M6IHNlc3Npb24uYXV0aG9yaXphdGlvbi5jbGllbnRfaWQsXG4gICAgICAgICAgaWRfdG9rZW46IHNlc3Npb24uYXV0aG9yaXphdGlvbi5pZF90b2tlblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUG9QVG9rZW4uaXNzdWUob3B0aW9ucyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChqd3QpIHtcbiAgICAgICAgcmV0dXJuIGp3dC5lbmNvZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpc3N1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pc3Mge3N0cmluZ30gVG9rZW4gaXNzdWVyIChSUCBjbGllbnRfaWQpXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXVkIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gQXVkaWVuY2UgZm9yIHRoZSB0b2tlblxuICAgICAqICAgKHN1Y2ggYXMgdGhlIFJlc291cmNlIFNlcnZlciB1cmwpXG4gICAgICogQHBhcmFtIG9wdGlvbnMua2V5IHtKV0t9IFByb29mIG9mIFBvc3Nlc3Npb24gKHByaXZhdGUpIHNpZ25pbmcga2V5LCBzZWVcbiAgICAgKiAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3ODAwI3NlY3Rpb24tMy4xXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pZF90b2tlbiB7c3RyaW5nfSBKV1QgY29tcGFjdCBlbmNvZGVkIElEIFRva2VuXG4gICAgICpcbiAgICAgKiBPcHRpb25hbDpcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMuaWF0XSB7bnVtYmVyfSBJc3N1ZWQgYXQgdGltZXN0YW1wIChpbiBzZWNvbmRzKVxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy5tYXhdIHtudW1iZXJ9IE1heCB0b2tlbiBsaWZldGltZSBpbiBzZWNvbmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UG9QVG9rZW59IFByb29mIG9mIFBvc3Nlc3Npb24gVG9rZW4gKEpXVCBpbnN0YW5jZSlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNzdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc3N1ZShvcHRpb25zKSB7XG4gICAgICB2YXIgYXVkID0gb3B0aW9ucy5hdWQsXG4gICAgICAgICAgaXNzID0gb3B0aW9ucy5pc3MsXG4gICAgICAgICAga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgICB2YXIgYWxnID0ga2V5LmFsZztcbiAgICAgIHZhciBpYXQgPSBvcHRpb25zLmlhdCB8fCBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIHZhciBtYXggPSBvcHRpb25zLm1heCB8fCBERUZBVUxUX01BWF9BR0U7XG4gICAgICB2YXIgZXhwID0gaWF0ICsgbWF4OyAvLyB0b2tlbiBleHBpcmF0aW9uXG5cbiAgICAgIHZhciBoZWFkZXIgPSB7XG4gICAgICAgIGFsZzogYWxnXG4gICAgICB9O1xuICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIGlzczogaXNzLFxuICAgICAgICBhdWQ6IGF1ZCxcbiAgICAgICAgZXhwOiBleHAsXG4gICAgICAgIGlhdDogaWF0LFxuICAgICAgICBpZF90b2tlbjogb3B0aW9ucy5pZF90b2tlbixcbiAgICAgICAgdG9rZW5fdHlwZTogJ3BvcCdcbiAgICAgIH07XG4gICAgICB2YXIgand0ID0gbmV3IFBvUFRva2VuKHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIGtleToga2V5LmNyeXB0b0tleVxuICAgICAgfSwge1xuICAgICAgICBmaWx0ZXI6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBqd3Q7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvUFRva2VuO1xufShKV1QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvUFRva2VuO1xuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9wZW5JZHBQb3B1cFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9wZW5JZHBQb3B1cDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib2J0YWluU2Vzc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9idGFpblNlc3Npb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBvcHVwSGFuZGxlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBvcHVwSGFuZGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lwY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG5cbmZ1bmN0aW9uIG9wZW5JZHBQb3B1cChwb3B1cFVyaSkge1xuICBjb25zdCB3aWR0aCA9IDY1MDtcbiAgY29uc3QgaGVpZ2h0ID0gNDAwO1xuICBjb25zdCBsZWZ0ID0gd2luZG93LnNjcmVlblggKyAod2luZG93LmlubmVyV2lkdGggLSB3aWR0aCkgLyAyO1xuICBjb25zdCB0b3AgPSB3aW5kb3cuc2NyZWVuWSArICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgY29uc3Qgc2V0dGluZ3MgPSBcIndpZHRoPVwiLmNvbmNhdCh3aWR0aCwgXCIsaGVpZ2h0PVwiKS5jb25jYXQoaGVpZ2h0LCBcIixsZWZ0PVwiKS5jb25jYXQobGVmdCwgXCIsdG9wPVwiKS5jb25jYXQodG9wKTtcbiAgcmV0dXJuIHdpbmRvdy5vcGVuKHBvcHVwVXJpLCAnc29saWQtYXV0aC1jbGllbnQnLCBzZXR0aW5ncyk7XG59XG5mdW5jdGlvbiBvYnRhaW5TZXNzaW9uKHN0b3JlLCBwb3B1cCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHBvcHVwU2VydmVyID0gbmV3IF9pcGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlNlcnZlclwiXShwb3B1cCwgT2JqZWN0KF91cmxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wib3JpZ2luT2ZcIl0pKG9wdGlvbnMucG9wdXBVcmkgfHwgJycpLCBwb3B1cEhhbmRsZXIoc3RvcmUsIG9wdGlvbnMsIHNlc3Npb24gPT4ge1xuICAgICAgcG9wdXBTZXJ2ZXIuc3RvcCgpO1xuICAgICAgcmVzb2x2ZShzZXNzaW9uKTtcbiAgICB9KSk7XG4gICAgcG9wdXBTZXJ2ZXIuc3RhcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwb3B1cEhhbmRsZXIoc3RvcmUsIF9yZWYsIGZvdW5kU2Vzc2lvbkNiKSB7XG4gIGxldCB7XG4gICAgcG9wdXBVcmksXG4gICAgY2FsbGJhY2tVcmlcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIC8vIE9yaWdpblxuICAgICAgY2FzZSAnZ2V0QXBwT3JpZ2luJzpcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAvLyBTdG9yYWdlXG5cbiAgICAgIGNhc2UgJ3N0b3JhZ2UvZ2V0SXRlbSc6XG4gICAgICAgIHJldHVybiBzdG9yZS5nZXRJdGVtKC4uLmFyZ3MpO1xuXG4gICAgICBjYXNlICdzdG9yYWdlL3NldEl0ZW0nOlxuICAgICAgICByZXR1cm4gc3RvcmUuc2V0SXRlbSguLi5hcmdzKTtcblxuICAgICAgY2FzZSAnc3RvcmFnZS9yZW1vdmVJdGVtJzpcbiAgICAgICAgcmV0dXJuIHN0b3JlLnJlbW92ZUl0ZW0oLi4uYXJncyk7XG4gICAgICAvLyBMb2dpblxuXG4gICAgICBjYXNlICdnZXRMb2dpbk9wdGlvbnMnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvcHVwVXJpLFxuICAgICAgICAgIGNhbGxiYWNrVXJpXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgJ2ZvdW5kU2Vzc2lvbic6XG4gICAgICAgIGZvdW5kU2Vzc2lvbkNiKC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = require(\"./raw\");\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n\n},{\"./raw\":2}],2:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar assign        = require('es5-ext/object/assign')\n  , normalizeOpts = require('es5-ext/object/normalize-options')\n  , isCallable    = require('es5-ext/object/is-callable')\n  , contains      = require('es5-ext/string/#/contains')\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\n},{\"es5-ext/object/assign\":5,\"es5-ext/object/is-callable\":8,\"es5-ext/object/normalize-options\":14,\"es5-ext/string/#/contains\":17}],4:[function(require,module,exports){\n\"use strict\";\n\n// eslint-disable-next-line no-empty-function\nmodule.exports = function () {};\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.assign : require(\"./shim\");\n\n},{\"./is-implemented\":6,\"./shim\":7}],6:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== \"function\") return false;\n\tobj = { foo: \"raz\" };\n\tassign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n\treturn obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n};\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\n\nvar keys  = require(\"../keys\")\n  , value = require(\"../valid-value\")\n  , max   = Math.max;\n\nmodule.exports = function (dest, src/*, srcn*/) {\n\tvar error, i, length = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry {\n\t\t\tdest[key] = src[key];\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < length; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n\n},{\"../keys\":11,\"../valid-value\":16}],8:[function(require,module,exports){\n// Deprecated\n\n\"use strict\";\n\nmodule.exports = function (obj) { return typeof obj === \"function\"; };\n\n},{}],9:[function(require,module,exports){\n\"use strict\";\n\nvar value                   = require(\"./valid-value\")\n  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (obj) {\n\tvar i;\n\tvalue(obj);\n\tfor (i in obj) {\n\t\t// Jslint: ignore\n\t\tif (objPropertyIsEnumerable.call(obj, i)) return false;\n\t}\n\treturn true;\n};\n\n},{\"./valid-value\":16}],10:[function(require,module,exports){\n\"use strict\";\n\nvar _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\nmodule.exports = function (val) { return val !== _undefined && val !== null; };\n\n},{\"../function/noop\":4}],11:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.keys : require(\"./shim\");\n\n},{\"./is-implemented\":12,\"./shim\":13}],12:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys(\"primitive\");\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n},{}],13:[function(require,module,exports){\n\"use strict\";\n\nvar isValue = require(\"../is-value\");\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };\n\n},{\"../is-value\":10}],14:[function(require,module,exports){\n\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (opts1/*, options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (!isValue(options)) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n\n},{\"./is-value\":10}],15:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n\n},{}],16:[function(require,module,exports){\n\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n\n},{\"./is-value\":10}],17:[function(require,module,exports){\n\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? String.prototype.contains : require(\"./shim\");\n\n},{\"./is-implemented\":18,\"./shim\":19}],18:[function(require,module,exports){\n\"use strict\";\n\nvar str = \"razdwatrzy\";\n\nmodule.exports = function () {\n\tif (typeof str.contains !== \"function\") return false;\n\treturn str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n};\n\n},{}],19:[function(require,module,exports){\n\"use strict\";\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n\n},{}],20:[function(require,module,exports){\nexports.Agent = require('./lib/Agent');\nexports.ServiceManager = require('./lib/ServiceManager');\nexports.TransportManager = require('./lib/TransportManager');\n\nexports.transport = {\n  LocalTransport:     require('./lib/transport/local/LocalTransport')\n};\n\nexports.TransportManager.registerType(exports.transport.LocalTransport);\n\n// load the default ServiceManager, a singleton, initialized with a LocalTransport\nexports.system = new exports.ServiceManager();\nexports.system.transports.add(new exports.transport.LocalTransport());\n\n// override Agent.getTransportById in order to support Agent.connect(transportId)\nexports.Agent.getTransportById = function (id) {\n  return exports.system.transports.get(id);\n};\n\n},{\"./lib/Agent\":21,\"./lib/ServiceManager\":22,\"./lib/TransportManager\":23,\"./lib/transport/local/LocalTransport\":27}],21:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('promise');\nvar uuid = require('uuid-v4');\nvar util = require('./util');\nvar URL = require('url');\n\n/**\n * Agent\n * @param {string} [id]         Id for the agent. If not provided, the agent\n *                              will be given a uuid.\n * @constructor\n */\nfunction Agent(id) {\n  this.id = id ? id.toString() : uuid();\n\n  // a list with all connected transports\n  this.connections = [];\n  this.defaultConnection = null;\n  this.ready = Promise.resolve([]);\n}\n\n// an object with modules which can be used to extend the agent\nAgent.modules = {};\n\n/**\n * Register a new type of module. This module can then be loaded via\n * Agent.extend() and Agent.loadModule().\n * @param {Function} constructor     A module constructor\n */\nAgent.registerModule = function (constructor) {\n  var type = constructor.prototype.type;\n  if (typeof constructor !== 'function') {\n    throw new Error('Constructor function expected');\n  }\n  if (!type) {\n    throw new Error('Field \"prototype.type\" missing in transport constructor');\n  }\n  if (type in Agent.modules) {\n    if (Agent.modules[type] !== constructor) {\n      throw new Error('Module of type \"' + type + '\" already exists');\n    }\n  }\n\n  Agent.modules[type] = constructor;\n};\n\n/**\n * Get a transport by id.\n * This static method can be overloaded for example by the get function of\n * a singleton TransportManager.\n * @param {string} id\n * @return {Transport}\n */\nAgent.getTransportById = function (id) {\n  throw new Error('Transport with id \"' + id + '\" not found');\n};\n\n/**\n * Extend an agent with modules (mixins).\n * The modules new functions are added to the Agent itself.\n * See also function `loadModule`.\n * @param {string | string[]} module  A module name or an Array with module\n *                                    names. Available modules:\n *                                    'pattern', 'request', 'babble'\n * @param {Object} [options]          Additional options for loading the module\n * @return {Agent} Returns the agent itself\n */\nAgent.prototype.extend = function (module, options) {\n  if (Array.isArray(module)) {\n    var modules = [].concat(module);\n\n    // order the modules such that 'pattern' comes first, this module must be\n    // loaded before other modules ('request' specifically)\n    modules.sort(function (a, b) {\n      if (a == 'pattern') return -1;\n      if (b == 'pattern') return 1;\n      return 0;\n    });\n\n    // an array with module names\n    for (var i = 0; i < modules.length; i++) {\n      this.extend(modules[i], options)\n    }\n  }\n  else {\n    // a single module name\n    var constructor = _getModuleConstructor(module);\n    var instance = new constructor(this, options);\n    var mixin = instance.mixin();\n\n    // check for conflicts in the modules mixin functions\n    var me = this;\n    Object.keys(mixin).forEach(function (name) {\n      if (me[name] !== undefined && name !== '_receive') {\n        throw new Error('Conflict: agent already has a property \"' + prop + '\"');\n      }\n    });\n\n    // extend the agent with all mixin functions provided by the module\n    Object.keys(mixin).forEach(function (name) {\n      me[name] = mixin[name];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Load a module onto an agent.\n * See also function `extend`.\n * @param {string | string[]} module  A module name or an Array with module\n *                                    names. Available modules:\n *                                    'pattern', 'request', 'babble'\n * @param {Object} [options]          Additional options for loading the module\n * @return {Object} Returns the created module\n */\nAgent.prototype.loadModule = function (module, options, additionalOptions) {\n  var _options = options !== undefined ? Object.create(options) : {};\n  _options.extend = false;\n\n  var constructor = _getModuleConstructor(module);\n  var instance = new constructor(this, options, additionalOptions);\n  var mixin = instance.mixin();\n\n  // only replace the _receive function, do not add other mixin functions\n  this._receive = mixin._receive;\n\n  return instance;\n};\n\n/**\n * Get a module constructor by it's name.\n * Throws an error when the module is not found.\n * @param {string} name\n * @return {function} Returns the modules constructor function\n * @private\n */\nfunction _getModuleConstructor(name) {\n  var constructor = Agent.modules[name];\n  if (!constructor) {\n    throw new Error('Unknown module \"' + name + '\". ' +\n      'Choose from: ' + Object.keys(Agent.modules).map(JSON.stringify).join(', '));\n  }\n  return constructor;\n}\n\n/**\n * Send a message to an agent\n * @param {string} to\n *              to is either:\n *              - A string \"agentId\", the id of the recipient. Will be send\n *                via the default transport or when there is no default\n *                transport via the first connected transport.\n *              - A string \"agentId@transportId\" Only usable locally, not\n *                for sharing an address with remote agents.\n *              - A string \"protocol://networkId/agentId\". This is a sharable\n *                identifier for an agent.\n * @param {*} message  Message to be send\n * @return {Promise} Returns a promise which resolves when the message as\n *                   successfully been sent, or rejected when sending the\n *                   message failed\n */\nAgent.prototype.send = function (to, message) {\n\n  var colon = to.indexOf(':');\n  if (colon !== -1) {\n    var url = URL.parse(to);\n\n    //TODO: Fix this for protocols that use networkId instead of host (Needs to be fixed in the protocol itself.)\n    return this._sendByProtocol(url.protocol.slice(0, -1), to, message);\n  }\n\n  // TODO: deprecate this notation \"agentId@transportId\"?\n  var at = to.indexOf('@');\n  if (at != -1) {\n    // to is an id like \"agentId@transportId\"\n    var _to = to.substring(0, at);\n    var _transportId = to.substring(at + 1);\n    return this._sendByTransportId(_transportId, _to, message);\n  }\n\n  // to is an id like \"agentId\". Send via the default transport\n  var conn = this.defaultConnection;\n  if (conn) {\n    return conn.send(to, message);\n  }\n  else {\n    return Promise.reject(new Error('No transport found'));\n  }\n};\n\n/**\n * Send a transport to an agent given a networkId\n * @param {string} networkId    A network id\n * @param {string} to           An agents id\n * @param {string} message      Message to be send\n * @return {Promise} Returns a promise which resolves when the message as\n *                   successfully been sent, or rejected when sending the\n *                   message failed\n * @private\n */\nAgent.prototype._sendByNetworkId = function (networkId, to, message) {\n  // TODO: change this.connections to a map with networkId as keys, much faster\n  for (var i = 0; i < this.connections.length; i++) {\n    var connection = this.connections[i];\n    if (connection.transport.networkId == networkId) {\n      return connection.send(to, message);\n    }\n  }\n\n  return Promise.reject(new Error('No transport found with networkId \"' + networkId + '\"'));\n};\n\n/**\n * Send a message by a transport by protocol.\n * The message will be send via the first found transport having the specified\n * protocol.\n * @param {string} protocol     A protocol, for example 'http' or 'ws'\n * @param {string} to           An agents id\n * @param {string} message      Message to be send\n * @return {Promise} Returns a promise which resolves when the message as\n *                   successfully been sent, or rejected when sending the\n *                   message failed\n * @private\n */\nAgent.prototype._sendByProtocol = function (protocol, to, message) {\n\n  // the https addresses also make use of the http protocol.\n  protocol = protocol == 'https' ? 'http' : protocol;\n\n  for (var i = 0; i < this.connections.length; i++) {\n    var connection = this.connections[i];\n    if (connection.transport.type == protocol) {\n      return connection.send(to, message);\n    }\n  }\n\n  return Promise.reject(new Error('No transport found for protocol \"' + protocol + '\"'));\n};\n\n/**\n * Send a transport to an agent via a specific transport\n * @param {string} transportId  The configured id of a transport.\n * @param {string} to           An agents id\n * @param {string} message      Message to be send\n * @return {Promise} Returns a promise which resolves when the message as\n *                   successfully been sent, or rejected when sending the\n *                   message failed\n * @private\n */\nAgent.prototype._sendByTransportId = function (transportId, to, message) {\n  for (var i = 0; i < this.connections.length; i++) {\n    var connection = this.connections[i];\n    if (connection.transport.id == transportId) {\n      return connection.send(to, message);\n    }\n  }\n\n  return Promise.reject(new Error('No transport found with id \"' + transportId + '\"'));\n};\n\n/**\n * Receive a message.\n * @param {string} from     Id of sender\n * @param {*} message       Received message, a JSON object (often a string)\n */\nAgent.prototype.receive = function (from, message, oobParams) {\n  // ... to be overloaded\n};\n\n/**\n * The method _receive is overloaded in a cascaded way by modules, and calls\n * the public method Agent.receive at the end of the chain.\n * @param {string} from     Id of sender\n * @param {*} message       Received message, a JSON object (often a string)\n * @param {array} oobParams Optional Out of Band parameters, e.g. query params for http\n * @returns {*} Returns the return value of Agent.receive\n * @private\n */\nAgent.prototype._receive = function (from, message, oobParams) {\n  return this.receive(from, message);\n};\n\nAgent.prototype.getUrls = function () {\n  return this.connections.map(function (connection) {\n    return connection.getMyUrl()\n  });\n};\n\nAgent.prototype.getUrlByProtocol = function (protocol) {\n  for (var i = 0; i < this.connections.length; i++) {\n    var connection = this.connections[i];\n    if (connection.transport.type == protocol) {\n      return connection.getMyUrl();\n    }\n  }\n};\n\n/**\n * Connect to a transport. The agent will subscribe itself to\n * messages sent to his id.\n * @param {string | Transport | Transport[] | string[]} transport\n *                                  A Transport instance, or the id of a\n *                                  transport loaded in eve.system.\n * @param {string} [id]             An optional alternative id to be used\n *                                  for the connection. By default, the agents\n *                                  own id is used.\n * @return {Connection | Connection[]}  Returns a connection or, in case of\n *                                      multiple transports, returns an\n *                                      array with connections. The connections\n *                                      have a promise .ready which resolves\n *                                      as soon as the connection is ready for\n *                                      use.\n */\nAgent.prototype.connect = function (transport, id) {\n  if (Array.isArray(transport)) {\n    var me = this;\n    return transport.map(function (_transport) {\n        try {\n          return me._connect(_transport, id);\n        } catch (e) {\n          return {error: e}\n        }\n      }\n    );\n  }\n  else if (typeof transport === 'string') {\n    // get transport by id\n    try {\n      return this._connect(Agent.getTransportById(transport), id);\n    } catch (e) {\n      return {error: e}\n    }\n  }\n  else {\n    // a transport instance\n    try {\n      return this._connect(transport, id);\n    } catch (e) {\n      return {error: e}\n    }\n  }\n};\n\n/**\n * Connect to a transport\n * @param {Transport} transport     A Transport instance\n * @param {string} [id]             An optional alternative id to be used\n *                                  for the connection. By default, the agents\n *                                  own id is used.\n * @return {Connection}             Returns a connection.\n * @private\n */\nAgent.prototype._connect = function (transport, id) {\n  // create a receive function which is bound to the _receive function.\n  // the _receive function can be replaced in by modules in a cascaded way,\n  // and in the end calls this.receive of the agent.\n  // note: we don't do receive = this._receive.bind(this) as the _receive\n  //       function can be overloaded after a connection is made.\n  var me = this;\n  var receive = function (from, message, oobParams) {\n    return me._receive(from, message, oobParams);\n  };\n  var connection = transport.connect(id || this.id, receive);\n  this.connections.push(connection);\n\n  // set or replace the defaultConnection\n  if (!this.defaultConnection) {\n    this.defaultConnection = connection;\n  }\n  else if (transport['default']) {\n    if (this.defaultConnection['default']) {\n      throw new Error('Cannot connect to a second default transport');\n    }\n    this.defaultConnection = connection;\n  }\n\n  this._updateReady();\n\n  return connection;\n};\n\n/**\n * Disconnect from one or multiple transports\n * @param {string | Transport | string[] | Transport[]} [transport]\n *              A transport or an array with transports.\n *              parameter transport can be an instance of a Transport, or the\n *              id of a transport.\n *              When transport is undefined, the agent will be disconnected\n *              from all connected transports.\n */\nAgent.prototype.disconnect = function (transport) {\n  var i, connection;\n\n  if (!transport) {\n    // disconnect all transports\n    while (connection = this.connections[0]) {\n      this._disconnect(connection);\n    }\n  }\n  else if (Array.isArray(transport)) {\n    // an array with transports\n    i = 0;\n    while (i < this.connections.length) {\n      connection = this.connections[i];\n      if (transport.indexOf(connection.transport) !== -1) {\n        this._disconnect(connection);\n      }\n      else {\n        i++;\n      }\n    }\n  }\n  else if (typeof transport === 'string') {\n    // transport by id\n    this.disconnect(Agent.getTransportById(transport));\n  }\n  else {\n    // a single transport\n    for (i = 0; i < this.connections.length; i++) {\n      connection = this.connections[i];\n      if (connection.transport === transport) {\n        this._disconnect(connection);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Close a connection\n * @param {Connection} connection\n * @private\n */\nAgent.prototype._disconnect = function (connection) {\n  // find the connection\n  var index = this.connections.indexOf(connection);\n  if (index !== -1) {\n    // close the connection\n    connection.close();\n\n    // remove from the list with connections\n    this.connections.splice(index, 1);\n\n    // replace the defaultConnection if needed\n    if (this.defaultConnection === connection) {\n      this.defaultConnection = this.connections[this.connections.length - 1] || null;\n    }\n  }\n\n  this._updateReady();\n};\n\n/**\n * Update the ready state of the agent\n * @private\n */\nAgent.prototype._updateReady = function () {\n  // FIXME: we should not replace with a new Promise,\n  //        we have a problem when this.ready is requested before ready,\n  //        and another connection is opened before ready\n  this.ready = Promise.all(this.connections.map(function (connection) {\n    return connection.ready;\n  }));\n};\n\nmodule.exports = Agent;\n\n},{\"./util\":28,\"promise\":52,\"url\":68,\"uuid-v4\":61}],22:[function(require,module,exports){\n'use strict';\n\nvar seed = require('seed-random');\nvar hypertimer = require('hypertimer');\nvar TransportManager = require('./TransportManager');\n\n// map with known configuration properties\nvar KNOWN_PROPERTIES = {\n  transports: true,\n  timer: true,\n  random: true\n};\n\nfunction ServiceManager(config) {\n  this.transports = new TransportManager();\n\n  this.timer = hypertimer();\n\n  this.random = Math.random;\n\n  this.init(config);\n}\n\n/**\n * Initialize the service manager with services loaded from a configuration\n * object. All current services are unloaded and removed.\n * @param {Object} config\n */\nServiceManager.prototype.init = function (config) {\n  this.transports.clear();\n\n  if (config) {\n    if (config.transports) {\n      this.transports.load(config.transports);\n    }\n\n    if (config.timer) {\n      this.timer.config(config.timer);\n    }\n\n    if (config.random) {\n      if (config.random.deterministic) {\n        var key = config.random.seed || 'random seed';\n        this.random = seed(key, config.random);\n      }\n      else {\n        this.random = Math.random;\n      }\n    }\n\n    for (var prop in config) {\n      if (config.hasOwnProperty(prop) && !KNOWN_PROPERTIES[prop]) {\n        // TODO: should log this warning via a configured logger\n        console.log('WARNING: Unknown configuration option \"' + prop + '\"')\n      }\n    }\n  }\n};\n\n/**\n * Clear all configured services\n */\nServiceManager.prototype.clear = function () {\n  this.transports.clear();\n};\n\nmodule.exports = ServiceManager;\n\n},{\"./TransportManager\":23,\"hypertimer\":31,\"seed-random\":60}],23:[function(require,module,exports){\n'use strict';\n\n/**\n * A manager for loading and finding transports.\n * @param {Array} [config]      Optional array containing configuration objects\n *                             for transports.\n * @constructor\n */\nfunction TransportManager(config) {\n  this.transports = [];\n\n  if (config) {\n    this.load(config);\n  }\n}\n\n// map with all registered types of transports\n// each transport must register itself at the TransportManager using registerType.\nTransportManager.types = {};\n\n/**\n * Register a new type of transport. This transport can then be loaded via\n * configuration.\n * @param {Transport.prototype} constructor     A transport constructor\n */\nTransportManager.registerType = function (constructor) {\n  var type = constructor.prototype.type;\n  if (typeof constructor !== 'function') {\n    throw new Error('Constructor function expected');\n  }\n  if (!type) {\n    throw new Error('Field \"prototype.type\" missing in transport constructor');\n  }\n  if (type in TransportManager.types) {\n    if (TransportManager.types[type] !== constructor) {\n      throw new Error('Transport type \"' + type + '\" already exists');\n    }\n  }\n\n  TransportManager.types[type] = constructor;\n};\n\n/**\n * Add a loaded transport to the manager\n * @param {Transport} transport\n * @return {Transport} returns the transport itself\n */\nTransportManager.prototype.add = function (transport) {\n  this.transports.push(transport);\n  return transport;\n};\n\n/**\n * Load one or multiple transports based on JSON configuration.\n * New transports will be appended to current transports.\n * @param {Object | Array} config\n * @return {Transport | Transport[]} Returns the loaded transport(s)\n */\nTransportManager.prototype.load = function (config) {\n  if (Array.isArray(config)) {\n    return config.map(this.load.bind(this));\n  }\n\n  var type = config.type;\n  if (!type) {\n    throw new Error('Property \"type\" missing');\n  }\n\n  var constructor = TransportManager.types[type];\n  if (!constructor) {\n    throw new Error('Unknown type of transport \"' + type + '\". ' +\n        'Choose from: ' + Object.keys(TransportManager.types).join(','))\n  }\n\n  var transport = new constructor(config);\n  this.transports.push(transport);\n  return transport;\n};\n\n/**\n * Unload a transport.\n * @param {Transport | Transport[] | string | string[]} transport\n *              A Transport instance or the id of a transport, or an Array\n *              with transports or transport ids.\n */\nTransportManager.prototype.unload = function (transport) {\n  var _transport;\n  if (typeof transport === 'string') {\n    _transport = this.get(transport);\n  }\n  else if (Array.isArray(transport)) {\n    for (var i = 0; i < transport.length; i++) {\n      this.unload(transport[i]);\n    }\n  }\n  else {\n    _transport = transport;\n  }\n\n  if (_transport) {\n    _transport.close();\n\n    var index = this.transports.indexOf(_transport);\n    if (index !== -1) {\n      this.transports.splice(index, 1);\n    }\n  }\n};\n\n/**\n * Get a transport by its id. The transport must have been created with an id\n * @param {string} [id] The id of a transport\n * @return {Transport} Returns the transport when found. Throws an error\n *                     when not found.\n */\nTransportManager.prototype.get = function (id) {\n  for (var i = 0; i < this.transports.length; i++) {\n    var transport = this.transports[i];\n    if (transport.id === id) {\n      return transport;\n    }\n  }\n\n  throw new Error('Transport with id \"' + id + '\" not found');\n};\n\n/**\n * Get all transports.\n * @return {Transport[]} Returns an array with all loaded transports.\n */\nTransportManager.prototype.getAll = function () {\n  return this.transports.concat([]);\n};\n\n/**\n * Find transports by type.\n * @param {string} [type]   Type of the transport. Choose from 'amqp',\n *                          'distribus', 'local', 'pubnub'.\n * @return {Transport[]}    When type is defined, the all transports of this\n *                          type are returned. When undefined, all transports\n *                          are returned.\n */\nTransportManager.prototype.getByType = function (type) {\n  if (type) {\n    if (!(type in TransportManager.types)) {\n      throw new Error('Unknown type of transport \"' + type + '\". ' +\n          'Choose from: ' + Object.keys(TransportManager.types).join(','))\n    }\n\n    return this.transports.filter(function (transport) {\n      return transport.type === type;\n    });\n  }\n  else {\n    return [].concat(this.transports);\n  }\n};\n\n/**\n * Close all configured transports and remove them from the manager.\n */\nTransportManager.prototype.clear = function () {\n  this.transports.forEach(function (transport) {\n    transport.close();\n  });\n  this.transports = [];\n};\n\nmodule.exports = TransportManager;\n\n},{}],24:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('promise');\n\n/**\n * An abstract Transport connection\n * @param {Transport} transport\n * @param {string} id\n * @param {function} receive\n * @constructor\n * @abstract\n */\nfunction Connection (transport, id, receive) {\n  throw new Error('Cannot create an abstract Connection');\n}\n\nConnection.prototype.ready = Promise.reject(new Error('Cannot get abstract property ready'));\n\n/**\n * Send a message to an agent.\n * @param {string} to\n * @param {*} message\n * @return {Promise} returns a promise which resolves when the message has been sent\n */\nConnection.prototype.send = function (to, message) {\n  throw new Error('Cannot call abstract function send');\n};\n\n/**\n * Close the connection, disconnect from the transport.\n */\nConnection.prototype.close = function () {\n  throw new Error('Cannot call abstract function \"close\"');\n};\n\nConnection.prototype.getMyUrl = function(){\n  return this.transport.type +\":\"+this.id;\n};\n\nmodule.exports = Connection;\n\n},{\"promise\":52}],25:[function(require,module,exports){\n'use strict';\n\n/**\n * Abstract prototype of a transport\n * @param {Object} [config]\n * @constructor\n */\nfunction Transport(config) {\n  this.id = config && config.id || null;\n  this['default'] = config && config['default'] || false;\n}\n\nTransport.prototype.type = null;\n\n/**\n * Connect an agent\n * @param {String} id\n * @param {Function} receive  Invoked as receive(from, message)\n * @return {Connection}       Returns a connection\n */\nTransport.prototype.connect = function(id, receive) {\n  throw new Error('Cannot invoke abstract function \"connect\"');\n};\n\n/**\n * Close the transport\n */\nTransport.prototype.close = function() {\n  throw new Error('Cannot invoke abstract function \"close\"');\n};\n\nmodule.exports = Transport;\n\n},{}],26:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('promise');\nvar Connection = require('../Connection');\n\n/**\n * A local connection.\n * @param {LocalTransport} transport\n * @param {string | number} id\n * @param {function} receive\n * @constructor\n */\nfunction LocalConnection(transport, id, receive) {\n  this.transport = transport;\n  this.id = id;\n\n  // register the agents receive function\n  if (this.id in this.transport.agents) {\n    throw new Error('Agent with id ' + id + ' already exists');\n  }\n  this.transport.agents[this.id] = receive;\n\n  // ready state\n  this.ready = Promise.resolve(this);\n}\n\nLocalConnection.prototype.getMyUrl = function(){\n  return this.transport.type +\":\"+this.id;\n};\n\n/**\n * Send a message to an agent.\n * @param {string} to\n * @param {*} message\n * @return {Promise} returns a promise which resolves when the message has been sent\n */\nLocalConnection.prototype.send = function (to, message) {\n  var query = to.replace(\"local:\",\"\").split(\"?\");\n  var callback = this.transport.agents[query[0]];\n  if (!callback) {\n    return Promise.reject(new Error('Agent with id ' + to + ' not found'));\n  }\n\n  var queryParams = query[1] ? query[1].split(\"&\"):[];\n  // invoke the agents receiver as callback(from, message, queryparameters)\n  callback(\"local:\"+this.id, message, queryParams);\n\n  return Promise.resolve();\n};\n\n/**\n * Close the connection\n */\nLocalConnection.prototype.close = function () {\n  delete this.transport.agents[this.id];\n};\n\nmodule.exports = LocalConnection;\n\n},{\"../Connection\":24,\"promise\":52}],27:[function(require,module,exports){\n'use strict';\n\nvar Transport = require('./../Transport');\nvar LocalConnection = require('./LocalConnection');\n\n/**\n * Create a local transport.\n * @param {Object} config         Config can contain the following properties:\n *                                - `id: string`. Optional\n * @constructor\n */\nfunction LocalTransport(config) {\n  this.id = config && config.id || null;\n  this.networkId = this.id || null;\n  this['default'] = config && config['default'] || false;\n  this.agents = {};\n}\n\nLocalTransport.prototype = new Transport();\n\nLocalTransport.prototype.type = 'local';\n\n/**\n * Connect an agent\n * @param {String} id\n * @param {Function} receive                  Invoked as receive(from, message)\n * @return {LocalConnection} Returns a promise which resolves when\n *                                                connected.\n */\nLocalTransport.prototype.connect = function(id, receive) {\n  return new LocalConnection(this, id, receive);\n};\n\n/**\n * Close the transport. Removes all agent connections.\n */\nLocalTransport.prototype.close = function() {\n  this.agents = {};\n};\n\nmodule.exports = LocalTransport;\n\n},{\"./../Transport\":25,\"./LocalConnection\":26}],28:[function(require,module,exports){\n'use strict';\n\n/**\n * Test whether the provided value is a Promise.\n * A value is marked as a Promise when it is an object containing functions\n * `then` and `catch`.\n * @param {*} value\n * @return {boolean} Returns true when `value` is a Promise\n */\nexports.isPromise = function (value) {\n  return value &&\n      typeof value['then'] === 'function' &&\n      typeof value['catch'] === 'function'\n};\n\n/**\n * Normalize a url. Removes trailing slash\n * @param {string} url\n * @return {string} Returns the normalized url\n */\nexports.normalizeURL = function (url) {\n  if (url[url.length - 1] == '/') {\n    return url.substring(0, url.length - 1);\n  }\n  else {\n    return url;\n  }\n};\n\n},{}],29:[function(require,module,exports){\n'use strict';\n\nvar isEmpty = require('es5-ext/object/is-empty')\n  , value   = require('es5-ext/object/valid-value')\n\n  , hasOwnProperty = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (obj/*, type*/) {\n\tvar type;\n\tvalue(obj);\n\ttype = arguments[1];\n\tif (arguments.length > 1) {\n\t\treturn hasOwnProperty.call(obj, '__ee__') && Boolean(obj.__ee__[type]);\n\t}\n\treturn obj.hasOwnProperty('__ee__') && !isEmpty(obj.__ee__);\n};\n\n},{\"es5-ext/object/is-empty\":9,\"es5-ext/object/valid-value\":16}],30:[function(require,module,exports){\n'use strict';\n\nvar d        = require('d')\n  , callable = require('es5-ext/object/valid-callable')\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n\n},{\"d\":3,\"es5-ext/object/valid-callable\":15}],31:[function(require,module,exports){\nmodule.exports = require('./lib/hypertimer');\n\n},{\"./lib/hypertimer\":34}],32:[function(require,module,exports){\nmodule.exports = (typeof window === 'undefined' || typeof window.Promise === 'undefined') ?\n    require('promise') :\n    window.Promise;\n\n},{\"promise\":45}],33:[function(require,module,exports){\nvar Debug = typeof window !== 'undefined' ? window.Debug : require('debug');\n\nmodule.exports = Debug || function () {\n  // empty stub when in the browser\n  return function () {};\n};\n\n},{\"debug\":42}],34:[function(require,module,exports){\nvar emitter = require('event-emitter');\nvar hasListeners = require('event-emitter/has-listeners');\nvar createMaster = require('./synchronization/master').createMaster;\nvar createSlave = require('./synchronization/slave').createSlave;\nvar util = require('./util');\n\n// enum for type of timeout\nvar TYPE = {\n  TIMEOUT: 0,\n  INTERVAL: 1,\n  TRIGGER: 2\n};\n\n/**\n * Create a new hypertimer\n * @param {Object} [options]  The following options are available:\n *                            deterministic: boolean\n *                                        If true (default), simultaneous events\n *                                        are executed in a deterministic order.\n *                            paced: boolean\n *                                        Mode for pacing of time. When paced,\n *                                        the time proceeds at a continuous,\n *                                        configurable rate, useful for\n *                                        animation purposes. When unpaced, the\n *                                        time jumps immediately from scheduled\n *                                        event to the next scheduled event.\n *                            rate: number\n *                                        The rate of progress of time with\n *                                        respect to real-time. Rate must be a\n *                                        positive number, and is 1 by default.\n *                                        For example when 2, the time of the\n *                                        hypertimer runs twice as fast as\n *                                        real-time.\n *                                        Only applicable when option paced=true.\n *                            time: number | Date | String\n *                                        Set a simulation time. If not provided,\n *                                        The timer is instantiated with the\n *                                        current system time.\n */\nfunction hypertimer(options) {\n  // options\n  var paced = true;\n  var rate = 1;             // number of milliseconds per milliseconds\n  var deterministic = true; // run simultaneous events in a deterministic order\n  var configuredTime = null;// only used for returning the configured time on .config()\n  var master = null;        // url of master, will run as slave\n  var port = null;          // port to serve as master\n\n  // properties\n  var running = false;              // true when running\n  var startTime = null;             // timestamp. the moment in real-time when hyperTime was set\n  var hyperTime = util.systemNow(); // timestamp. the start time in hyper-time\n  var timeouts = [];                // array with all running timeouts\n  var current = {};                 // the timeouts currently in progress (callback is being executed)\n  var timeoutId = null;             // currently running timer\n  var idSeq = 0;                    // counter for unique timeout id's\n  var server = null;\n  var client = null;\n\n  // exported timer object with public functions and variables\n  // add event-emitter mixin\n  var timer = emitter({});\n\n  /**\n   * Change configuration options of the hypertimer, or retrieve current\n   * configuration.\n   * @param {Object} [options]  The following options are available:\n   *                            deterministic: boolean\n   *                                        If true (default), simultaneous events\n   *                                        are executed in a deterministic order.\n   *                            paced: boolean\n   *                                        Mode for pacing of time. When paced,\n   *                                        the time proceeds at a continuous,\n   *                                        configurable rate, useful for\n   *                                        animation purposes. When unpaced, the\n   *                                        time jumps immediately from scheduled\n   *                                        event to the next scheduled event.\n   *                            rate: number\n   *                                        The rate of progress of time with\n   *                                        respect to real-time. Rate must be a\n   *                                        positive number, and is 1 by default.\n   *                                        For example when 2, the time of the\n   *                                        hypertimer runs twice as fast as\n   *                                        real-time.\n   *                                        Only applicable when option paced=true.\n   *                            time: number | Date | String\n   *                                        Set a simulation time.\n   * @return {Object} Returns the applied configuration\n   */\n  timer.config = function(options) {\n    if (options) {\n      _validateConfig(options);\n      _setConfig(options);\n    }\n\n    // return a copy of the configuration options\n    return _getConfig();\n  };\n\n  /**\n   * Returns the current time of the timer as a number.\n   * See also getTime().\n   * @return {number} The time\n   */\n  timer.now = function () {\n    if (paced) {\n      if (running) {\n        // TODO: implement performance.now() / process.hrtime(time) for high precision calculation of time interval\n        var realInterval = util.systemNow() - startTime;\n        var hyperInterval = realInterval * rate;\n        return hyperTime + hyperInterval;\n      }\n      else {\n        return hyperTime;\n      }\n    }\n    else {\n      return hyperTime;\n    }\n  };\n\n  /**\n   * Continue the timer.\n   */\n  timer['continue'] = function() {\n    startTime = util.systemNow();\n    running = true;\n\n    // reschedule running timeouts\n    _schedule();\n  };\n\n  /**\n   * Pause the timer. The timer can be continued again with `continue()`\n   */\n  timer.pause = function() {\n    hyperTime = timer.now();\n    startTime = null;\n    running = false;\n\n    // reschedule running timeouts (pauses them)\n    _schedule();\n  };\n\n  /**\n   * Returns the current time of the timer as Date.\n   * See also now().\n   * @return {Date} The time\n   */\n  timer.getTime = function() {\n    return new Date(timer.now());\n  };\n\n  /**\n   * Get the value of the hypertimer. This function returns the result of getTime().\n   * @return {Date} current time\n   */\n  timer.valueOf = timer.getTime;\n\n  /**\n   * Return a string representation of the current hyper-time.\n   * @returns {string} String representation\n   */\n  timer.toString = function () {\n    return timer.getTime().toString();\n  };\n\n  /**\n   * Set a timeout, which is triggered when the timeout occurs in hyper-time.\n   * See also setTrigger.\n   * @param {Function} callback   Function executed when delay is exceeded.\n   * @param {number} delay        The delay in milliseconds. When the delay is\n   *                              smaller or equal to zero, the callback is\n   *                              triggered immediately.\n   * @return {number} Returns a timeoutId which can be used to cancel the\n   *                  timeout using clearTimeout().\n   */\n  timer.setTimeout = function(callback, delay) {\n    var id = idSeq++;\n    var timestamp = timer.now() + delay;\n    if (isNaN(timestamp)) {\n      throw new TypeError('delay must be a number');\n    }\n\n    // add a new timeout to the queue\n    _queueTimeout({\n      id: id,\n      type: TYPE.TIMEOUT,\n      time: timestamp,\n      callback: callback\n    });\n\n    // reschedule the timeouts\n    _schedule();\n\n    return id;\n  };\n\n  /**\n   * Set a trigger, which is triggered when the timeout occurs in hyper-time.\n   * See also getTimeout.\n   * @param {Function} callback   Function executed when timeout occurs.\n   * @param {Date | number | string } time\n   *                              An absolute moment in time (Date) when the\n   *                              callback will be triggered. When the date is\n   *                              a Date in the past, the callback is triggered\n   *                              immediately.\n   * @return {number} Returns a triggerId which can be used to cancel the\n   *                  trigger using clearTrigger().\n   */\n  timer.setTrigger = function (callback, time) {\n    var id = idSeq++;\n    var timestamp = toTimestamp(time);\n\n    // add a new timeout to the queue\n    _queueTimeout({\n      id: id,\n      type: TYPE.TRIGGER,\n      time: timestamp,\n      callback: callback\n    });\n\n    // reschedule the timeouts\n    _schedule();\n\n    return id;\n  };\n\n\n  /**\n   * Trigger a callback every interval. Optionally, a start date can be provided\n   * to specify the first time the callback must be triggered.\n   * See also setTimeout and setTrigger.\n   * @param {Function} callback         Function executed when delay is exceeded.\n   * @param {number} interval           Interval in milliseconds. When interval\n   *                                    is smaller than zero or is infinity, the\n   *                                    interval will be set to zero and triggered\n   *                                    with a maximum rate.\n   * @param {Date | number | string} [firstTime]\n   *                                    An absolute moment in time (Date) when the\n   *                                    callback will be triggered the first time.\n   *                                    By default, firstTime = now() + interval.\n   * @return {number} Returns a intervalId which can be used to cancel the\n   *                  trigger using clearInterval().\n   */\n  timer.setInterval = function(callback, interval, firstTime) {\n    var id = idSeq++;\n\n    var _interval = Number(interval);\n    if (isNaN(_interval)) {\n      throw new TypeError('interval must be a number');\n    }\n    if (_interval < 0 || !isFinite(_interval)) {\n      _interval = 0;\n    }\n\n    var _firstTime = (firstTime != undefined) ?\n        toTimestamp(firstTime) :\n        null;\n\n    var now = timer.now();\n    var _time = (_firstTime != null) ? _firstTime : (now + _interval);\n\n    var timeout = {\n      id: id,\n      type: TYPE.INTERVAL,\n      interval: _interval,\n      time: _time,\n      firstTime: _firstTime != null ? _firstTime : _time,\n      occurrence: 0,\n      callback: callback\n    };\n\n    if (_time < now) {\n      // update schedule when in the past\n      _rescheduleInterval(timeout, now);\n    }\n\n    // add a new timeout to the queue\n    _queueTimeout(timeout);\n\n    // reschedule the timeouts\n    _schedule();\n\n    return id;\n  };\n\n  /**\n   * Cancel a timeout\n   * @param {number} timeoutId   The id of a timeout\n   */\n  timer.clearTimeout = function(timeoutId) {\n    // test whether timeout is currently being executed\n    if (current[timeoutId]) {\n      delete current[timeoutId];\n      return;\n    }\n\n    // find the timeout in the queue\n    for (var i = 0; i < timeouts.length; i++) {\n      if (timeouts[i].id === timeoutId) {\n        // remove this timeout from the queue\n        timeouts.splice(i, 1);\n\n        // reschedule timeouts\n        _schedule();\n        break;\n      }\n    }\n  };\n\n  /**\n   * Cancel a trigger\n   * @param {number} triggerId   The id of a trigger\n   */\n  timer.clearTrigger = timer.clearTimeout;\n\n  timer.clearInterval = timer.clearTimeout;\n\n  /**\n   * Returns a list with the id's of all timeouts\n   * @returns {number[]} Timeout id's\n   */\n  timer.list = function () {\n    return timeouts.map(function (timeout) {\n      return timeout.id;\n    });\n  };\n\n  /**\n   * Clear all timeouts\n   */\n  timer.clear = function () {\n    // empty the queue\n    current = {};\n    timeouts = [];\n\n    // reschedule\n    _schedule();\n  };\n\n  /**\n   * Destroy the timer. This will clear all timeouts, and close connections\n   * to a master or to slave timers.\n   */\n  timer.destroy = function () {\n    timer.clear();\n    if (client) client.destroy();\n    if (server) server.destroy();\n  };\n\n  /**\n   * Get the current configuration\n   * @returns {{paced: boolean, rate: number, deterministic: boolean, time: *, master: *}}\n   *                Returns a copy of the current configuration\n   * @private\n   */\n  function _getConfig () {\n    return {\n      paced: paced,\n      rate: rate,\n      deterministic: deterministic,\n      time: configuredTime,\n      master: master,\n      port: port\n    }\n  }\n\n  /**\n   * Validate configuration, depending on the current mode: slave or normal\n   * @param {Object} options\n   * @private\n   */\n  function _validateConfig (options) {\n    // validate writable options\n    if (client || options.master) {\n      // when we are a slave, we can't adjust the config, except for\n      // changing the master url or becoming a master itself (port configured)\n      for (var prop in options) {\n        if (prop !== 'master' && prop !== 'slave') {\n          throw new Error('Cannot apply configuration option \"'  + prop +'\", timer is configured as slave.');\n        }\n      }\n    }\n  }\n\n  /**\n   * Change configuration\n   * @param {{paced: boolean, rate: number, deterministic: boolean, time: *, master: *}} options\n   * @private\n   */\n  function _setConfig(options) {\n    if ('deterministic' in options) {\n      deterministic = options.deterministic ? true : false;\n    }\n\n    if ('paced' in options) {\n      paced = options.paced ? true : false;\n    }\n\n    // important: apply time before rate\n    if ('time' in options) {\n      hyperTime = toTimestamp(options.time);\n      startTime = util.systemNow();\n\n      // update intervals\n      _rescheduleIntervals(hyperTime);\n\n      configuredTime = new Date(hyperTime).toISOString();\n    }\n\n    if ('rate' in options) {\n      var newRate = Number(options.rate);\n      if (isNaN(newRate) || newRate <= 0) {\n        throw new TypeError('Invalid rate ' + JSON.stringify(options.rate) + '. Rate must be a positive number');\n      }\n\n      // important: first get the new hyperTime, then adjust the startTime\n      hyperTime = timer.now();\n      startTime = util.systemNow();\n      rate = newRate;\n    }\n\n    if ('master' in options) {\n      // create a timesync slave, connect to master via a websocket\n      if (client) {\n        client.destroy();\n        client = null;\n      }\n\n      master = options.master;\n      if (options.master != null) {\n        client = createSlave(options.master);\n\n        function applyConfig(config) {\n          var prev = _getConfig();\n          _setConfig(config);\n          var curr = _getConfig();\n          timer.emit('config', curr, prev);\n        }\n\n        client.on('change', function (time)   { applyConfig({time: time}) });\n        client.on('config', function (config) { applyConfig(config) });\n        client.on('error',  function (err)    { timer.emit('error', err) });\n      }\n    }\n\n    // create a master\n    if ('port' in options) {\n      if (server) {\n        server.destroy();\n        server = null;\n      }\n\n      port = options.port;\n      if (options.port) {\n        server = createMaster(timer.now, timer.config, options.port);\n        server.on('error', function (err) { timer.emit('error', err) });\n      }\n    }\n\n    // reschedule running timeouts\n    _schedule();\n\n    if (server) {\n      // broadcast changed config\n      server.broadcastConfig();\n    }\n  }\n\n  /**\n   * Reschedule all intervals after a new time has been set.\n   * @param {number} now\n   * @private\n   */\n  function _rescheduleIntervals(now) {\n    for (var i = 0; i < timeouts.length; i++) {\n      var timeout = timeouts[i];\n      if (timeout.type === TYPE.INTERVAL) {\n        _rescheduleInterval(timeout, now);\n      }\n    }\n  }\n\n  /**\n   * Reschedule the intervals after a new time has been set.\n   * @param {Object} timeout\n   * @param {number} now\n   * @private\n   */\n  function _rescheduleInterval(timeout, now) {\n    timeout.occurrence = Math.round((now - timeout.firstTime) / timeout.interval);\n    timeout.time = timeout.firstTime + timeout.occurrence * timeout.interval;\n  }\n\n  /**\n   * Add a timeout to the queue. After the queue has been changed, the queue\n   * must be rescheduled by executing _reschedule()\n   * @param {{id: number, type: number, time: number, callback: Function}} timeout\n   * @private\n   */\n  function _queueTimeout(timeout) {\n    // insert the new timeout at the right place in the array, sorted by time\n    if (timeouts.length > 0) {\n      var i = timeouts.length - 1;\n      while (i >= 0 && timeouts[i].time > timeout.time) {\n        i--;\n      }\n\n      // insert the new timeout in the queue. Note that the timeout is\n      // inserted *after* existing timeouts with the exact *same* time,\n      // so the order in which they are executed is deterministic\n      timeouts.splice(i + 1, 0, timeout);\n    }\n    else {\n      // queue is empty, append the new timeout\n      timeouts.push(timeout);\n    }\n  }\n\n  /**\n   * Execute a timeout\n   * @param {{id: number, type: number, time: number, callback: function}} timeout\n   * @param {function} [callback]\n   *             The callback is executed when the timeout's callback is\n   *             finished. Called without parameters\n   * @private\n   */\n  function _execTimeout(timeout, callback) {\n    // store the timeout in the queue with timeouts in progress\n    // it can be cleared when a clearTimeout is executed inside the callback\n    current[timeout.id] = timeout;\n\n    function finish() {\n      // in case of an interval we have to reschedule on next cycle\n      // interval must not be cleared while executing the callback\n      if (timeout.type === TYPE.INTERVAL && current[timeout.id]) {\n        timeout.occurrence++;\n        timeout.time = timeout.firstTime + timeout.occurrence * timeout.interval;\n        _queueTimeout(timeout);\n        //console.log('queue timeout', timer.getTime().toISOString(), new Date(timeout.time).toISOString(), timeout.occurrence) // TODO: cleanup\n      }\n\n      // remove the timeout from the queue with timeouts in progress\n      delete current[timeout.id];\n\n      callback && callback();\n    }\n\n    // execute the callback\n    try {\n      if (timeout.callback.length == 0) {\n        // synchronous timeout,  like `timer.setTimeout(function () {...}, delay)`\n        timeout.callback();\n        finish();\n      } else {\n        // asynchronous timeout, like `timer.setTimeout(function (done) {...; done(); }, delay)`\n        timeout.callback(finish);\n      }\n    } catch (err) {\n      // emit or log the error\n      if (hasListeners(timer, 'error')) {\n        timer.emit('error', err);\n      }\n      else {\n        console.log('Error', err);\n      }\n\n      finish();\n    }\n  }\n\n  /**\n   * Remove all timeouts occurring before or on the provided time from the\n   * queue and return them.\n   * @param {number} time    A timestamp\n   * @returns {Array} returns an array containing all expired timeouts\n   * @private\n   */\n  function _getExpiredTimeouts(time) {\n    var i = 0;\n    while (i < timeouts.length && ((timeouts[i].time <= time) || !isFinite(timeouts[i].time))) {\n      i++;\n    }\n    var expired = timeouts.splice(0, i);\n\n    if (deterministic == false) {\n      // the array with expired timeouts is in deterministic order\n      // shuffle them\n      util.shuffle(expired);\n    }\n\n    return expired;\n  }\n\n  /**\n   * Reschedule all queued timeouts\n   * @private\n   */\n  function _schedule() {\n    // do not _schedule when there are timeouts in progress\n    // this can be the case with async timeouts in non-paced mode.\n    // _schedule will be executed again when all async timeouts are finished.\n    if (!paced && Object.keys(current).length > 0) {\n      return;\n    }\n\n    var next = timeouts[0];\n\n    // cancel timer when running\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (running && next) {\n      // schedule next timeout\n      var time = next.time;\n      var delay = time - timer.now();\n      var realDelay = paced ? delay / rate : 0;\n\n      function onTimeout() {\n        // when running in non-paced mode, update the hyperTime to\n        // adjust the time of the current event\n        if (!paced) {\n          hyperTime = (time > hyperTime && isFinite(time)) ? time : hyperTime;\n        }\n\n        // grab all expired timeouts from the queue\n        var expired = _getExpiredTimeouts(time);\n        // note: expired.length can never be zero (on every change of the queue, we reschedule)\n\n        // execute all expired timeouts\n        if (paced) {\n          // in paced mode, we fire all timeouts in parallel,\n          // and don't await their completion (they can do async operations)\n          expired.forEach(function (timeout) {\n            _execTimeout(timeout);\n          });\n\n          // schedule the next round\n          _schedule();\n        }\n        else {\n          // in non-paced mode, we execute all expired timeouts serially,\n          // and wait for their completion in order to guarantee deterministic\n          // order of execution\n          function next() {\n            var timeout = expired.shift();\n            if (timeout) {\n              _execTimeout(timeout, next);\n            }\n            else {\n              // schedule the next round\n              _schedule();\n            }\n          }\n          next();\n        }\n      }\n\n      timeoutId = setTimeout(onTimeout, Math.round(realDelay));\n      // Note: Math.round(realDelay) is to defeat a bug in node.js v0.10.30,\n      //       see https://github.com/joyent/node/issues/8065\n    }\n  }\n\n  /**\n   * Convert a Date, number, or ISOString to a number timestamp,\n   * and validate whether it's a valid Date. The number Infinity is also\n   * accepted as a valid timestamp\n   * @param {Date | number | string} date\n   * @return {number} Returns a unix timestamp, a number\n   */\n  function toTimestamp(date) {\n    var value =\n        (typeof date === 'number') ? date :           // number\n        (date instanceof Date)     ? date.valueOf() : // Date\n        new Date(date).valueOf();                     // ISOString, momentjs, ...\n\n    if (isNaN(value)) {\n      throw new TypeError('Invalid date ' + JSON.stringify(date) + '. ' +\n          'Date, number, or ISOString expected');\n    }\n\n    return value;\n  }\n\n  Object.defineProperty(timer, 'running', {\n    get: function () {\n      return running;\n    }\n  });\n\n  timer.config(options);  // apply options\n  timer.continue();       // start the timer\n\n  return timer;\n}\n\nmodule.exports = hypertimer;\n\n},{\"./synchronization/master\":36,\"./synchronization/slave\":37,\"./util\":41,\"event-emitter\":30,\"event-emitter/has-listeners\":29}],35:[function(require,module,exports){\nmodule.exports = (typeof window === 'undefined' || typeof window.WebSocket === 'undefined') ?\n    require('ws') :\n    window.WebSocket;\n\n},{\"ws\":62}],36:[function(require,module,exports){\nvar WebSocket = require('./WebSocket');\nvar emitter = require('./socket-emitter');\nvar debug = require('../debug')('hypertimer:master');\n\nexports.createMaster = function (now, config, port) {\n  var master = new WebSocket.Server({port: port});\n\n  master.on('connection', function (ws) {\n    debug('new connection');\n\n    var _emitter = emitter(ws);\n\n    // ping timesync messages (for the timesync module)\n    _emitter.on('time', function (data, callback) {\n      var time = now();\n      callback(time);\n      debug('send time ' + new Date(time).toISOString());\n    });\n\n    // send the masters config to the new connection\n    var config = sanitizedConfig();\n    debug('send config', config);\n    _emitter.send('config', config);\n\n    ws.emitter = _emitter; // used by broadcast\n  });\n\n  master.broadcast = function (event, data) {\n    debug('broadcast', event, data);\n    master.clients.forEach(function (client) {\n      client.emitter.send(event, data);\n    });\n  };\n\n  master.broadcastConfig = function () {\n    master.broadcast('config', sanitizedConfig());\n  };\n\n  master.destroy = function() {\n    master.close();\n    debug('destroyed');\n  };\n\n  function sanitizedConfig() {\n    var curr = config();\n    delete curr.time;\n    delete curr.master;\n    delete curr.port;\n    return curr;\n  }\n\n  debug('listening at ws://localhost:' + port);\n\n  return master;\n};\n\n},{\"../debug\":33,\"./WebSocket\":35,\"./socket-emitter\":38}],37:[function(require,module,exports){\nvar WebSocket = require('./WebSocket');\nvar Promise = require('../Promise');\nvar debug = require('../debug')('hypertimer:slave');\nvar emitter = require('./socket-emitter');\nvar stat = require('./stat');\nvar util = require('./util');\n\n// TODO: make these constants configurable\nvar INTERVAL = 3600000; // once an hour\nvar DELAY = 1000;       // delay between individual requests\nvar REPEAT = 5;         // number of times to request the time for determining latency\n\nexports.createSlave = function (url) {\n  var ws = new WebSocket(url);\n  var slave = emitter(ws);\n  var isFirst = true;\n  var isDestroyed = false;\n  var syncTimer = null;\n\n  ws.onopen = function () {\n    debug('connected');\n    sync();\n    syncTimer = setInterval(sync, INTERVAL);\n  };\n\n  slave.destroy = function () {\n    isDestroyed = true;\n\n    clearInterval(syncTimer);\n    syncTimer = null;\n\n    ws.close();\n\n    debug('destroyed');\n  };\n\n  /**\n   * Sync with the time of the master. Emits a 'change' message\n   * @private\n   */\n  function sync() {\n    // retrieve latency, then wait 1 sec\n    function getLatencyAndWait() {\n      var result = null;\n\n      if (isDestroyed) {\n        return Promise.resolve(result);\n      }\n\n      return getLatency(slave)\n          .then(function (latency) { result = latency })  // store the retrieved latency\n          .catch(function (err)    { console.log(err) })  // just log failed requests\n          .then(function () { return util.wait(DELAY) })  // wait 1 sec\n          .then(function () { return result});            // return the retrieved latency\n    }\n\n    return util\n        .repeat(getLatencyAndWait, REPEAT)\n        .then(function (all) {\n          debug('latencies', all);\n\n          // filter away failed requests\n          var latencies = all.filter(function (latency) {\n            return latency !== null;\n          });\n\n          // calculate the limit for outliers\n          var limit = stat.median(latencies) + stat.std(latencies);\n\n          // filter away outliers: all latencies largereq than the mean+std\n          var filtered = latencies.filter(function (latency) {\n            return latency < limit;\n          });\n\n          // return the mean latency\n          return (filtered.length > 0) ? stat.mean(filtered) : null;\n        })\n        .then(function (latency) {\n          if (isDestroyed) {\n            return Promise.resolve(null);\n          }\n          else {\n            return slave.request('time').then(function (timestamp) {\n              var time = timestamp + latency;\n              slave.emit('change', time);\n              return time;\n            });\n          }\n        })\n        .catch(function (err) {\n          slave.emit('error', err)\n        });\n  }\n\n  /**\n   * Request the time of the master and calculate the latency from the\n   * roundtrip time\n   * @param {{request: function}} emitter\n   * @returns {Promise.<number | null>} returns the latency\n   * @private\n   */\n  function getLatency(emitter) {\n    var start = Date.now();\n\n    return emitter.request('time')\n        .then(function (timestamp) {\n          var end = Date.now();\n          var latency = (end - start) / 2;\n          var time = timestamp + latency;\n\n          // apply the first ever retrieved offset immediately.\n          if (isFirst) {\n            isFirst = false;\n            emitter.emit('change', time);\n          }\n\n          return latency;\n        })\n  }\n\n  return slave;\n};\n\n\n},{\"../Promise\":32,\"../debug\":33,\"./WebSocket\":35,\"./socket-emitter\":38,\"./stat\":39,\"./util\":40}],38:[function(require,module,exports){\n// Turn a WebSocket in an event emitter.\nvar eventEmitter = require('event-emitter');\nvar Promise = require('./../Promise');\nvar debug = require('../debug')('hypertimer:socket');\n\nvar TIMEOUT = 60000; // ms\n// TODO: make timeout a configuration setting\n\nmodule.exports = function (socket) {\n  var emitter = eventEmitter({\n    socket: socket,\n    send: send,\n    request: request\n  });\n\n  /**\n   * Send an event\n   * @param {string} event\n   * @param {*} data\n   */\n  function send (event, data) {\n    var envelope = {\n      event: event,\n      data: data\n    };\n    debug('send', envelope);\n    socket.send(JSON.stringify(envelope));\n  }\n\n  /**\n   * Request an event, await a response\n   * @param {string} event\n   * @param {*} data\n   * @return {Promise} Returns a promise which resolves with the reply\n   */\n  function request (event, data) {\n    return new Promise(function (resolve, reject) {\n      // put the data in an envelope with id\n      var id = getId();\n      var envelope = {\n        event: event,\n        id: id,\n        data: data\n      };\n\n      // add the request to the list with requests in progress\n      queue[id] = {\n        resolve: resolve,\n        reject: reject,\n        timeout: setTimeout(function () {\n          delete queue[id];\n          reject(new Error('Timeout'));\n        }, TIMEOUT)\n      };\n\n      debug('request', envelope);\n      socket.send(JSON.stringify(envelope));\n    }).catch(function (err) {console.log('ERROR', err)});\n  }\n\n  /**\n   * Event handler, handles incoming messages\n   * @param {Object} event\n   */\n  socket.onmessage = function (event) {\n    var data = event.data;\n    var envelope = JSON.parse(data);\n    debug('receive', envelope);\n\n    // match the request from the id in the response\n    var request = queue[envelope.id];\n    if (request) {\n      // incoming response\n      clearTimeout(request.timeout);\n      delete queue[envelope.id];\n      request.resolve(envelope.data);\n    }\n    else if ('id' in envelope) {\n      // incoming request\n      emitter.emit(envelope.event, envelope.data, function (reply) {\n        var response = {\n          id: envelope.id,\n          data: reply\n        };\n\n        if (socket.readyState === socket.OPEN || socket.readyState === socket.CONNECTING) {\n          debug('reply', response);\n          socket.send(JSON.stringify(response));\n        }\n        else {\n          debug('cancel reply', response, '(socket is closed)');\n        }\n      });\n    }\n    else {\n      // regular incoming message\n      emitter.emit(envelope.event, envelope.data);\n    }\n  };\n\n  var queue = {};   // queue with requests in progress\n\n  // get a unique id (simple counter)\n  function getId () {\n    return _id++;\n  }\n  var _id = 0;\n\n  return emitter;\n};\n\n},{\"../debug\":33,\"./../Promise\":32,\"event-emitter\":30}],39:[function(require,module,exports){\n// basic statistical functions\n\nexports.compare = function (a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n};\n\nexports.add = function (a, b) {\n  return a + b;\n};\n\nexports.sum = function (arr) {\n  return arr.reduce(exports.add);\n};\n\nexports.mean = function (arr) {\n  return exports.sum(arr) / arr.length;\n};\n\nexports.std = function (arr) {\n  return Math.sqrt(exports.variance(arr));\n};\n\nexports.variance = function (arr) {\n  if (arr.length < 2) return 0;\n\n  var _mean = exports.mean(arr);\n  return arr\n          .map(function (x) {\n            return Math.pow(x - _mean, 2)\n          })\n          .reduce(exports.add) / (arr.length - 1);\n};\n\nexports.median = function (arr) {\n  if (arr.length < 2) return arr[0];\n\n  var sorted = arr.slice().sort(exports.compare);\n  if (sorted.length % 2 === 0) {\n    // even\n    return (arr[arr.length / 2 - 1] + arr[arr.length / 2]) / 2;\n  }\n  else {\n    // odd\n    return arr[(arr.length - 1) / 2];\n  }\n};\n\n},{}],40:[function(require,module,exports){\nvar Promise = require('../Promise');\n\n/**\n * Resolve a promise after a delay\n * @param {number} delay    A delay in milliseconds\n * @returns {Promise} Resolves after given delay\n */\nexports.wait = function(delay) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, delay);\n  });\n};\n\n/**\n * Repeat a given asynchronous function a number of times\n * @param {function} fn   A function returning a promise\n * @param {number} times\n * @return {Promise}\n */\nexports.repeat = function (fn, times) {\n  return new Promise(function (resolve, reject) {\n    var count = 0;\n    var results = [];\n\n    function recurse() {\n      if (count < times) {\n        count++;\n        fn().then(function (result) {\n          results.push(result);\n          recurse();\n        })\n      }\n      else {\n        resolve(results);\n      }\n    }\n\n    recurse();\n  });\n};\n\n/**\n * Repeat an asynchronous callback function whilst\n * @param {function} condition   A function returning true or false\n * @param {function} callback    A callback returning a Promise\n * @returns {Promise}\n */\nexports.whilst = function (condition, callback) {\n  return new Promise(function (resolve, reject) {\n    function recurse() {\n      if (condition()) {\n        callback().then(function () {\n          recurse()\n        });\n      }\n      else {\n        resolve();\n      }\n    }\n\n    recurse();\n  });\n};\n\n},{\"../Promise\":32}],41:[function(require,module,exports){\n\n/* istanbul ignore else */\nif (typeof Date.now === 'function') {\n  /**\n   * Helper function to get the current time\n   * @return {number} Current time\n   */\n  exports.systemNow = function () {\n    return Date.now();\n  }\n}\nelse {\n  /**\n   * Helper function to get the current time\n   * @return {number} Current time\n   */\n  exports.systemNow = function () {\n    return new Date().valueOf();\n  }\n}\n\n/**\n * Shuffle an array\n *\n * + Jonas Raoni Soares Silva\n * @ http://jsfromhell.com/array/shuffle [v1.0]\n *\n * @param {Array} o   Array to be shuffled\n * @returns {Array}   Returns the shuffled array\n */\nexports.shuffle = function (o){\n  for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);\n  return o;\n};\n\n},{}],42:[function(require,module,exports){\n(function (process){\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n}).call(this,require('_process'))\n},{\"./common\":43,\"_process\":63}],43:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n},{\"ms\":44}],44:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n},{}],45:[function(require,module,exports){\n'use strict';\n\nmodule.exports = require('./lib')\n\n},{\"./lib\":50}],46:[function(require,module,exports){\n'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._37 = 0;\n  this._12 = null;\n  this._59 = [];\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._99 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._37 === 3) {\n    self = self._12;\n  }\n  if (self._37 === 0) {\n    self._59.push(deferred);\n    return;\n  }\n  asap(function() {\n    var cb = self._37 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._37 === 1) {\n        resolve(deferred.promise, self._12);\n      } else {\n        reject(deferred.promise, self._12);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._12);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._37 = 3;\n      self._12 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._37 = 1;\n  self._12 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._37 = 2;\n  self._12 = newValue;\n  finale(self);\n}\nfunction finale(self) {\n  for (var i = 0; i < self._59.length; i++) {\n    handle(self, self._59[i]);\n  }\n  self._59 = null;\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n},{\"asap/raw\":2}],47:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this;\n  self.then(null, function (err) {\n    setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\n\n},{\"./core.js\":46}],48:[function(require,module,exports){\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._99);\n  p._37 = 1;\n  p._12 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._37 === 3) {\n            val = val._12;\n          }\n          if (val._37 === 1) return res(i, val._12);\n          if (val._37 === 2) reject(val._12);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n},{\"./core.js\":46}],49:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.prototype['finally'] = function (f) {\n  return this.then(function (value) {\n    return Promise.resolve(f()).then(function () {\n      return value;\n    });\n  }, function (err) {\n    return Promise.resolve(f()).then(function () {\n      throw err;\n    });\n  });\n};\n\n},{\"./core.js\":46}],50:[function(require,module,exports){\n'use strict';\n\nmodule.exports = require('./core.js');\nrequire('./done.js');\nrequire('./finally.js');\nrequire('./es6-extensions.js');\nrequire('./node-extensions.js');\n\n},{\"./core.js\":46,\"./done.js\":47,\"./es6-extensions.js\":48,\"./finally.js\":49,\"./node-extensions.js\":51}],51:[function(require,module,exports){\n'use strict';\n\n// This file contains then/promise specific extensions that are only useful\n// for node.js interop\n\nvar Promise = require('./core.js');\nvar asap = require('asap');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  argumentCount = argumentCount || Infinity;\n  return function () {\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 0,\n        argumentCount > 0 ? argumentCount : 0);\n    return new Promise(function (resolve, reject) {\n      args.push(function (err, res) {\n        if (err) reject(err);\n        else resolve(res);\n      })\n      var res = fn.apply(self, args);\n      if (res &&\n        (\n          typeof res === 'object' ||\n          typeof res === 'function'\n        ) &&\n        typeof res.then === 'function'\n      ) {\n        resolve(res);\n      }\n    })\n  }\n}\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback =\n      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        })\n      }\n    }\n  }\n}\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n}\n\n},{\"./core.js\":46,\"asap\":1}],52:[function(require,module,exports){\narguments[4][45][0].apply(exports,arguments)\n},{\"./lib\":57,\"dup\":45}],53:[function(require,module,exports){\n'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n},{\"asap/raw\":2}],54:[function(require,module,exports){\narguments[4][47][0].apply(exports,arguments)\n},{\"./core.js\":53,\"dup\":47}],55:[function(require,module,exports){\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n},{\"./core.js\":53}],56:[function(require,module,exports){\narguments[4][49][0].apply(exports,arguments)\n},{\"./core.js\":53,\"dup\":49}],57:[function(require,module,exports){\n'use strict';\n\nmodule.exports = require('./core.js');\nrequire('./done.js');\nrequire('./finally.js');\nrequire('./es6-extensions.js');\nrequire('./node-extensions.js');\nrequire('./synchronous.js');\n\n},{\"./core.js\":53,\"./done.js\":54,\"./es6-extensions.js\":55,\"./finally.js\":56,\"./node-extensions.js\":58,\"./synchronous.js\":59}],58:[function(require,module,exports){\n'use strict';\n\n// This file contains then/promise specific extensions that are only useful\n// for node.js interop\n\nvar Promise = require('./core.js');\nvar asap = require('asap');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  if (\n    typeof argumentCount === 'number' && argumentCount !== Infinity\n  ) {\n    return denodeifyWithCount(fn, argumentCount);\n  } else {\n    return denodeifyWithoutCount(fn);\n  }\n}\n\nvar callbackFn = (\n  'function (err, res) {' +\n  'if (err) { rj(err); } else { rs(res); }' +\n  '}'\n);\nfunction denodeifyWithCount(fn, argumentCount) {\n  var args = [];\n  for (var i = 0; i < argumentCount; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'return new Promise(function (rs, rj) {',\n    'var res = fn.call(',\n    ['self'].concat(args).concat([callbackFn]).join(','),\n    ');',\n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n  return Function(['Promise', 'fn'], body)(Promise, fn);\n}\nfunction denodeifyWithoutCount(fn) {\n  var fnLength = Math.max(fn.length - 1, 3);\n  var args = [];\n  for (var i = 0; i < fnLength; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'var args;',\n    'var argLength = arguments.length;',\n    'if (arguments.length > ' + fnLength + ') {',\n    'args = new Array(arguments.length + 1);',\n    'for (var i = 0; i < arguments.length; i++) {',\n    'args[i] = arguments[i];',\n    '}',\n    '}',\n    'return new Promise(function (rs, rj) {',\n    'var cb = ' + callbackFn + ';',\n    'var res;',\n    'switch (argLength) {',\n    args.concat(['extra']).map(function (_, index) {\n      return (\n        'case ' + (index) + ':' +\n        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +\n        'break;'\n      );\n    }).join(''),\n    'default:',\n    'args[argLength] = cb;',\n    'res = fn.apply(self, args);',\n    '}',\n    \n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n\n  return Function(\n    ['Promise', 'fn'],\n    body\n  )(Promise, fn);\n}\n\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback =\n      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        })\n      }\n    }\n  }\n}\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n}\n\n},{\"./core.js\":53,\"asap\":1}],59:[function(require,module,exports){\n'use strict';\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\nPromise.enableSynchronous = function () {\n  Promise.prototype.isPending = function() {\n    return this.getState() == 0;\n  };\n\n  Promise.prototype.isFulfilled = function() {\n    return this.getState() == 1;\n  };\n\n  Promise.prototype.isRejected = function() {\n    return this.getState() == 2;\n  };\n\n  Promise.prototype.getValue = function () {\n    if (this._81 === 3) {\n      return this._65.getValue();\n    }\n\n    if (!this.isFulfilled()) {\n      throw new Error('Cannot get a value of an unfulfilled promise.');\n    }\n\n    return this._65;\n  };\n\n  Promise.prototype.getReason = function () {\n    if (this._81 === 3) {\n      return this._65.getReason();\n    }\n\n    if (!this.isRejected()) {\n      throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n    }\n\n    return this._65;\n  };\n\n  Promise.prototype.getState = function () {\n    if (this._81 === 3) {\n      return this._65.getState();\n    }\n    if (this._81 === -1 || this._81 === -2) {\n      return 0;\n    }\n\n    return this._81;\n  };\n};\n\nPromise.disableSynchronous = function() {\n  Promise.prototype.isPending = undefined;\n  Promise.prototype.isFulfilled = undefined;\n  Promise.prototype.isRejected = undefined;\n  Promise.prototype.getValue = undefined;\n  Promise.prototype.getReason = undefined;\n  Promise.prototype.getState = undefined;\n};\n\n},{\"./core.js\":53}],60:[function(require,module,exports){\n(function (global){\n'use strict';\r\n\r\nvar width = 256;// each RC4 output is 0 <= x < 256\r\nvar chunks = 6;// at least six RC4 outputs for each double\r\nvar digits = 52;// there are 52 significant digits in a double\r\nvar pool = [];// pool: entropy pool starts empty\r\nvar GLOBAL = typeof global === 'undefined' ? window : global;\r\n\r\n//\r\n// The following constants are related to IEEE 754 limits.\r\n//\r\nvar startdenom = Math.pow(width, chunks),\r\n    significance = Math.pow(2, digits),\r\n    overflow = significance * 2,\r\n    mask = width - 1;\r\n\r\n\r\nvar oldRandom = Math.random;\r\n\r\n//\r\n// seedrandom()\r\n// This is the seedrandom function described above.\r\n//\r\nmodule.exports = function(seed, options) {\r\n  if (options && options.global === true) {\r\n    options.global = false;\r\n    Math.random = module.exports(seed, options);\r\n    options.global = true;\r\n    return Math.random;\r\n  }\r\n  var use_entropy = (options && options.entropy) || false;\r\n  var key = [];\r\n\r\n  // Flatten the seed string or build one from local entropy if needed.\r\n  var shortseed = mixkey(flatten(\r\n    use_entropy ? [seed, tostring(pool)] :\r\n    0 in arguments ? seed : autoseed(), 3), key);\r\n\r\n  // Use the seed to initialize an ARC4 generator.\r\n  var arc4 = new ARC4(key);\r\n\r\n  // Mix the randomness into accumulated entropy.\r\n  mixkey(tostring(arc4.S), pool);\r\n\r\n  // Override Math.random\r\n\r\n  // This function returns a random double in [0, 1) that contains\r\n  // randomness in every bit of the mantissa of the IEEE 754 value.\r\n\r\n  return function() {         // Closure to return a random double:\r\n    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48\r\n        d = startdenom,                 //   and denominator d = 2 ^ 48.\r\n        x = 0;                          //   and no 'extra last byte'.\r\n    while (n < significance) {          // Fill up all significant digits by\r\n      n = (n + x) * width;              //   shifting numerator and\r\n      d *= width;                       //   denominator and generating a\r\n      x = arc4.g(1);                    //   new least-significant-byte.\r\n    }\r\n    while (n >= overflow) {             // To avoid rounding up, before adding\r\n      n /= 2;                           //   last byte, shift everything\r\n      d /= 2;                           //   right using integer Math until\r\n      x >>>= 1;                         //   we have exactly the desired bits.\r\n    }\r\n    return (n + x) / d;                 // Form the number within [0, 1).\r\n  };\r\n};\r\n\r\nmodule.exports.resetGlobal = function () {\r\n  Math.random = oldRandom;\r\n};\r\n\r\n//\r\n// ARC4\r\n//\r\n// An ARC4 implementation.  The constructor takes a key in the form of\r\n// an array of at most (width) integers that should be 0 <= x < (width).\r\n//\r\n// The g(count) method returns a pseudorandom integer that concatenates\r\n// the next (count) outputs from ARC4.  Its return value is a number x\r\n// that is in the range 0 <= x < (width ^ count).\r\n//\r\n/** @constructor */\r\nfunction ARC4(key) {\r\n  var t, keylen = key.length,\r\n      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\r\n\r\n  // The empty key [] is treated as [0].\r\n  if (!keylen) { key = [keylen++]; }\r\n\r\n  // Set up S using the standard key scheduling algorithm.\r\n  while (i < width) {\r\n    s[i] = i++;\r\n  }\r\n  for (i = 0; i < width; i++) {\r\n    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];\r\n    s[j] = t;\r\n  }\r\n\r\n  // The \"g\" method returns the next (count) outputs as one number.\r\n  (me.g = function(count) {\r\n    // Using instance members instead of closure state nearly doubles speed.\r\n    var t, r = 0,\r\n        i = me.i, j = me.j, s = me.S;\r\n    while (count--) {\r\n      t = s[i = mask & (i + 1)];\r\n      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];\r\n    }\r\n    me.i = i; me.j = j;\r\n    return r;\r\n    // For robust unpredictability discard an initial batch of values.\r\n    // See http://www.rsa.com/rsalabs/node.asp?id=2009\r\n  })(width);\r\n}\r\n\r\n//\r\n// flatten()\r\n// Converts an object tree to nested arrays of strings.\r\n//\r\nfunction flatten(obj, depth) {\r\n  var result = [], typ = (typeof obj)[0], prop;\r\n  if (depth && typ == 'o') {\r\n    for (prop in obj) {\r\n      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}\r\n    }\r\n  }\r\n  return (result.length ? result : typ == 's' ? obj : obj + '\\0');\r\n}\r\n\r\n//\r\n// mixkey()\r\n// Mixes a string seed into a key that is an array of integers, and\r\n// returns a shortened string seed that is equivalent to the result key.\r\n//\r\nfunction mixkey(seed, key) {\r\n  var stringseed = seed + '', smear, j = 0;\r\n  while (j < stringseed.length) {\r\n    key[mask & j] =\r\n      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));\r\n  }\r\n  return tostring(key);\r\n}\r\n\r\n//\r\n// autoseed()\r\n// Returns an object for autoseeding, using window.crypto if available.\r\n//\r\n/** @param {Uint8Array=} seed */\r\nfunction autoseed(seed) {\r\n  try {\r\n    GLOBAL.crypto.getRandomValues(seed = new Uint8Array(width));\r\n    return tostring(seed);\r\n  } catch (e) {\r\n    return [+new Date, GLOBAL, GLOBAL.navigator && GLOBAL.navigator.plugins,\r\n            GLOBAL.screen, tostring(pool)];\r\n  }\r\n}\r\n\r\n//\r\n// tostring()\r\n// Converts an array of charcodes to a string\r\n//\r\nfunction tostring(a) {\r\n  return String.fromCharCode.apply(0, a);\r\n}\r\n\r\n//\r\n// When seedrandom.js is loaded, we immediately mix a few bits\r\n// from the built-in RNG into the entropy pool.  Because we do\r\n// not want to intefere with determinstic PRNG state later,\r\n// seedrandom will not call Math.random on its own again after\r\n// initialization.\r\n//\r\nmixkey(Math.random(), pool);\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],61:[function(require,module,exports){\n\nexports = module.exports = function() {\n\tvar ret = '', value;\n\tfor (var i = 0; i < 32; i++) {\n\t\tvalue = exports.random() * 16 | 0;\n\t\t// Insert the hypens\n\t\tif (i > 4 && i < 21 && ! (i % 4)) {\n\t\t\tret += '-';\n\t\t}\n\t\t// Add the next random character\n\t\tret += (\n\t\t\t(i === 12) ? 4 : (\n\t\t\t\t(i === 16) ? (value & 3 | 8) : value\n\t\t\t)\n\t\t).toString(16);\n\t}\n\treturn ret;\n};\n\nvar uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;\nexports.isUUID = function(uuid) {\n\treturn uuidRegex.test(uuid);\n};\n\nexports.random = function() {\n\treturn Math.random();\n};\n\n\n},{}],62:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function() {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n},{}],63:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],64:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],65:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],66:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],67:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":65,\"./encode\":66}],68:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n},{\"./util\":69,\"punycode\":64,\"querystring\":67}],69:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n},{}]},{},[20])(20)\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlanMvZGlzdC9ldmUuY3VzdG9tLmpzPzczZWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUZBQWEsR0FBRyxJQUFzRCxFQUFFLG1CQUFtQixLQUFLLFVBQTROLENBQUMsYUFBYSwwQkFBMEIsbUJBQW1CLGtCQUFrQixnQkFBZ0IsVUFBVSxVQUFVLDBDQUEwQyxnQkFBZ0IsT0FBQyxPQUFPLG9CQUFvQiw4Q0FBOEMsa0NBQWtDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGVBQWUsc0JBQXNCLG9CQUFvQixrREFBa0QsV0FBVyxZQUFZLFNBQVMsU0FBUyxLQUFLO0FBQ3h6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsVUFBVTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7QUFDdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNB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QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLCtDQUErQztBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHlEQUF5RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNENBQTRDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsYUFBYTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxnQ0FBZ0M7QUFDbkM7O0FBRUE7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTyxXQUFXOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsQ0FBQyxFQUFFLDRCQUE0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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsV0FBVztBQUNkOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsYUFBYTtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLENBQUMsRUFBRSxlQUFlO0FBQ2xCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxlQUFlO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLENBQUMsRUFBRSxlQUFlO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLG1HQUFtRztBQUN0Rzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQSxDQUFDLEVBQUUsd0JBQXdCO0FBQzNCO0FBQ0EsQ0FBQyxFQUFFLG9CQUFvQjtBQUN2Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOztBQUV0QyxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsQ0FBQyxxSUFBcUk7QUFDdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBOztBQUVBLENBQUMsRUFBRSw0QkFBNEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBSzs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRCwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSwyQ0FBMkM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUcsRUFBRSxHQUFHO0FBQ1QsQ0FBQyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuZXZlID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLy8gcmF3QXNhcCBwcm92aWRlcyBldmVyeXRoaW5nIHdlIG5lZWQgZXhjZXB0IGV4Y2VwdGlvbiBtYW5hZ2VtZW50LlxudmFyIHJhd0FzYXAgPSByZXF1aXJlKFwiLi9yYXdcIik7XG4vLyBSYXdUYXNrcyBhcmUgcmVjeWNsZWQgdG8gcmVkdWNlIEdDIGNodXJuLlxudmFyIGZyZWVUYXNrcyA9IFtdO1xuLy8gV2UgcXVldWUgZXJyb3JzIHRvIGVuc3VyZSB0aGV5IGFyZSB0aHJvd24gaW4gcmlnaHQgb3JkZXIgKEZJRk8pLlxuLy8gQXJyYXktYXMtcXVldWUgaXMgZ29vZCBlbm91Z2ggaGVyZSwgc2luY2Ugd2UgYXJlIGp1c3QgZGVhbGluZyB3aXRoIGV4Y2VwdGlvbnMuXG52YXIgcGVuZGluZ0Vycm9ycyA9IFtdO1xudmFyIHJlcXVlc3RFcnJvclRocm93ID0gcmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIodGhyb3dGaXJzdEVycm9yKTtcblxuZnVuY3Rpb24gdGhyb3dGaXJzdEVycm9yKCkge1xuICAgIGlmIChwZW5kaW5nRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBwZW5kaW5nRXJyb3JzLnNoaWZ0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGxzIGEgdGFzayBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHJldHVybmluZywgaW4gaXRzIG93biBldmVudCwgd2l0aCBwcmlvcml0eVxuICogb3ZlciBvdGhlciBldmVudHMgbGlrZSBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlcGFpbnQuIEFuIGVycm9yIHRocm93biBmcm9tIGFuXG4gKiBldmVudCB3aWxsIG5vdCBpbnRlcnJ1cHQsIG5vciBldmVuIHN1YnN0YW50aWFsbHkgc2xvdyBkb3duIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBvdGhlciBldmVudHMsIGJ1dCB3aWxsIGJlIHJhdGhlciBwb3N0cG9uZWQgdG8gYSBsb3dlciBwcmlvcml0eSBldmVudC5cbiAqIEBwYXJhbSB7e2NhbGx9fSB0YXNrIEEgY2FsbGFibGUgb2JqZWN0LCB0eXBpY2FsbHkgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYXNhcDtcbmZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIHZhciByYXdUYXNrO1xuICAgIGlmIChmcmVlVGFza3MubGVuZ3RoKSB7XG4gICAgICAgIHJhd1Rhc2sgPSBmcmVlVGFza3MucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmF3VGFzayA9IG5ldyBSYXdUYXNrKCk7XG4gICAgfVxuICAgIHJhd1Rhc2sudGFzayA9IHRhc2s7XG4gICAgcmF3QXNhcChyYXdUYXNrKTtcbn1cblxuLy8gV2Ugd3JhcCB0YXNrcyB3aXRoIHJlY3ljbGFibGUgdGFzayBvYmplY3RzLiAgQSB0YXNrIG9iamVjdCBpbXBsZW1lbnRzXG4vLyBgY2FsbGAsIGp1c3QgbGlrZSBhIGZ1bmN0aW9uLlxuZnVuY3Rpb24gUmF3VGFzaygpIHtcbiAgICB0aGlzLnRhc2sgPSBudWxsO1xufVxuXG4vLyBUaGUgc29sZSBwdXJwb3NlIG9mIHdyYXBwaW5nIHRoZSB0YXNrIGlzIHRvIGNhdGNoIHRoZSBleGNlcHRpb24gYW5kIHJlY3ljbGVcbi8vIHRoZSB0YXNrIG9iamVjdCBhZnRlciBpdHMgc2luZ2xlIHVzZS5cblJhd1Rhc2sucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy50YXNrLmNhbGwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoYXNhcC5vbmVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGhvb2sgZXhpc3RzIHB1cmVseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgICAgICAgIC8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdFxuICAgICAgICAgICAgLy8gZGVwZW5kcyBvbiBpdHMgZXhpc3RlbmNlLlxuICAgICAgICAgICAgYXNhcC5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGEgd2ViIGJyb3dzZXIsIGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC4gSG93ZXZlciwgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHNsb3dpbmcgZG93biB0aGUgcXVldWUgb2YgcGVuZGluZyB0YXNrcywgd2UgcmV0aHJvdyB0aGUgZXJyb3IgaW4gYVxuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgdHVybi5cbiAgICAgICAgICAgIHBlbmRpbmdFcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICByZXF1ZXN0RXJyb3JUaHJvdygpO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgZnJlZVRhc2tzW2ZyZWVUYXNrcy5sZW5ndGhdID0gdGhpcztcbiAgICB9XG59O1xuXG59LHtcIi4vcmF3XCI6Mn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBtZWFucyBwb3NzaWJsZSB0byBleGVjdXRlIGEgdGFzayBpbiBpdHMgb3duIHR1cm4sIHdpdGhcbi8vIHByaW9yaXR5IG92ZXIgb3RoZXIgZXZlbnRzIGluY2x1ZGluZyBJTywgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZWRyYXdcbi8vIGV2ZW50cyBpbiBicm93c2Vycy5cbi8vXG4vLyBBbiBleGNlcHRpb24gdGhyb3duIGJ5IGEgdGFzayB3aWxsIHBlcm1hbmVudGx5IGludGVycnVwdCB0aGUgcHJvY2Vzc2luZyBvZlxuLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duIGJ5IGEgdGFzaywgdGhhdCB0aGUgdGFzayBxdWV1ZSB3aWxsIGNvbnRpbnVlIGZsdXNoaW5nIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLCBidXQgaWYgeW91IHVzZSBgcmF3QXNhcGAgZGlyZWN0bHksIHlvdSBhcmUgcmVzcG9uc2libGUgdG9cbi8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4vLyBjYWxsIGByYXdBc2FwLnJlcXVlc3RGbHVzaGAgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbm1vZHVsZS5leHBvcnRzID0gcmF3QXNhcDtcbmZ1bmN0aW9uIHJhd0FzYXAodGFzaykge1xuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCgpO1xuICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIC8vIEVxdWl2YWxlbnQgdG8gcHVzaCwgYnV0IGF2b2lkcyBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgcXVldWVbcXVldWUubGVuZ3RoXSA9IHRhc2s7XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuLy8gT25jZSBhIGZsdXNoIGhhcyBiZWVuIHJlcXVlc3RlZCwgbm8gZnVydGhlciBjYWxscyB0byBgcmVxdWVzdEZsdXNoYCBhcmVcbi8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbnZhciBmbHVzaGluZyA9IGZhbHNlO1xuLy8gYHJlcXVlc3RGbHVzaGAgaXMgYW4gaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgbWV0aG9kIHRoYXQgYXR0ZW1wdHMgdG8ga2lja1xuLy8gb2ZmIGEgYGZsdXNoYCBldmVudCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLiBgZmx1c2hgIHdpbGwgYXR0ZW1wdCB0byBleGhhdXN0XG4vLyB0aGUgZXZlbnQgcXVldWUgYmVmb3JlIHlpZWxkaW5nIHRvIHRoZSBicm93c2VyJ3Mgb3duIGV2ZW50IGxvb3AuXG52YXIgcmVxdWVzdEZsdXNoO1xuLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHRhc2sgdG8gZXhlY3V0ZSBpbiB0aGUgdGFzayBxdWV1ZS4gVGhpcyBpc1xuLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4vLyBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbnZhciBpbmRleCA9IDA7XG4vLyBJZiBhIHRhc2sgc2NoZWR1bGVzIGFkZGl0aW9uYWwgdGFza3MgcmVjdXJzaXZlbHksIHRoZSB0YXNrIHF1ZXVlIGNhbiBncm93XG4vLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4vLyB0cnVuY2F0ZSBhbHJlYWR5LWNvbXBsZXRlZCB0YXNrcy5cbnZhciBjYXBhY2l0eSA9IDEwMjQ7XG5cbi8vIFRoZSBmbHVzaCBmdW5jdGlvbiBwcm9jZXNzZXMgYWxsIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHNjaGVkdWxlZCB3aXRoXG4vLyBgcmF3QXNhcGAgdW5sZXNzIGFuZCB1bnRpbCBvbmUgb2YgdGhvc2UgdGFza3MgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbi8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbi8vIGNvbnNpc3RlbnQgYW5kIHdpbGwgcmVzdW1lIHdoZXJlIGl0IGxlZnQgb2ZmIHdoZW4gY2FsbGVkIGFnYWluLlxuLy8gSG93ZXZlciwgYGZsdXNoYCBkb2VzIG5vdCBtYWtlIGFueSBhcnJhbmdlbWVudHMgdG8gYmUgY2FsbGVkIGFnYWluIGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duLlxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgaW5kZXggYmVmb3JlIGNhbGxpbmcgdGhlIHRhc2suIFRoaXMgZW5zdXJlcyB0aGF0IHdlIHdpbGxcbiAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBxdWV1ZVtjdXJyZW50SW5kZXhdLmNhbGwoKTtcbiAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgLy8gSWYgd2UgY2FsbCBgYXNhcGAgd2l0aGluIHRhc2tzIHNjaGVkdWxlZCBieSBgYXNhcGAsIHRoZSBxdWV1ZSB3aWxsXG4gICAgICAgIC8vIGdyb3csIGJ1dCB0byBhdm9pZCBhbiBPKG4pIHdhbGsgZm9yIGV2ZXJ5IHRhc2sgd2UgZXhlY3V0ZSwgd2UgZG9uJ3RcbiAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgcGVyaW9kaWNhbGx5IHNoaWZ0IDEwMjQgdGFza3Mgb2ZmIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKGluZGV4ID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNoaWZ0IGFsbCB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGluZGV4IGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgZm9yICh2YXIgc2NhbiA9IDAsIG5ld0xlbmd0aCA9IHF1ZXVlLmxlbmd0aCAtIGluZGV4OyBzY2FuIDwgbmV3TGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBxdWV1ZVtzY2FuXSA9IHF1ZXVlW3NjYW4gKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggLT0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBpbmRleCA9IDA7XG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSBzdHJhdGVneSBiYXNlZCBvbiBkYXRhIGNvbGxlY3RlZCBmcm9tXG4vLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbi8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFtRy01VVlHdXA1cXhHZEVNV2toUDZCV0N6MDUzTlViMkUxUW9VVFUxNnVBL2VkaXQjZ2lkPTc4MzcyNDU5M1xuXG4vLyBTYWZhcmkgNiBhbmQgNi4xIGZvciBkZXNrdG9wLCBpUGFkLCBhbmQgaVBob25lIGFyZSB0aGUgb25seSBicm93c2VycyB0aGF0XG4vLyBoYXZlIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgYnV0IG5vdCB1bi1wcmVmaXhlZCBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXVzdCB1c2UgYGdsb2JhbGAgb3IgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgdG8gd29yayBpbiBib3RoIGZyYW1lcyBhbmQgd2ViXG4vLyB3b3JrZXJzLiBgZ2xvYmFsYCBpcyBhIHByb3Zpc2lvbiBvZiBCcm93c2VyaWZ5LCBNciwgTXJzLCBvciBNb3AuXG5cbi8qIGdsb2JhbHMgc2VsZiAqL1xudmFyIHNjb3BlID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHNlbGY7XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBzY29wZS5NdXRhdGlvbk9ic2VydmVyIHx8IHNjb3BlLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbi8vIE11dGF0aW9uT2JzZXJ2ZXJzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGhhdmUgaGlnaCBwcmlvcml0eSBhbmQgd29ya1xuLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xuaWYgKHR5cGVvZiBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuXG4vLyBNZXNzYWdlQ2hhbm5lbHMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgZ2l2ZSBkaXJlY3QgYWNjZXNzIHRvIHRoZSBIVE1MXG4vLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMCBpcyB0aGUgb25seSBicm93c2VyIHRoYXQgaGFzIHNldEltbWVkaWF0ZSBidXQgZG9lc1xuLy8gbm90IGhhdmUgTXV0YXRpb25PYnNlcnZlcnMuXG4vLyBBbHRob3VnaCBzZXRJbW1lZGlhdGUgeWllbGRzIHRvIHRoZSBicm93c2VyJ3MgcmVuZGVyZXIsIGl0IHdvdWxkIGJlXG4vLyBwcmVmZXJyYWJsZSB0byBmYWxsaW5nIGJhY2sgdG8gc2V0VGltZW91dCBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlXG4vLyB0aGUgbWluaW11bSA0bXMgcGVuYWx0eS5cbi8vIFVuZm9ydHVuYXRlbHkgdGhlcmUgYXBwZWFycyB0byBiZSBhIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCBNb2JpbGUgKGFuZFxuLy8gRGVza3RvcCB0byBhIGxlc3NlciBleHRlbnQpIHRoYXQgcmVuZGVycyBib3RoIHNldEltbWVkaWF0ZSBhbmRcbi8vIE1lc3NhZ2VDaGFubmVsIHVzZWxlc3MgZm9yIHRoZSBwdXJwb3NlcyBvZiBBU0FQLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL2lzc3Vlcy8zOTZcblxuLy8gVGltZXJzIGFyZSBpbXBsZW1lbnRlZCB1bml2ZXJzYWxseS5cbi8vIFdlIGZhbGwgYmFjayB0byB0aW1lcnMgaW4gd29ya2VycyBpbiBtb3N0IGVuZ2luZXMsIGFuZCBpbiBmb3JlZ3JvdW5kXG4vLyBjb250ZXh0cyBpbiB0aGUgZm9sbG93aW5nIGJyb3dzZXJzLlxuLy8gSG93ZXZlciwgbm90ZSB0aGF0IGV2ZW4gdGhpcyBzaW1wbGUgY2FzZSByZXF1aXJlcyBudWFuY2VzIHRvIG9wZXJhdGUgaW4gYVxuLy8gYnJvYWQgc3BlY3RydW0gb2YgYnJvd3NlcnMuXG4vL1xuLy8gLSBGaXJlZm94IDMtMTNcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi05XG4vLyAtIGlQYWQgU2FmYXJpIDQuM1xuLy8gLSBMeW54IDIuOC43XG59IGVsc2Uge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihmbHVzaCk7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIHJlcXVlc3RzIHRoYXQgdGhlIGhpZ2ggcHJpb3JpdHkgZXZlbnQgcXVldWUgYmUgZmx1c2hlZCBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZS5cbi8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuLy8gcXVldWUgaWYgdGhlIGV4Y2VwdGlvbiBoYW5kbGVkIGJ5IE5vZGUuanPigJlzXG4vLyBgcHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIpYCBvciBieSBhIGRvbWFpbi5cbnJhd0FzYXAucmVxdWVzdEZsdXNoID0gcmVxdWVzdEZsdXNoO1xuXG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRvZ2dsZSA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuXG4vLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbi8vIG9yaWdpbmFsIGZvdW5kYXRpb24gZm9yIHRoaXMgbGlicmFyeS5cbi8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG5cbi8vIFNhZmFyaSA2LjAuNSAoYXQgbGVhc3QpIGludGVybWl0dGVudGx5IGZhaWxzIHRvIGNyZWF0ZSBtZXNzYWdlIHBvcnRzIG9uIGFcbi8vIHBhZ2UncyBmaXJzdCBsb2FkLiBUaGFua2Z1bGx5LCB0aGlzIHZlcnNpb24gb2YgU2FmYXJpIHN1cHBvcnRzXG4vLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTWVzc2FnZUNoYW5uZWwoY2FsbGJhY2spIHtcbi8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuLy8gICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIEZvciByZWFzb25zIGV4cGxhaW5lZCBhYm92ZSwgd2UgYXJlIGFsc28gdW5hYmxlIHRvIHVzZSBgc2V0SW1tZWRpYXRlYFxuLy8gdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4vLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuLy8gSXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gYXNzaWduIGBzZXRJbW1lZGlhdGVgIHRvIGByZXF1ZXN0Rmx1c2hgIGJlY2F1c2Vcbi8vIGBzZXRJbW1lZGlhdGVgIG11c3QgYmUgY2FsbGVkICpieSBuYW1lKiBhbmQgdGhlcmVmb3JlIG11c3QgYmUgd3JhcHBlZCBpbiBhXG4vLyBjbG9zdXJlLlxuLy8gTmV2ZXIgZm9yZ2V0LlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuLy8gc2Nyb2xsaW5nLiBUaGlzIHByb2JsZW0gZG9lcyBub3QgaW1wYWN0IEFTQVAgYmVjYXVzZSBTYWZhcmkgNi4wIHN1cHBvcnRzXG4vLyBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHRoYXQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCBpbnN0ZWFkLlxuLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuLy8gaXMgdG8gYWRkIGEgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2FsbHMgZm9yIGEgZmx1c2guXG5cbi8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuLy8gYXBwcm94aW1hdGVseSA3IGluIHdlYiB3b3JrZXJzIGluIEZpcmVmb3ggOCB0aHJvdWdoIDE4LCBhbmQgc29tZXRpbWVzIG5vdFxuLy8gZXZlbiB0aGVuLlxuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIC8vIFdlIGRpc3BhdGNoIGEgdGltZW91dCB3aXRoIGEgc3BlY2lmaWVkIGRlbGF5IG9mIDAgZm9yIGVuZ2luZXMgdGhhdFxuICAgICAgICAvLyBjYW4gcmVsaWFibHkgYWNjb21tb2RhdGUgdGhhdCByZXF1ZXN0LiBUaGlzIHdpbGwgdXN1YWxseSBiZSBzbmFwcGVkXG4gICAgICAgIC8vIHRvIGEgNCBtaWxpc2Vjb25kIGRlbGF5LCBidXQgb25jZSB3ZSdyZSBmbHVzaGluZywgdGhlcmUncyBubyBkZWxheVxuICAgICAgICAvLyBiZXR3ZWVuIGV2ZW50cy5cbiAgICAgICAgdmFyIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIHZhciBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKGhhbmRsZVRpbWVyLCA1MCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRoaXMgaXMgZm9yIGBhc2FwLmpzYCBvbmx5LlxuLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbi8vIGl0cyBleGlzdGVuY2UuXG5yYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lciA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4vLyBpbnRvIHRoaXMgQVNBUCBwYWNrYWdlLiBJdCB3YXMgbGF0ZXIgYWRhcHRlZCB0byBSU1ZQIHdoaWNoIG1hZGUgZnVydGhlclxuLy8gYW1lbmRtZW50cy4gVGhlc2UgZGVjaXNpb25zLCBwYXJ0aWN1bGFybHkgdG8gbWFyZ2luYWxpemUgTWVzc2FnZUNoYW5uZWwgYW5kXG4vLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4vLyBiYWNrIGludG8gQVNBUCBwcm9wZXIuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzL2Jsb2IvY2RkZjcyMzI1NDZhOWNmODU4NTI0Yjc1Y2RlNmY5ZWRmNzI2MjBhNy9saWIvcnN2cC9hc2FwLmpzXG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvYXNzaWduJylcbiAgLCBub3JtYWxpemVPcHRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMnKVxuICAsIGlzQ2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZScpXG4gICwgY29udGFpbnMgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuXG4gICwgZDtcblxuZCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRzY3IsIHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgdywgb3B0aW9ucywgZGVzYztcblx0aWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMikgfHwgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykpIHtcblx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0dmFsdWUgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHRcdHcgPSBjb250YWlucy5jYWxsKGRzY3IsICd3Jyk7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cbmQuZ3MgPSBmdW5jdGlvbiAoZHNjciwgZ2V0LCBzZXQvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCBvcHRpb25zLCBkZXNjO1xuXHRpZiAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmIChnZXQgPT0gbnVsbCkge1xuXHRcdGdldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShnZXQpKSB7XG5cdFx0b3B0aW9ucyA9IGdldDtcblx0XHRnZXQgPSBzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoc2V0ID09IG51bGwpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoc2V0KSkge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHR9XG5cblx0ZGVzYyA9IHsgZ2V0OiBnZXQsIHNldDogc2V0LCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cbn0se1wiZXM1LWV4dC9vYmplY3QvYXNzaWduXCI6NSxcImVzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlXCI6OCxcImVzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zXCI6MTQsXCJlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zXCI6MTd9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge307XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IE9iamVjdC5hc3NpZ24gOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjo2LFwiLi9zaGltXCI6N31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiwgb2JqO1xuXHRpZiAodHlwZW9mIGFzc2lnbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiBcInJhelwiIH07XG5cdGFzc2lnbihvYmosIHsgYmFyOiBcImR3YVwiIH0sIHsgdHJ6eTogXCJ0cnp5XCIgfSk7XG5cdHJldHVybiBvYmouZm9vICsgb2JqLmJhciArIG9iai50cnp5ID09PSBcInJhemR3YXRyenlcIjtcbn07XG5cbn0se31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlzICA9IHJlcXVpcmUoXCIuLi9rZXlzXCIpXG4gICwgdmFsdWUgPSByZXF1aXJlKFwiLi4vdmFsaWQtdmFsdWVcIilcbiAgLCBtYXggICA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZXN0LCBzcmMvKiwg4oCmc3JjbiovKSB7XG5cdHZhciBlcnJvciwgaSwgbGVuZ3RoID0gbWF4KGFyZ3VtZW50cy5sZW5ndGgsIDIpLCBhc3NpZ247XG5cdGRlc3QgPSBPYmplY3QodmFsdWUoZGVzdCkpO1xuXHRhc3NpZ24gPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRlc3Rba2V5XSA9IHNyY1trZXldO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZTtcblx0XHR9XG5cdH07XG5cdGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRrZXlzKHNyYykuZm9yRWFjaChhc3NpZ24pO1xuXHR9XG5cdGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnJvcjtcblx0cmV0dXJuIGRlc3Q7XG59O1xuXG59LHtcIi4uL2tleXNcIjoxMSxcIi4uL3ZhbGlkLXZhbHVlXCI6MTZ9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIERlcHJlY2F0ZWRcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiOyB9O1xuXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgdmFsdWUgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi92YWxpZC12YWx1ZVwiKVxuICAsIG9ialByb3BlcnR5SXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHZhciBpO1xuXHR2YWx1ZShvYmopO1xuXHRmb3IgKGkgaW4gb2JqKSB7XG5cdFx0Ly8gSnNsaW50OiBpZ25vcmVcblx0XHRpZiAob2JqUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGkpKSByZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59O1xuXG59LHtcIi4vdmFsaWQtdmFsdWVcIjoxNn1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX3VuZGVmaW5lZCA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvbi9ub29wXCIpKCk7IC8vIFN1cHBvcnQgRVMzIGVuZ2luZXNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgIT09IF91bmRlZmluZWQgJiYgdmFsICE9PSBudWxsOyB9O1xuXG59LHtcIi4uL2Z1bmN0aW9uL25vb3BcIjo0fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IE9iamVjdC5rZXlzIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6MTIsXCIuL3NoaW1cIjoxM31dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRPYmplY3Qua2V5cyhcInByaW1pdGl2ZVwiKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxufSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4uL2lzLXZhbHVlXCIpO1xuXG52YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIGtleXMoaXNWYWx1ZShvYmplY3QpID8gT2JqZWN0KG9iamVjdCkgOiBvYmplY3QpOyB9O1xuXG59LHtcIi4uL2lzLXZhbHVlXCI6MTB9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBvYmopIHtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gc3JjKSBvYmpba2V5XSA9IHNyY1trZXldO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzMS8qLCDigKZvcHRpb25zKi8pIHtcblx0dmFyIHJlc3VsdCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRpZiAoIWlzVmFsdWUob3B0aW9ucykpIHJldHVybjtcblx0XHRwcm9jZXNzKE9iamVjdChvcHRpb25zKSwgcmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG59LHtcIi4vaXMtdmFsdWVcIjoxMH1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0cmV0dXJuIGZuO1xufTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4vaXMtdmFsdWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNWYWx1ZSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG59LHtcIi4vaXMtdmFsdWVcIjoxMH1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBTdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6MTgsXCIuL3NoaW1cIjoxOX1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgc3RyID0gXCJyYXpkd2F0cnp5XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHN0ci5jb250YWlucyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBzdHIuY29udGFpbnMoXCJkd2FcIikgPT09IHRydWUgJiYgc3RyLmNvbnRhaW5zKFwiZm9vXCIpID09PSBmYWxzZTtcbn07XG5cbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW5kZXhPZiA9IFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLyosIHBvc2l0aW9uKi8pIHtcblx0cmV0dXJuIGluZGV4T2YuY2FsbCh0aGlzLCBzZWFyY2hTdHJpbmcsIGFyZ3VtZW50c1sxXSkgPiAtMTtcbn07XG5cbn0se31dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMuQWdlbnQgPSByZXF1aXJlKCcuL2xpYi9BZ2VudCcpO1xuZXhwb3J0cy5TZXJ2aWNlTWFuYWdlciA9IHJlcXVpcmUoJy4vbGliL1NlcnZpY2VNYW5hZ2VyJyk7XG5leHBvcnRzLlRyYW5zcG9ydE1hbmFnZXIgPSByZXF1aXJlKCcuL2xpYi9UcmFuc3BvcnRNYW5hZ2VyJyk7XG5cbmV4cG9ydHMudHJhbnNwb3J0ID0ge1xuICBMb2NhbFRyYW5zcG9ydDogICAgIHJlcXVpcmUoJy4vbGliL3RyYW5zcG9ydC9sb2NhbC9Mb2NhbFRyYW5zcG9ydCcpXG59O1xuXG5leHBvcnRzLlRyYW5zcG9ydE1hbmFnZXIucmVnaXN0ZXJUeXBlKGV4cG9ydHMudHJhbnNwb3J0LkxvY2FsVHJhbnNwb3J0KTtcblxuLy8gbG9hZCB0aGUgZGVmYXVsdCBTZXJ2aWNlTWFuYWdlciwgYSBzaW5nbGV0b24sIGluaXRpYWxpemVkIHdpdGggYSBMb2NhbFRyYW5zcG9ydFxuZXhwb3J0cy5zeXN0ZW0gPSBuZXcgZXhwb3J0cy5TZXJ2aWNlTWFuYWdlcigpO1xuZXhwb3J0cy5zeXN0ZW0udHJhbnNwb3J0cy5hZGQobmV3IGV4cG9ydHMudHJhbnNwb3J0LkxvY2FsVHJhbnNwb3J0KCkpO1xuXG4vLyBvdmVycmlkZSBBZ2VudC5nZXRUcmFuc3BvcnRCeUlkIGluIG9yZGVyIHRvIHN1cHBvcnQgQWdlbnQuY29ubmVjdCh0cmFuc3BvcnRJZClcbmV4cG9ydHMuQWdlbnQuZ2V0VHJhbnNwb3J0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gZXhwb3J0cy5zeXN0ZW0udHJhbnNwb3J0cy5nZXQoaWQpO1xufTtcblxufSx7XCIuL2xpYi9BZ2VudFwiOjIxLFwiLi9saWIvU2VydmljZU1hbmFnZXJcIjoyMixcIi4vbGliL1RyYW5zcG9ydE1hbmFnZXJcIjoyMyxcIi4vbGliL3RyYW5zcG9ydC9sb2NhbC9Mb2NhbFRyYW5zcG9ydFwiOjI3fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZC12NCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBVUkwgPSByZXF1aXJlKCd1cmwnKTtcblxuLyoqXG4gKiBBZ2VudFxuICogQHBhcmFtIHtzdHJpbmd9IFtpZF0gICAgICAgICBJZCBmb3IgdGhlIGFnZW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBhZ2VudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGdpdmVuIGEgdXVpZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBZ2VudChpZCkge1xuICB0aGlzLmlkID0gaWQgPyBpZC50b1N0cmluZygpIDogdXVpZCgpO1xuXG4gIC8vIGEgbGlzdCB3aXRoIGFsbCBjb25uZWN0ZWQgdHJhbnNwb3J0c1xuICB0aGlzLmNvbm5lY3Rpb25zID0gW107XG4gIHRoaXMuZGVmYXVsdENvbm5lY3Rpb24gPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbn1cblxuLy8gYW4gb2JqZWN0IHdpdGggbW9kdWxlcyB3aGljaCBjYW4gYmUgdXNlZCB0byBleHRlbmQgdGhlIGFnZW50XG5BZ2VudC5tb2R1bGVzID0ge307XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgdHlwZSBvZiBtb2R1bGUuIFRoaXMgbW9kdWxlIGNhbiB0aGVuIGJlIGxvYWRlZCB2aWFcbiAqIEFnZW50LmV4dGVuZCgpIGFuZCBBZ2VudC5sb2FkTW9kdWxlKCkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciAgICAgQSBtb2R1bGUgY29uc3RydWN0b3JcbiAqL1xuQWdlbnQucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcbiAgdmFyIHR5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUudHlwZTtcbiAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RydWN0b3IgZnVuY3Rpb24gZXhwZWN0ZWQnKTtcbiAgfVxuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIFwicHJvdG90eXBlLnR5cGVcIiBtaXNzaW5nIGluIHRyYW5zcG9ydCBjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmICh0eXBlIGluIEFnZW50Lm1vZHVsZXMpIHtcbiAgICBpZiAoQWdlbnQubW9kdWxlc1t0eXBlXSAhPT0gY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTW9kdWxlIG9mIHR5cGUgXCInICsgdHlwZSArICdcIiBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cbiAgfVxuXG4gIEFnZW50Lm1vZHVsZXNbdHlwZV0gPSBjb25zdHJ1Y3Rvcjtcbn07XG5cbi8qKlxuICogR2V0IGEgdHJhbnNwb3J0IGJ5IGlkLlxuICogVGhpcyBzdGF0aWMgbWV0aG9kIGNhbiBiZSBvdmVybG9hZGVkIGZvciBleGFtcGxlIGJ5IHRoZSBnZXQgZnVuY3Rpb24gb2ZcbiAqIGEgc2luZ2xldG9uIFRyYW5zcG9ydE1hbmFnZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqL1xuQWdlbnQuZ2V0VHJhbnNwb3J0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCB3aXRoIGlkIFwiJyArIGlkICsgJ1wiIG5vdCBmb3VuZCcpO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgYW4gYWdlbnQgd2l0aCBtb2R1bGVzIChtaXhpbnMpLlxuICogVGhlIG1vZHVsZXMgbmV3IGZ1bmN0aW9ucyBhcmUgYWRkZWQgdG8gdGhlIEFnZW50IGl0c2VsZi5cbiAqIFNlZSBhbHNvIGZ1bmN0aW9uIGBsb2FkTW9kdWxlYC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IG1vZHVsZSAgQSBtb2R1bGUgbmFtZSBvciBhbiBBcnJheSB3aXRoIG1vZHVsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy4gQXZhaWxhYmxlIG1vZHVsZXM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXR0ZXJuJywgJ3JlcXVlc3QnLCAnYmFiYmxlJ1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgICBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIG1vZHVsZVxuICogQHJldHVybiB7QWdlbnR9IFJldHVybnMgdGhlIGFnZW50IGl0c2VsZlxuICovXG5BZ2VudC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKG1vZHVsZSwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtb2R1bGUpKSB7XG4gICAgdmFyIG1vZHVsZXMgPSBbXS5jb25jYXQobW9kdWxlKTtcblxuICAgIC8vIG9yZGVyIHRoZSBtb2R1bGVzIHN1Y2ggdGhhdCAncGF0dGVybicgY29tZXMgZmlyc3QsIHRoaXMgbW9kdWxlIG11c3QgYmVcbiAgICAvLyBsb2FkZWQgYmVmb3JlIG90aGVyIG1vZHVsZXMgKCdyZXF1ZXN0JyBzcGVjaWZpY2FsbHkpXG4gICAgbW9kdWxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYSA9PSAncGF0dGVybicpIHJldHVybiAtMTtcbiAgICAgIGlmIChiID09ICdwYXR0ZXJuJykgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIC8vIGFuIGFycmF5IHdpdGggbW9kdWxlIG5hbWVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmV4dGVuZChtb2R1bGVzW2ldLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBhIHNpbmdsZSBtb2R1bGUgbmFtZVxuICAgIHZhciBjb25zdHJ1Y3RvciA9IF9nZXRNb2R1bGVDb25zdHJ1Y3Rvcihtb2R1bGUpO1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjb25zdHJ1Y3Rvcih0aGlzLCBvcHRpb25zKTtcbiAgICB2YXIgbWl4aW4gPSBpbnN0YW5jZS5taXhpbigpO1xuXG4gICAgLy8gY2hlY2sgZm9yIGNvbmZsaWN0cyBpbiB0aGUgbW9kdWxlcyBtaXhpbiBmdW5jdGlvbnNcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKG1peGluKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobWVbbmFtZV0gIT09IHVuZGVmaW5lZCAmJiBuYW1lICE9PSAnX3JlY2VpdmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmxpY3Q6IGFnZW50IGFscmVhZHkgaGFzIGEgcHJvcGVydHkgXCInICsgcHJvcCArICdcIicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZXh0ZW5kIHRoZSBhZ2VudCB3aXRoIGFsbCBtaXhpbiBmdW5jdGlvbnMgcHJvdmlkZWQgYnkgdGhlIG1vZHVsZVxuICAgIE9iamVjdC5rZXlzKG1peGluKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBtZVtuYW1lXSA9IG1peGluW25hbWVdO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExvYWQgYSBtb2R1bGUgb250byBhbiBhZ2VudC5cbiAqIFNlZSBhbHNvIGZ1bmN0aW9uIGBleHRlbmRgLlxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gbW9kdWxlICBBIG1vZHVsZSBuYW1lIG9yIGFuIEFycmF5IHdpdGggbW9kdWxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLiBBdmFpbGFibGUgbW9kdWxlczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhdHRlcm4nLCAncmVxdWVzdCcsICdiYWJibGUnXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICAgIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgbW9kdWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGNyZWF0ZWQgbW9kdWxlXG4gKi9cbkFnZW50LnByb3RvdHlwZS5sb2FkTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZSwgb3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShvcHRpb25zKSA6IHt9O1xuICBfb3B0aW9ucy5leHRlbmQgPSBmYWxzZTtcblxuICB2YXIgY29uc3RydWN0b3IgPSBfZ2V0TW9kdWxlQ29uc3RydWN0b3IobW9kdWxlKTtcbiAgdmFyIGluc3RhbmNlID0gbmV3IGNvbnN0cnVjdG9yKHRoaXMsIG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgdmFyIG1peGluID0gaW5zdGFuY2UubWl4aW4oKTtcblxuICAvLyBvbmx5IHJlcGxhY2UgdGhlIF9yZWNlaXZlIGZ1bmN0aW9uLCBkbyBub3QgYWRkIG90aGVyIG1peGluIGZ1bmN0aW9uc1xuICB0aGlzLl9yZWNlaXZlID0gbWl4aW4uX3JlY2VpdmU7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLyoqXG4gKiBHZXQgYSBtb2R1bGUgY29uc3RydWN0b3IgYnkgaXQncyBuYW1lLlxuICogVGhyb3dzIGFuIGVycm9yIHdoZW4gdGhlIG1vZHVsZSBpcyBub3QgZm91bmQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7ZnVuY3Rpb259IFJldHVybnMgdGhlIG1vZHVsZXMgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRNb2R1bGVDb25zdHJ1Y3RvcihuYW1lKSB7XG4gIHZhciBjb25zdHJ1Y3RvciA9IEFnZW50Lm1vZHVsZXNbbmFtZV07XG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kdWxlIFwiJyArIG5hbWUgKyAnXCIuICcgK1xuICAgICAgJ0Nob29zZSBmcm9tOiAnICsgT2JqZWN0LmtleXMoQWdlbnQubW9kdWxlcykubWFwKEpTT04uc3RyaW5naWZ5KS5qb2luKCcsICcpKTtcbiAgfVxuICByZXR1cm4gY29uc3RydWN0b3I7XG59XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UgdG8gYW4gYWdlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b1xuICogICAgICAgICAgICAgIHRvIGlzIGVpdGhlcjpcbiAqICAgICAgICAgICAgICAtIEEgc3RyaW5nIFwiYWdlbnRJZFwiLCB0aGUgaWQgb2YgdGhlIHJlY2lwaWVudC4gV2lsbCBiZSBzZW5kXG4gKiAgICAgICAgICAgICAgICB2aWEgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IG9yIHdoZW4gdGhlcmUgaXMgbm8gZGVmYXVsdFxuICogICAgICAgICAgICAgICAgdHJhbnNwb3J0IHZpYSB0aGUgZmlyc3QgY29ubmVjdGVkIHRyYW5zcG9ydC5cbiAqICAgICAgICAgICAgICAtIEEgc3RyaW5nIFwiYWdlbnRJZEB0cmFuc3BvcnRJZFwiIE9ubHkgdXNhYmxlIGxvY2FsbHksIG5vdFxuICogICAgICAgICAgICAgICAgZm9yIHNoYXJpbmcgYW4gYWRkcmVzcyB3aXRoIHJlbW90ZSBhZ2VudHMuXG4gKiAgICAgICAgICAgICAgLSBBIHN0cmluZyBcInByb3RvY29sOi8vbmV0d29ya0lkL2FnZW50SWRcIi4gVGhpcyBpcyBhIHNoYXJhYmxlXG4gKiAgICAgICAgICAgICAgICBpZGVudGlmaWVyIGZvciBhbiBhZ2VudC5cbiAqIEBwYXJhbSB7Kn0gbWVzc2FnZSAgTWVzc2FnZSB0byBiZSBzZW5kXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBtZXNzYWdlIGFzXG4gKiAgICAgICAgICAgICAgICAgICBzdWNjZXNzZnVsbHkgYmVlbiBzZW50LCBvciByZWplY3RlZCB3aGVuIHNlbmRpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICBtZXNzYWdlIGZhaWxlZFxuICovXG5BZ2VudC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICh0bywgbWVzc2FnZSkge1xuXG4gIHZhciBjb2xvbiA9IHRvLmluZGV4T2YoJzonKTtcbiAgaWYgKGNvbG9uICE9PSAtMSkge1xuICAgIHZhciB1cmwgPSBVUkwucGFyc2UodG8pO1xuXG4gICAgLy9UT0RPOiBGaXggdGhpcyBmb3IgcHJvdG9jb2xzIHRoYXQgdXNlIG5ldHdvcmtJZCBpbnN0ZWFkIG9mIGhvc3QgKE5lZWRzIHRvIGJlIGZpeGVkIGluIHRoZSBwcm90b2NvbCBpdHNlbGYuKVxuICAgIHJldHVybiB0aGlzLl9zZW5kQnlQcm90b2NvbCh1cmwucHJvdG9jb2wuc2xpY2UoMCwgLTEpLCB0bywgbWVzc2FnZSk7XG4gIH1cblxuICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcyBub3RhdGlvbiBcImFnZW50SWRAdHJhbnNwb3J0SWRcIj9cbiAgdmFyIGF0ID0gdG8uaW5kZXhPZignQCcpO1xuICBpZiAoYXQgIT0gLTEpIHtcbiAgICAvLyB0byBpcyBhbiBpZCBsaWtlIFwiYWdlbnRJZEB0cmFuc3BvcnRJZFwiXG4gICAgdmFyIF90byA9IHRvLnN1YnN0cmluZygwLCBhdCk7XG4gICAgdmFyIF90cmFuc3BvcnRJZCA9IHRvLnN1YnN0cmluZyhhdCArIDEpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kQnlUcmFuc3BvcnRJZChfdHJhbnNwb3J0SWQsIF90bywgbWVzc2FnZSk7XG4gIH1cblxuICAvLyB0byBpcyBhbiBpZCBsaWtlIFwiYWdlbnRJZFwiLiBTZW5kIHZpYSB0aGUgZGVmYXVsdCB0cmFuc3BvcnRcbiAgdmFyIGNvbm4gPSB0aGlzLmRlZmF1bHRDb25uZWN0aW9uO1xuICBpZiAoY29ubikge1xuICAgIHJldHVybiBjb25uLnNlbmQodG8sIG1lc3NhZ2UpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vIHRyYW5zcG9ydCBmb3VuZCcpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kIGEgdHJhbnNwb3J0IHRvIGFuIGFnZW50IGdpdmVuIGEgbmV0d29ya0lkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkICAgIEEgbmV0d29yayBpZFxuICogQHBhcmFtIHtzdHJpbmd9IHRvICAgICAgICAgICBBbiBhZ2VudHMgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlICAgICAgTWVzc2FnZSB0byBiZSBzZW5kXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBtZXNzYWdlIGFzXG4gKiAgICAgICAgICAgICAgICAgICBzdWNjZXNzZnVsbHkgYmVlbiBzZW50LCBvciByZWplY3RlZCB3aGVuIHNlbmRpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICBtZXNzYWdlIGZhaWxlZFxuICogQHByaXZhdGVcbiAqL1xuQWdlbnQucHJvdG90eXBlLl9zZW5kQnlOZXR3b3JrSWQgPSBmdW5jdGlvbiAobmV0d29ya0lkLCB0bywgbWVzc2FnZSkge1xuICAvLyBUT0RPOiBjaGFuZ2UgdGhpcy5jb25uZWN0aW9ucyB0byBhIG1hcCB3aXRoIG5ldHdvcmtJZCBhcyBrZXlzLCBtdWNoIGZhc3RlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbnNbaV07XG4gICAgaWYgKGNvbm5lY3Rpb24udHJhbnNwb3J0Lm5ldHdvcmtJZCA9PSBuZXR3b3JrSWQpIHtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uLnNlbmQodG8sIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vIHRyYW5zcG9ydCBmb3VuZCB3aXRoIG5ldHdvcmtJZCBcIicgKyBuZXR3b3JrSWQgKyAnXCInKSk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBtZXNzYWdlIGJ5IGEgdHJhbnNwb3J0IGJ5IHByb3RvY29sLlxuICogVGhlIG1lc3NhZ2Ugd2lsbCBiZSBzZW5kIHZpYSB0aGUgZmlyc3QgZm91bmQgdHJhbnNwb3J0IGhhdmluZyB0aGUgc3BlY2lmaWVkXG4gKiBwcm90b2NvbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbCAgICAgQSBwcm90b2NvbCwgZm9yIGV4YW1wbGUgJ2h0dHAnIG9yICd3cydcbiAqIEBwYXJhbSB7c3RyaW5nfSB0byAgICAgICAgICAgQW4gYWdlbnRzIGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAgICAgIE1lc3NhZ2UgdG8gYmUgc2VuZFxuICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgbWVzc2FnZSBhc1xuICogICAgICAgICAgICAgICAgICAgc3VjY2Vzc2Z1bGx5IGJlZW4gc2VudCwgb3IgcmVqZWN0ZWQgd2hlbiBzZW5kaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgbWVzc2FnZSBmYWlsZWRcbiAqIEBwcml2YXRlXG4gKi9cbkFnZW50LnByb3RvdHlwZS5fc2VuZEJ5UHJvdG9jb2wgPSBmdW5jdGlvbiAocHJvdG9jb2wsIHRvLCBtZXNzYWdlKSB7XG5cbiAgLy8gdGhlIGh0dHBzIGFkZHJlc3NlcyBhbHNvIG1ha2UgdXNlIG9mIHRoZSBodHRwIHByb3RvY29sLlxuICBwcm90b2NvbCA9IHByb3RvY29sID09ICdodHRwcycgPyAnaHR0cCcgOiBwcm90b2NvbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbnNbaV07XG4gICAgaWYgKGNvbm5lY3Rpb24udHJhbnNwb3J0LnR5cGUgPT0gcHJvdG9jb2wpIHtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uLnNlbmQodG8sIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vIHRyYW5zcG9ydCBmb3VuZCBmb3IgcHJvdG9jb2wgXCInICsgcHJvdG9jb2wgKyAnXCInKSk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSB0cmFuc3BvcnQgdG8gYW4gYWdlbnQgdmlhIGEgc3BlY2lmaWMgdHJhbnNwb3J0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNwb3J0SWQgIFRoZSBjb25maWd1cmVkIGlkIG9mIGEgdHJhbnNwb3J0LlxuICogQHBhcmFtIHtzdHJpbmd9IHRvICAgICAgICAgICBBbiBhZ2VudHMgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlICAgICAgTWVzc2FnZSB0byBiZSBzZW5kXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBtZXNzYWdlIGFzXG4gKiAgICAgICAgICAgICAgICAgICBzdWNjZXNzZnVsbHkgYmVlbiBzZW50LCBvciByZWplY3RlZCB3aGVuIHNlbmRpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICBtZXNzYWdlIGZhaWxlZFxuICogQHByaXZhdGVcbiAqL1xuQWdlbnQucHJvdG90eXBlLl9zZW5kQnlUcmFuc3BvcnRJZCA9IGZ1bmN0aW9uICh0cmFuc3BvcnRJZCwgdG8sIG1lc3NhZ2UpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb25zW2ldO1xuICAgIGlmIChjb25uZWN0aW9uLnRyYW5zcG9ydC5pZCA9PSB0cmFuc3BvcnRJZCkge1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZCh0bywgbWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm8gdHJhbnNwb3J0IGZvdW5kIHdpdGggaWQgXCInICsgdHJhbnNwb3J0SWQgKyAnXCInKSk7XG59O1xuXG4vKipcbiAqIFJlY2VpdmUgYSBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZyb20gICAgIElkIG9mIHNlbmRlclxuICogQHBhcmFtIHsqfSBtZXNzYWdlICAgICAgIFJlY2VpdmVkIG1lc3NhZ2UsIGEgSlNPTiBvYmplY3QgKG9mdGVuIGEgc3RyaW5nKVxuICovXG5BZ2VudC5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIChmcm9tLCBtZXNzYWdlLCBvb2JQYXJhbXMpIHtcbiAgLy8gLi4uIHRvIGJlIG92ZXJsb2FkZWRcbn07XG5cbi8qKlxuICogVGhlIG1ldGhvZCBfcmVjZWl2ZSBpcyBvdmVybG9hZGVkIGluIGEgY2FzY2FkZWQgd2F5IGJ5IG1vZHVsZXMsIGFuZCBjYWxsc1xuICogdGhlIHB1YmxpYyBtZXRob2QgQWdlbnQucmVjZWl2ZSBhdCB0aGUgZW5kIG9mIHRoZSBjaGFpbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tICAgICBJZCBvZiBzZW5kZXJcbiAqIEBwYXJhbSB7Kn0gbWVzc2FnZSAgICAgICBSZWNlaXZlZCBtZXNzYWdlLCBhIEpTT04gb2JqZWN0IChvZnRlbiBhIHN0cmluZylcbiAqIEBwYXJhbSB7YXJyYXl9IG9vYlBhcmFtcyBPcHRpb25hbCBPdXQgb2YgQmFuZCBwYXJhbWV0ZXJzLCBlLmcuIHF1ZXJ5IHBhcmFtcyBmb3IgaHR0cFxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBvZiBBZ2VudC5yZWNlaXZlXG4gKiBAcHJpdmF0ZVxuICovXG5BZ2VudC5wcm90b3R5cGUuX3JlY2VpdmUgPSBmdW5jdGlvbiAoZnJvbSwgbWVzc2FnZSwgb29iUGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLnJlY2VpdmUoZnJvbSwgbWVzc2FnZSk7XG59O1xuXG5BZ2VudC5wcm90b3R5cGUuZ2V0VXJscyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnMubWFwKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24uZ2V0TXlVcmwoKVxuICB9KTtcbn07XG5cbkFnZW50LnByb3RvdHlwZS5nZXRVcmxCeVByb3RvY29sID0gZnVuY3Rpb24gKHByb3RvY29sKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uc1tpXTtcbiAgICBpZiAoY29ubmVjdGlvbi50cmFuc3BvcnQudHlwZSA9PSBwcm90b2NvbCkge1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uZ2V0TXlVcmwoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29ubmVjdCB0byBhIHRyYW5zcG9ydC4gVGhlIGFnZW50IHdpbGwgc3Vic2NyaWJlIGl0c2VsZiB0b1xuICogbWVzc2FnZXMgc2VudCB0byBoaXMgaWQuXG4gKiBAcGFyYW0ge3N0cmluZyB8IFRyYW5zcG9ydCB8IFRyYW5zcG9ydFtdIHwgc3RyaW5nW119IHRyYW5zcG9ydFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBUcmFuc3BvcnQgaW5zdGFuY2UsIG9yIHRoZSBpZCBvZiBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQgbG9hZGVkIGluIGV2ZS5zeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2lkXSAgICAgICAgICAgICBBbiBvcHRpb25hbCBhbHRlcm5hdGl2ZSBpZCB0byBiZSB1c2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIGNvbm5lY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBhZ2VudHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93biBpZCBpcyB1c2VkLlxuICogQHJldHVybiB7Q29ubmVjdGlvbiB8IENvbm5lY3Rpb25bXX0gIFJldHVybnMgYSBjb25uZWN0aW9uIG9yLCBpbiBjYXNlIG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGUgdHJhbnNwb3J0cywgcmV0dXJucyBhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5IHdpdGggY29ubmVjdGlvbnMuIFRoZSBjb25uZWN0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUgYSBwcm9taXNlIC5yZWFkeSB3aGljaCByZXNvbHZlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIHNvb24gYXMgdGhlIGNvbm5lY3Rpb24gaXMgcmVhZHkgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlLlxuICovXG5BZ2VudC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQsIGlkKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyYW5zcG9ydCkpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHJldHVybiB0cmFuc3BvcnQubWFwKGZ1bmN0aW9uIChfdHJhbnNwb3J0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1lLl9jb25uZWN0KF90cmFuc3BvcnQsIGlkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB7ZXJyb3I6IGV9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiB0cmFuc3BvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZ2V0IHRyYW5zcG9ydCBieSBpZFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdChBZ2VudC5nZXRUcmFuc3BvcnRCeUlkKHRyYW5zcG9ydCksIGlkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4ge2Vycm9yOiBlfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBhIHRyYW5zcG9ydCBpbnN0YW5jZVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdCh0cmFuc3BvcnQsIGlkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4ge2Vycm9yOiBlfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb25uZWN0IHRvIGEgdHJhbnNwb3J0XG4gKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0ICAgICBBIFRyYW5zcG9ydCBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtpZF0gICAgICAgICAgICAgQW4gb3B0aW9uYWwgYWx0ZXJuYXRpdmUgaWQgdG8gYmUgdXNlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBjb25uZWN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgYWdlbnRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd24gaWQgaXMgdXNlZC5cbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259ICAgICAgICAgICAgIFJldHVybnMgYSBjb25uZWN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuQWdlbnQucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCwgaWQpIHtcbiAgLy8gY3JlYXRlIGEgcmVjZWl2ZSBmdW5jdGlvbiB3aGljaCBpcyBib3VuZCB0byB0aGUgX3JlY2VpdmUgZnVuY3Rpb24uXG4gIC8vIHRoZSBfcmVjZWl2ZSBmdW5jdGlvbiBjYW4gYmUgcmVwbGFjZWQgaW4gYnkgbW9kdWxlcyBpbiBhIGNhc2NhZGVkIHdheSxcbiAgLy8gYW5kIGluIHRoZSBlbmQgY2FsbHMgdGhpcy5yZWNlaXZlIG9mIHRoZSBhZ2VudC5cbiAgLy8gbm90ZTogd2UgZG9uJ3QgZG8gcmVjZWl2ZSA9IHRoaXMuX3JlY2VpdmUuYmluZCh0aGlzKSBhcyB0aGUgX3JlY2VpdmVcbiAgLy8gICAgICAgZnVuY3Rpb24gY2FuIGJlIG92ZXJsb2FkZWQgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIG1hZGUuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciByZWNlaXZlID0gZnVuY3Rpb24gKGZyb20sIG1lc3NhZ2UsIG9vYlBhcmFtcykge1xuICAgIHJldHVybiBtZS5fcmVjZWl2ZShmcm9tLCBtZXNzYWdlLCBvb2JQYXJhbXMpO1xuICB9O1xuICB2YXIgY29ubmVjdGlvbiA9IHRyYW5zcG9ydC5jb25uZWN0KGlkIHx8IHRoaXMuaWQsIHJlY2VpdmUpO1xuICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goY29ubmVjdGlvbik7XG5cbiAgLy8gc2V0IG9yIHJlcGxhY2UgdGhlIGRlZmF1bHRDb25uZWN0aW9uXG4gIGlmICghdGhpcy5kZWZhdWx0Q29ubmVjdGlvbikge1xuICAgIHRoaXMuZGVmYXVsdENvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICB9XG4gIGVsc2UgaWYgKHRyYW5zcG9ydFsnZGVmYXVsdCddKSB7XG4gICAgaWYgKHRoaXMuZGVmYXVsdENvbm5lY3Rpb25bJ2RlZmF1bHQnXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29ubmVjdCB0byBhIHNlY29uZCBkZWZhdWx0IHRyYW5zcG9ydCcpO1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRDb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZVJlYWR5KCk7XG5cbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3QgZnJvbSBvbmUgb3IgbXVsdGlwbGUgdHJhbnNwb3J0c1xuICogQHBhcmFtIHtzdHJpbmcgfCBUcmFuc3BvcnQgfCBzdHJpbmdbXSB8IFRyYW5zcG9ydFtdfSBbdHJhbnNwb3J0XVxuICogICAgICAgICAgICAgIEEgdHJhbnNwb3J0IG9yIGFuIGFycmF5IHdpdGggdHJhbnNwb3J0cy5cbiAqICAgICAgICAgICAgICBwYXJhbWV0ZXIgdHJhbnNwb3J0IGNhbiBiZSBhbiBpbnN0YW5jZSBvZiBhIFRyYW5zcG9ydCwgb3IgdGhlXG4gKiAgICAgICAgICAgICAgaWQgb2YgYSB0cmFuc3BvcnQuXG4gKiAgICAgICAgICAgICAgV2hlbiB0cmFuc3BvcnQgaXMgdW5kZWZpbmVkLCB0aGUgYWdlbnQgd2lsbCBiZSBkaXNjb25uZWN0ZWRcbiAqICAgICAgICAgICAgICBmcm9tIGFsbCBjb25uZWN0ZWQgdHJhbnNwb3J0cy5cbiAqL1xuQWdlbnQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIHZhciBpLCBjb25uZWN0aW9uO1xuXG4gIGlmICghdHJhbnNwb3J0KSB7XG4gICAgLy8gZGlzY29ubmVjdCBhbGwgdHJhbnNwb3J0c1xuICAgIHdoaWxlIChjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uc1swXSkge1xuICAgICAgdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc3BvcnQpKSB7XG4gICAgLy8gYW4gYXJyYXkgd2l0aCB0cmFuc3BvcnRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aCkge1xuICAgICAgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbnNbaV07XG4gICAgICBpZiAodHJhbnNwb3J0LmluZGV4T2YoY29ubmVjdGlvbi50cmFuc3BvcnQpICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyB0cmFuc3BvcnQgYnkgaWRcbiAgICB0aGlzLmRpc2Nvbm5lY3QoQWdlbnQuZ2V0VHJhbnNwb3J0QnlJZCh0cmFuc3BvcnQpKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBhIHNpbmdsZSB0cmFuc3BvcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbnNbaV07XG4gICAgICBpZiAoY29ubmVjdGlvbi50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xvc2UgYSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbkFnZW50LnByb3RvdHlwZS5fZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gIC8vIGZpbmQgdGhlIGNvbm5lY3Rpb25cbiAgdmFyIGluZGV4ID0gdGhpcy5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm5lY3Rpb24pO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgLy8gY2xvc2UgdGhlIGNvbm5lY3Rpb25cbiAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG5cbiAgICAvLyByZW1vdmUgZnJvbSB0aGUgbGlzdCB3aXRoIGNvbm5lY3Rpb25zXG4gICAgdGhpcy5jb25uZWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gcmVwbGFjZSB0aGUgZGVmYXVsdENvbm5lY3Rpb24gaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMuZGVmYXVsdENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuZGVmYXVsdENvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb25zW3RoaXMuY29ubmVjdGlvbnMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICB0aGlzLl91cGRhdGVSZWFkeSgpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHJlYWR5IHN0YXRlIG9mIHRoZSBhZ2VudFxuICogQHByaXZhdGVcbiAqL1xuQWdlbnQucHJvdG90eXBlLl91cGRhdGVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRklYTUU6IHdlIHNob3VsZCBub3QgcmVwbGFjZSB3aXRoIGEgbmV3IFByb21pc2UsXG4gIC8vICAgICAgICB3ZSBoYXZlIGEgcHJvYmxlbSB3aGVuIHRoaXMucmVhZHkgaXMgcmVxdWVzdGVkIGJlZm9yZSByZWFkeSxcbiAgLy8gICAgICAgIGFuZCBhbm90aGVyIGNvbm5lY3Rpb24gaXMgb3BlbmVkIGJlZm9yZSByZWFkeVxuICB0aGlzLnJlYWR5ID0gUHJvbWlzZS5hbGwodGhpcy5jb25uZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbi5yZWFkeTtcbiAgfSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcblxufSx7XCIuL3V0aWxcIjoyOCxcInByb21pc2VcIjo1MixcInVybFwiOjY4LFwidXVpZC12NFwiOjYxfV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2VlZCA9IHJlcXVpcmUoJ3NlZWQtcmFuZG9tJyk7XG52YXIgaHlwZXJ0aW1lciA9IHJlcXVpcmUoJ2h5cGVydGltZXInKTtcbnZhciBUcmFuc3BvcnRNYW5hZ2VyID0gcmVxdWlyZSgnLi9UcmFuc3BvcnRNYW5hZ2VyJyk7XG5cbi8vIG1hcCB3aXRoIGtub3duIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllc1xudmFyIEtOT1dOX1BST1BFUlRJRVMgPSB7XG4gIHRyYW5zcG9ydHM6IHRydWUsXG4gIHRpbWVyOiB0cnVlLFxuICByYW5kb206IHRydWVcbn07XG5cbmZ1bmN0aW9uIFNlcnZpY2VNYW5hZ2VyKGNvbmZpZykge1xuICB0aGlzLnRyYW5zcG9ydHMgPSBuZXcgVHJhbnNwb3J0TWFuYWdlcigpO1xuXG4gIHRoaXMudGltZXIgPSBoeXBlcnRpbWVyKCk7XG5cbiAgdGhpcy5yYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICB0aGlzLmluaXQoY29uZmlnKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBzZXJ2aWNlIG1hbmFnZXIgd2l0aCBzZXJ2aWNlcyBsb2FkZWQgZnJvbSBhIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdC4gQWxsIGN1cnJlbnQgc2VydmljZXMgYXJlIHVubG9hZGVkIGFuZCByZW1vdmVkLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICovXG5TZXJ2aWNlTWFuYWdlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdGhpcy50cmFuc3BvcnRzLmNsZWFyKCk7XG5cbiAgaWYgKGNvbmZpZykge1xuICAgIGlmIChjb25maWcudHJhbnNwb3J0cykge1xuICAgICAgdGhpcy50cmFuc3BvcnRzLmxvYWQoY29uZmlnLnRyYW5zcG9ydHMpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcudGltZXIpIHtcbiAgICAgIHRoaXMudGltZXIuY29uZmlnKGNvbmZpZy50aW1lcik7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5yYW5kb20pIHtcbiAgICAgIGlmIChjb25maWcucmFuZG9tLmRldGVybWluaXN0aWMpIHtcbiAgICAgICAgdmFyIGtleSA9IGNvbmZpZy5yYW5kb20uc2VlZCB8fCAncmFuZG9tIHNlZWQnO1xuICAgICAgICB0aGlzLnJhbmRvbSA9IHNlZWQoa2V5LCBjb25maWcucmFuZG9tKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJhbmRvbSA9IE1hdGgucmFuZG9tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIHByb3AgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3ApICYmICFLTk9XTl9QUk9QRVJUSUVTW3Byb3BdKSB7XG4gICAgICAgIC8vIFRPRE86IHNob3VsZCBsb2cgdGhpcyB3YXJuaW5nIHZpYSBhIGNvbmZpZ3VyZWQgbG9nZ2VyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBVbmtub3duIGNvbmZpZ3VyYXRpb24gb3B0aW9uIFwiJyArIHByb3AgKyAnXCInKVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhciBhbGwgY29uZmlndXJlZCBzZXJ2aWNlc1xuICovXG5TZXJ2aWNlTWFuYWdlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudHJhbnNwb3J0cy5jbGVhcigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlTWFuYWdlcjtcblxufSx7XCIuL1RyYW5zcG9ydE1hbmFnZXJcIjoyMyxcImh5cGVydGltZXJcIjozMSxcInNlZWQtcmFuZG9tXCI6NjB9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBtYW5hZ2VyIGZvciBsb2FkaW5nIGFuZCBmaW5kaW5nIHRyYW5zcG9ydHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnXSAgICAgIE9wdGlvbmFsIGFycmF5IGNvbnRhaW5pbmcgY29uZmlndXJhdGlvbiBvYmplY3RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRyYW5zcG9ydHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVHJhbnNwb3J0TWFuYWdlcihjb25maWcpIHtcbiAgdGhpcy50cmFuc3BvcnRzID0gW107XG5cbiAgaWYgKGNvbmZpZykge1xuICAgIHRoaXMubG9hZChjb25maWcpO1xuICB9XG59XG5cbi8vIG1hcCB3aXRoIGFsbCByZWdpc3RlcmVkIHR5cGVzIG9mIHRyYW5zcG9ydHNcbi8vIGVhY2ggdHJhbnNwb3J0IG11c3QgcmVnaXN0ZXIgaXRzZWxmIGF0IHRoZSBUcmFuc3BvcnRNYW5hZ2VyIHVzaW5nIHJlZ2lzdGVyVHlwZS5cblRyYW5zcG9ydE1hbmFnZXIudHlwZXMgPSB7fTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyB0eXBlIG9mIHRyYW5zcG9ydC4gVGhpcyB0cmFuc3BvcnQgY2FuIHRoZW4gYmUgbG9hZGVkIHZpYVxuICogY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7VHJhbnNwb3J0LnByb3RvdHlwZX0gY29uc3RydWN0b3IgICAgIEEgdHJhbnNwb3J0IGNvbnN0cnVjdG9yXG4gKi9cblRyYW5zcG9ydE1hbmFnZXIucmVnaXN0ZXJUeXBlID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSB7XG4gIHZhciB0eXBlID0gY29uc3RydWN0b3IucHJvdG90eXBlLnR5cGU7XG4gIGlmICh0eXBlb2YgY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cnVjdG9yIGZ1bmN0aW9uIGV4cGVjdGVkJyk7XG4gIH1cbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBcInByb3RvdHlwZS50eXBlXCIgbWlzc2luZyBpbiB0cmFuc3BvcnQgY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAodHlwZSBpbiBUcmFuc3BvcnRNYW5hZ2VyLnR5cGVzKSB7XG4gICAgaWYgKFRyYW5zcG9ydE1hbmFnZXIudHlwZXNbdHlwZV0gIT09IGNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCB0eXBlIFwiJyArIHR5cGUgKyAnXCIgYWxyZWFkeSBleGlzdHMnKTtcbiAgICB9XG4gIH1cblxuICBUcmFuc3BvcnRNYW5hZ2VyLnR5cGVzW3R5cGVdID0gY29uc3RydWN0b3I7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxvYWRlZCB0cmFuc3BvcnQgdG8gdGhlIG1hbmFnZXJcbiAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gcmV0dXJucyB0aGUgdHJhbnNwb3J0IGl0c2VsZlxuICovXG5UcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIHRoaXMudHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG4vKipcbiAqIExvYWQgb25lIG9yIG11bHRpcGxlIHRyYW5zcG9ydHMgYmFzZWQgb24gSlNPTiBjb25maWd1cmF0aW9uLlxuICogTmV3IHRyYW5zcG9ydHMgd2lsbCBiZSBhcHBlbmRlZCB0byBjdXJyZW50IHRyYW5zcG9ydHMuXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBjb25maWdcbiAqIEByZXR1cm4ge1RyYW5zcG9ydCB8IFRyYW5zcG9ydFtdfSBSZXR1cm5zIHRoZSBsb2FkZWQgdHJhbnNwb3J0KHMpXG4gKi9cblRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICByZXR1cm4gY29uZmlnLm1hcCh0aGlzLmxvYWQuYmluZCh0aGlzKSk7XG4gIH1cblxuICB2YXIgdHlwZSA9IGNvbmZpZy50eXBlO1xuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwidHlwZVwiIG1pc3NpbmcnKTtcbiAgfVxuXG4gIHZhciBjb25zdHJ1Y3RvciA9IFRyYW5zcG9ydE1hbmFnZXIudHlwZXNbdHlwZV07XG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSBvZiB0cmFuc3BvcnQgXCInICsgdHlwZSArICdcIi4gJyArXG4gICAgICAgICdDaG9vc2UgZnJvbTogJyArIE9iamVjdC5rZXlzKFRyYW5zcG9ydE1hbmFnZXIudHlwZXMpLmpvaW4oJywnKSlcbiAgfVxuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgY29uc3RydWN0b3IoY29uZmlnKTtcbiAgdGhpcy50cmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbi8qKlxuICogVW5sb2FkIGEgdHJhbnNwb3J0LlxuICogQHBhcmFtIHtUcmFuc3BvcnQgfCBUcmFuc3BvcnRbXSB8IHN0cmluZyB8IHN0cmluZ1tdfSB0cmFuc3BvcnRcbiAqICAgICAgICAgICAgICBBIFRyYW5zcG9ydCBpbnN0YW5jZSBvciB0aGUgaWQgb2YgYSB0cmFuc3BvcnQsIG9yIGFuIEFycmF5XG4gKiAgICAgICAgICAgICAgd2l0aCB0cmFuc3BvcnRzIG9yIHRyYW5zcG9ydCBpZHMuXG4gKi9cblRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLnVubG9hZCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgdmFyIF90cmFuc3BvcnQ7XG4gIGlmICh0eXBlb2YgdHJhbnNwb3J0ID09PSAnc3RyaW5nJykge1xuICAgIF90cmFuc3BvcnQgPSB0aGlzLmdldCh0cmFuc3BvcnQpO1xuICB9XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNwb3J0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNwb3J0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVubG9hZCh0cmFuc3BvcnRbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBfdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB9XG5cbiAgaWYgKF90cmFuc3BvcnQpIHtcbiAgICBfdHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZihfdHJhbnNwb3J0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGEgdHJhbnNwb3J0IGJ5IGl0cyBpZC4gVGhlIHRyYW5zcG9ydCBtdXN0IGhhdmUgYmVlbiBjcmVhdGVkIHdpdGggYW4gaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdIFRoZSBpZCBvZiBhIHRyYW5zcG9ydFxuICogQHJldHVybiB7VHJhbnNwb3J0fSBSZXR1cm5zIHRoZSB0cmFuc3BvcnQgd2hlbiBmb3VuZC4gVGhyb3dzIGFuIGVycm9yXG4gKiAgICAgICAgICAgICAgICAgICAgIHdoZW4gbm90IGZvdW5kLlxuICovXG5UcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzW2ldO1xuICAgIGlmICh0cmFuc3BvcnQuaWQgPT09IGlkKSB7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0O1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IHdpdGggaWQgXCInICsgaWQgKyAnXCIgbm90IGZvdW5kJyk7XG59O1xuXG4vKipcbiAqIEdldCBhbGwgdHJhbnNwb3J0cy5cbiAqIEByZXR1cm4ge1RyYW5zcG9ydFtdfSBSZXR1cm5zIGFuIGFycmF5IHdpdGggYWxsIGxvYWRlZCB0cmFuc3BvcnRzLlxuICovXG5UcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRyYW5zcG9ydHMuY29uY2F0KFtdKTtcbn07XG5cbi8qKlxuICogRmluZCB0cmFuc3BvcnRzIGJ5IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdICAgVHlwZSBvZiB0aGUgdHJhbnNwb3J0LiBDaG9vc2UgZnJvbSAnYW1xcCcsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc3RyaWJ1cycsICdsb2NhbCcsICdwdWJudWInLlxuICogQHJldHVybiB7VHJhbnNwb3J0W119ICAgIFdoZW4gdHlwZSBpcyBkZWZpbmVkLCB0aGUgYWxsIHRyYW5zcG9ydHMgb2YgdGhpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgYXJlIHJldHVybmVkLiBXaGVuIHVuZGVmaW5lZCwgYWxsIHRyYW5zcG9ydHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcmV0dXJuZWQuXG4gKi9cblRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLmdldEJ5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCEodHlwZSBpbiBUcmFuc3BvcnRNYW5hZ2VyLnR5cGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgb2YgdHJhbnNwb3J0IFwiJyArIHR5cGUgKyAnXCIuICcgK1xuICAgICAgICAgICdDaG9vc2UgZnJvbTogJyArIE9iamVjdC5rZXlzKFRyYW5zcG9ydE1hbmFnZXIudHlwZXMpLmpvaW4oJywnKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzLmZpbHRlcihmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0LnR5cGUgPT09IHR5cGU7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLnRyYW5zcG9ydHMpO1xuICB9XG59O1xuXG4vKipcbiAqIENsb3NlIGFsbCBjb25maWd1cmVkIHRyYW5zcG9ydHMgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hbmFnZXIuXG4gKi9cblRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gIH0pO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWFuYWdlcjtcblxufSx7fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKTtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBUcmFuc3BvcnQgY29ubmVjdGlvblxuICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydFxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWNlaXZlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhYnN0cmFjdFxuICovXG5mdW5jdGlvbiBDb25uZWN0aW9uICh0cmFuc3BvcnQsIGlkLCByZWNlaXZlKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhbiBhYnN0cmFjdCBDb25uZWN0aW9uJyk7XG59XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlYWR5ID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDYW5ub3QgZ2V0IGFic3RyYWN0IHByb3BlcnR5IHJlYWR5JykpO1xuXG4vKipcbiAqIFNlbmQgYSBtZXNzYWdlIHRvIGFuIGFnZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gKiBAcGFyYW0geyp9IG1lc3NhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9IHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIG1lc3NhZ2UgaGFzIGJlZW4gc2VudFxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHRvLCBtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgYWJzdHJhY3QgZnVuY3Rpb24gc2VuZCcpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiwgZGlzY29ubmVjdCBmcm9tIHRoZSB0cmFuc3BvcnQuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIGFic3RyYWN0IGZ1bmN0aW9uIFwiY2xvc2VcIicpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TXlVcmwgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy50cmFuc3BvcnQudHlwZSArXCI6XCIrdGhpcy5pZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbjtcblxufSx7XCJwcm9taXNlXCI6NTJ9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQWJzdHJhY3QgcHJvdG90eXBlIG9mIGEgdHJhbnNwb3J0XG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUcmFuc3BvcnQoY29uZmlnKSB7XG4gIHRoaXMuaWQgPSBjb25maWcgJiYgY29uZmlnLmlkIHx8IG51bGw7XG4gIHRoaXNbJ2RlZmF1bHQnXSA9IGNvbmZpZyAmJiBjb25maWdbJ2RlZmF1bHQnXSB8fCBmYWxzZTtcbn1cblxuVHJhbnNwb3J0LnByb3RvdHlwZS50eXBlID0gbnVsbDtcblxuLyoqXG4gKiBDb25uZWN0IGFuIGFnZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2VpdmUgIEludm9rZWQgYXMgcmVjZWl2ZShmcm9tLCBtZXNzYWdlKVxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gICAgICAgUmV0dXJucyBhIGNvbm5lY3Rpb25cbiAqL1xuVHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oaWQsIHJlY2VpdmUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGFic3RyYWN0IGZ1bmN0aW9uIFwiY29ubmVjdFwiJyk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSB0cmFuc3BvcnRcbiAqL1xuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYWJzdHJhY3QgZnVuY3Rpb24gXCJjbG9zZVwiJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxufSx7fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKTtcbnZhciBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi4vQ29ubmVjdGlvbicpO1xuXG4vKipcbiAqIEEgbG9jYWwgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7TG9jYWxUcmFuc3BvcnR9IHRyYW5zcG9ydFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGlkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWNlaXZlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTG9jYWxDb25uZWN0aW9uKHRyYW5zcG9ydCwgaWQsIHJlY2VpdmUpIHtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMuaWQgPSBpZDtcblxuICAvLyByZWdpc3RlciB0aGUgYWdlbnRzIHJlY2VpdmUgZnVuY3Rpb25cbiAgaWYgKHRoaXMuaWQgaW4gdGhpcy50cmFuc3BvcnQuYWdlbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCB3aXRoIGlkICcgKyBpZCArICcgYWxyZWFkeSBleGlzdHMnKTtcbiAgfVxuICB0aGlzLnRyYW5zcG9ydC5hZ2VudHNbdGhpcy5pZF0gPSByZWNlaXZlO1xuXG4gIC8vIHJlYWR5IHN0YXRlXG4gIHRoaXMucmVhZHkgPSBQcm9taXNlLnJlc29sdmUodGhpcyk7XG59XG5cbkxvY2FsQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TXlVcmwgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy50cmFuc3BvcnQudHlwZSArXCI6XCIrdGhpcy5pZDtcbn07XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UgdG8gYW4gYWdlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAqIEBwYXJhbSB7Kn0gbWVzc2FnZVxuICogQHJldHVybiB7UHJvbWlzZX0gcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgbWVzc2FnZSBoYXMgYmVlbiBzZW50XG4gKi9cbkxvY2FsQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICh0bywgbWVzc2FnZSkge1xuICB2YXIgcXVlcnkgPSB0by5yZXBsYWNlKFwibG9jYWw6XCIsXCJcIikuc3BsaXQoXCI/XCIpO1xuICB2YXIgY2FsbGJhY2sgPSB0aGlzLnRyYW5zcG9ydC5hZ2VudHNbcXVlcnlbMF1dO1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQWdlbnQgd2l0aCBpZCAnICsgdG8gKyAnIG5vdCBmb3VuZCcpKTtcbiAgfVxuXG4gIHZhciBxdWVyeVBhcmFtcyA9IHF1ZXJ5WzFdID8gcXVlcnlbMV0uc3BsaXQoXCImXCIpOltdO1xuICAvLyBpbnZva2UgdGhlIGFnZW50cyByZWNlaXZlciBhcyBjYWxsYmFjayhmcm9tLCBtZXNzYWdlLCBxdWVyeXBhcmFtZXRlcnMpXG4gIGNhbGxiYWNrKFwibG9jYWw6XCIrdGhpcy5pZCwgbWVzc2FnZSwgcXVlcnlQYXJhbXMpO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGNvbm5lY3Rpb25cbiAqL1xuTG9jYWxDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVsZXRlIHRoaXMudHJhbnNwb3J0LmFnZW50c1t0aGlzLmlkXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxDb25uZWN0aW9uO1xuXG59LHtcIi4uL0Nvbm5lY3Rpb25cIjoyNCxcInByb21pc2VcIjo1Mn1dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vLi4vVHJhbnNwb3J0Jyk7XG52YXIgTG9jYWxDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9Mb2NhbENvbm5lY3Rpb24nKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBsb2NhbCB0cmFuc3BvcnQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICAgICAgICAgQ29uZmlnIGNhbiBjb250YWluIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBpZDogc3RyaW5nYC4gT3B0aW9uYWxcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMb2NhbFRyYW5zcG9ydChjb25maWcpIHtcbiAgdGhpcy5pZCA9IGNvbmZpZyAmJiBjb25maWcuaWQgfHwgbnVsbDtcbiAgdGhpcy5uZXR3b3JrSWQgPSB0aGlzLmlkIHx8IG51bGw7XG4gIHRoaXNbJ2RlZmF1bHQnXSA9IGNvbmZpZyAmJiBjb25maWdbJ2RlZmF1bHQnXSB8fCBmYWxzZTtcbiAgdGhpcy5hZ2VudHMgPSB7fTtcbn1cblxuTG9jYWxUcmFuc3BvcnQucHJvdG90eXBlID0gbmV3IFRyYW5zcG9ydCgpO1xuXG5Mb2NhbFRyYW5zcG9ydC5wcm90b3R5cGUudHlwZSA9ICdsb2NhbCc7XG5cbi8qKlxuICogQ29ubmVjdCBhbiBhZ2VudFxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNlaXZlICAgICAgICAgICAgICAgICAgSW52b2tlZCBhcyByZWNlaXZlKGZyb20sIG1lc3NhZ2UpXG4gKiBAcmV0dXJuIHtMb2NhbENvbm5lY3Rpb259IFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkLlxuICovXG5Mb2NhbFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGlkLCByZWNlaXZlKSB7XG4gIHJldHVybiBuZXcgTG9jYWxDb25uZWN0aW9uKHRoaXMsIGlkLCByZWNlaXZlKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIHRyYW5zcG9ydC4gUmVtb3ZlcyBhbGwgYWdlbnQgY29ubmVjdGlvbnMuXG4gKi9cbkxvY2FsVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmFnZW50cyA9IHt9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFRyYW5zcG9ydDtcblxufSx7XCIuLy4uL1RyYW5zcG9ydFwiOjI1LFwiLi9Mb2NhbENvbm5lY3Rpb25cIjoyNn1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgUHJvbWlzZS5cbiAqIEEgdmFsdWUgaXMgbWFya2VkIGFzIGEgUHJvbWlzZSB3aGVuIGl0IGlzIGFuIG9iamVjdCBjb250YWluaW5nIGZ1bmN0aW9uc1xuICogYHRoZW5gIGFuZCBgY2F0Y2hgLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gYHZhbHVlYCBpcyBhIFByb21pc2VcbiAqL1xuZXhwb3J0cy5pc1Byb21pc2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWVbJ3RoZW4nXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIHZhbHVlWydjYXRjaCddID09PSAnZnVuY3Rpb24nXG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHVybC4gUmVtb3ZlcyB0cmFpbGluZyBzbGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBub3JtYWxpemVkIHVybFxuICovXG5leHBvcnRzLm5vcm1hbGl6ZVVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgaWYgKHVybFt1cmwubGVuZ3RoIC0gMV0gPT0gJy8nKSB7XG4gICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbn07XG5cbn0se31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRW1wdHkgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9pcy1lbXB0eScpXG4gICwgdmFsdWUgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlJylcblxuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLyosIHR5cGUqLykge1xuXHR2YXIgdHlwZTtcblx0dmFsdWUob2JqKTtcblx0dHlwZSA9IGFyZ3VtZW50c1sxXTtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCAnX19lZV9fJykgJiYgQm9vbGVhbihvYmouX19lZV9fW3R5cGVdKTtcblx0fVxuXHRyZXR1cm4gb2JqLmhhc093blByb3BlcnR5KCdfX2VlX18nKSAmJiAhaXNFbXB0eShvYmouX19lZV9fKTtcbn07XG5cbn0se1wiZXM1LWV4dC9vYmplY3QvaXMtZW1wdHlcIjo5LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWVcIjoxNn1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG5cbiAgLCBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG5cbiAgLCBvbiwgb25jZSwgb2ZmLCBlbWl0LCBtZXRob2RzLCBkZXNjcmlwdG9ycywgYmFzZTtcblxub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGE7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHtcblx0XHRkYXRhID0gZGVzY3JpcHRvci52YWx1ZSA9IGNyZWF0ZShudWxsKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19lZV9fJywgZGVzY3JpcHRvcik7XG5cdFx0ZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHR9XG5cdGlmICghZGF0YVt0eXBlXSkgZGF0YVt0eXBlXSA9IGxpc3RlbmVyO1xuXHRlbHNlIGlmICh0eXBlb2YgZGF0YVt0eXBlXSA9PT0gJ29iamVjdCcpIGRhdGFbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdGVsc2UgZGF0YVt0eXBlXSA9IFtkYXRhW3R5cGVdLCBsaXN0ZW5lcl07XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBvbmNlLCBzZWxmO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblx0c2VsZiA9IHRoaXM7XG5cdG9uLmNhbGwodGhpcywgdHlwZSwgb25jZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYuY2FsbChzZWxmLCB0eXBlLCBvbmNlKTtcblx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmd1bWVudHMpO1xuXHR9KTtcblxuXHRvbmNlLl9fZWVPbmNlTGlzdGVuZXJfXyA9IGxpc3RlbmVyO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YSwgbGlzdGVuZXJzLCBjYW5kaWRhdGUsIGk7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybiB0aGlzO1xuXHRkYXRhID0gdGhpcy5fX2VlX187XG5cdGlmICghZGF0YVt0eXBlXSkgcmV0dXJuIHRoaXM7XG5cdGxpc3RlbmVycyA9IGRhdGFbdHlwZV07XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0Zm9yIChpID0gMDsgKGNhbmRpZGF0ZSA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0aWYgKChjYW5kaWRhdGUgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHRcdChjYW5kaWRhdGUuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDIpIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcnNbaSA/IDAgOiAxXTtcblx0XHRcdFx0ZWxzZSBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoKGxpc3RlbmVycyA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdChsaXN0ZW5lcnMuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdGRlbGV0ZSBkYXRhW3R5cGVdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHZhciBpLCBsLCBsaXN0ZW5lciwgbGlzdGVuZXJzLCBhcmdzO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybjtcblx0bGlzdGVuZXJzID0gdGhpcy5fX2VlX19bdHlwZV07XG5cdGlmICghbGlzdGVuZXJzKSByZXR1cm47XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cblx0XHRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblx0XHRmb3IgKGkgPSAwOyAobGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0YXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9XG59O1xuXG5tZXRob2RzID0ge1xuXHRvbjogb24sXG5cdG9uY2U6IG9uY2UsXG5cdG9mZjogb2ZmLFxuXHRlbWl0OiBlbWl0XG59O1xuXG5kZXNjcmlwdG9ycyA9IHtcblx0b246IGQob24pLFxuXHRvbmNlOiBkKG9uY2UpLFxuXHRvZmY6IGQob2ZmKSxcblx0ZW1pdDogZChlbWl0KVxufTtcblxuYmFzZSA9IGRlZmluZVByb3BlcnRpZXMoe30sIGRlc2NyaXB0b3JzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKG8pIHtcblx0cmV0dXJuIChvID09IG51bGwpID8gY3JlYXRlKGJhc2UpIDogZGVmaW5lUHJvcGVydGllcyhPYmplY3QobyksIGRlc2NyaXB0b3JzKTtcbn07XG5leHBvcnRzLm1ldGhvZHMgPSBtZXRob2RzO1xuXG59LHtcImRcIjozLFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIjoxNX1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaHlwZXJ0aW1lcicpO1xuXG59LHtcIi4vbGliL2h5cGVydGltZXJcIjozNH1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpID9cbiAgICByZXF1aXJlKCdwcm9taXNlJykgOlxuICAgIHdpbmRvdy5Qcm9taXNlO1xuXG59LHtcInByb21pc2VcIjo0NX1dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEZWJ1ZyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LkRlYnVnIDogcmVxdWlyZSgnZGVidWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWJ1ZyB8fCBmdW5jdGlvbiAoKSB7XG4gIC8vIGVtcHR5IHN0dWIgd2hlbiBpbiB0aGUgYnJvd3NlclxuICByZXR1cm4gZnVuY3Rpb24gKCkge307XG59O1xuXG59LHtcImRlYnVnXCI6NDJ9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50LWVtaXR0ZXInKTtcbnZhciBoYXNMaXN0ZW5lcnMgPSByZXF1aXJlKCdldmVudC1lbWl0dGVyL2hhcy1saXN0ZW5lcnMnKTtcbnZhciBjcmVhdGVNYXN0ZXIgPSByZXF1aXJlKCcuL3N5bmNocm9uaXphdGlvbi9tYXN0ZXInKS5jcmVhdGVNYXN0ZXI7XG52YXIgY3JlYXRlU2xhdmUgPSByZXF1aXJlKCcuL3N5bmNocm9uaXphdGlvbi9zbGF2ZScpLmNyZWF0ZVNsYXZlO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gZW51bSBmb3IgdHlwZSBvZiB0aW1lb3V0XG52YXIgVFlQRSA9IHtcbiAgVElNRU9VVDogMCxcbiAgSU5URVJWQUw6IDEsXG4gIFRSSUdHRVI6IDJcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGh5cGVydGltZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5pc3RpYzogYm9vbGVhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHNpbXVsdGFuZW91cyBldmVudHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBleGVjdXRlZCBpbiBhIGRldGVybWluaXN0aWMgb3JkZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNlZDogYm9vbGVhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kZSBmb3IgcGFjaW5nIG9mIHRpbWUuIFdoZW4gcGFjZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdGltZSBwcm9jZWVkcyBhdCBhIGNvbnRpbnVvdXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGUgcmF0ZSwgdXNlZnVsIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uIHB1cnBvc2VzLiBXaGVuIHVucGFjZWQsIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSBqdW1wcyBpbW1lZGlhdGVseSBmcm9tIHNjaGVkdWxlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgdG8gdGhlIG5leHQgc2NoZWR1bGVkIGV2ZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0ZTogbnVtYmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcmF0ZSBvZiBwcm9ncmVzcyBvZiB0aW1lIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BlY3QgdG8gcmVhbC10aW1lLiBSYXRlIG11c3QgYmUgYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmUgbnVtYmVyLCBhbmQgaXMgMSBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgd2hlbiAyLCB0aGUgdGltZSBvZiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5cGVydGltZXIgcnVucyB0d2ljZSBhcyBmYXN0IGFzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFsLXRpbWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gcGFjZWQ9dHJ1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IG51bWJlciB8IERhdGUgfCBTdHJpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCBhIHNpbXVsYXRpb24gdGltZS4gSWYgbm90IHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHRpbWVyIGlzIGluc3RhbnRpYXRlZCB3aXRoIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCBzeXN0ZW0gdGltZS5cbiAqL1xuZnVuY3Rpb24gaHlwZXJ0aW1lcihvcHRpb25zKSB7XG4gIC8vIG9wdGlvbnNcbiAgdmFyIHBhY2VkID0gdHJ1ZTtcbiAgdmFyIHJhdGUgPSAxOyAgICAgICAgICAgICAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHBlciBtaWxsaXNlY29uZHNcbiAgdmFyIGRldGVybWluaXN0aWMgPSB0cnVlOyAvLyBydW4gc2ltdWx0YW5lb3VzIGV2ZW50cyBpbiBhIGRldGVybWluaXN0aWMgb3JkZXJcbiAgdmFyIGNvbmZpZ3VyZWRUaW1lID0gbnVsbDsvLyBvbmx5IHVzZWQgZm9yIHJldHVybmluZyB0aGUgY29uZmlndXJlZCB0aW1lIG9uIC5jb25maWcoKVxuICB2YXIgbWFzdGVyID0gbnVsbDsgICAgICAgIC8vIHVybCBvZiBtYXN0ZXIsIHdpbGwgcnVuIGFzIHNsYXZlXG4gIHZhciBwb3J0ID0gbnVsbDsgICAgICAgICAgLy8gcG9ydCB0byBzZXJ2ZSBhcyBtYXN0ZXJcblxuICAvLyBwcm9wZXJ0aWVzXG4gIHZhciBydW5uaW5nID0gZmFsc2U7ICAgICAgICAgICAgICAvLyB0cnVlIHdoZW4gcnVubmluZ1xuICB2YXIgc3RhcnRUaW1lID0gbnVsbDsgICAgICAgICAgICAgLy8gdGltZXN0YW1wLiB0aGUgbW9tZW50IGluIHJlYWwtdGltZSB3aGVuIGh5cGVyVGltZSB3YXMgc2V0XG4gIHZhciBoeXBlclRpbWUgPSB1dGlsLnN5c3RlbU5vdygpOyAvLyB0aW1lc3RhbXAuIHRoZSBzdGFydCB0aW1lIGluIGh5cGVyLXRpbWVcbiAgdmFyIHRpbWVvdXRzID0gW107ICAgICAgICAgICAgICAgIC8vIGFycmF5IHdpdGggYWxsIHJ1bm5pbmcgdGltZW91dHNcbiAgdmFyIGN1cnJlbnQgPSB7fTsgICAgICAgICAgICAgICAgIC8vIHRoZSB0aW1lb3V0cyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MgKGNhbGxiYWNrIGlzIGJlaW5nIGV4ZWN1dGVkKVxuICB2YXIgdGltZW91dElkID0gbnVsbDsgICAgICAgICAgICAgLy8gY3VycmVudGx5IHJ1bm5pbmcgdGltZXJcbiAgdmFyIGlkU2VxID0gMDsgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIgZm9yIHVuaXF1ZSB0aW1lb3V0IGlkJ3NcbiAgdmFyIHNlcnZlciA9IG51bGw7XG4gIHZhciBjbGllbnQgPSBudWxsO1xuXG4gIC8vIGV4cG9ydGVkIHRpbWVyIG9iamVjdCB3aXRoIHB1YmxpYyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlc1xuICAvLyBhZGQgZXZlbnQtZW1pdHRlciBtaXhpblxuICB2YXIgdGltZXIgPSBlbWl0dGVyKHt9KTtcblxuICAvKipcbiAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgaHlwZXJ0aW1lciwgb3IgcmV0cmlldmUgY3VycmVudFxuICAgKiBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGF2YWlsYWJsZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5pc3RpYzogYm9vbGVhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgc2ltdWx0YW5lb3VzIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgZXhlY3V0ZWQgaW4gYSBkZXRlcm1pbmlzdGljIG9yZGVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNlZDogYm9vbGVhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb2RlIGZvciBwYWNpbmcgb2YgdGltZS4gV2hlbiBwYWNlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRpbWUgcHJvY2VlZHMgYXQgYSBjb250aW51b3VzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGUgcmF0ZSwgdXNlZnVsIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24gcHVycG9zZXMuIFdoZW4gdW5wYWNlZCwgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUganVtcHMgaW1tZWRpYXRlbHkgZnJvbSBzY2hlZHVsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgdG8gdGhlIG5leHQgc2NoZWR1bGVkIGV2ZW50LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRlOiBudW1iZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJhdGUgb2YgcHJvZ3Jlc3Mgb2YgdGltZSB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BlY3QgdG8gcmVhbC10aW1lLiBSYXRlIG11c3QgYmUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZSBudW1iZXIsIGFuZCBpcyAxIGJ5IGRlZmF1bHQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvciBleGFtcGxlIHdoZW4gMiwgdGhlIHRpbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5cGVydGltZXIgcnVucyB0d2ljZSBhcyBmYXN0IGFzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWwtdGltZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSBhcHBsaWNhYmxlIHdoZW4gb3B0aW9uIHBhY2VkPXRydWUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IG51bWJlciB8IERhdGUgfCBTdHJpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0IGEgc2ltdWxhdGlvbiB0aW1lLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGFwcGxpZWQgY29uZmlndXJhdGlvblxuICAgKi9cbiAgdGltZXIuY29uZmlnID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBfdmFsaWRhdGVDb25maWcob3B0aW9ucyk7XG4gICAgICBfc2V0Q29uZmlnKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBhIGNvcHkgb2YgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgIHJldHVybiBfZ2V0Q29uZmlnKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgdGltZXIgYXMgYSBudW1iZXIuXG4gICAqIFNlZSBhbHNvIGdldFRpbWUoKS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdGltZVxuICAgKi9cbiAgdGltZXIubm93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYWNlZCkge1xuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHBlcmZvcm1hbmNlLm5vdygpIC8gcHJvY2Vzcy5ocnRpbWUodGltZSkgZm9yIGhpZ2ggcHJlY2lzaW9uIGNhbGN1bGF0aW9uIG9mIHRpbWUgaW50ZXJ2YWxcbiAgICAgICAgdmFyIHJlYWxJbnRlcnZhbCA9IHV0aWwuc3lzdGVtTm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIHZhciBoeXBlckludGVydmFsID0gcmVhbEludGVydmFsICogcmF0ZTtcbiAgICAgICAgcmV0dXJuIGh5cGVyVGltZSArIGh5cGVySW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGh5cGVyVGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gaHlwZXJUaW1lO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29udGludWUgdGhlIHRpbWVyLlxuICAgKi9cbiAgdGltZXJbJ2NvbnRpbnVlJ10gPSBmdW5jdGlvbigpIHtcbiAgICBzdGFydFRpbWUgPSB1dGlsLnN5c3RlbU5vdygpO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgLy8gcmVzY2hlZHVsZSBydW5uaW5nIHRpbWVvdXRzXG4gICAgX3NjaGVkdWxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSB0aW1lci4gVGhlIHRpbWVyIGNhbiBiZSBjb250aW51ZWQgYWdhaW4gd2l0aCBgY29udGludWUoKWBcbiAgICovXG4gIHRpbWVyLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaHlwZXJUaW1lID0gdGltZXIubm93KCk7XG4gICAgc3RhcnRUaW1lID0gbnVsbDtcbiAgICBydW5uaW5nID0gZmFsc2U7XG5cbiAgICAvLyByZXNjaGVkdWxlIHJ1bm5pbmcgdGltZW91dHMgKHBhdXNlcyB0aGVtKVxuICAgIF9zY2hlZHVsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIHRpbWVyIGFzIERhdGUuXG4gICAqIFNlZSBhbHNvIG5vdygpLlxuICAgKiBAcmV0dXJuIHtEYXRlfSBUaGUgdGltZVxuICAgKi9cbiAgdGltZXIuZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lci5ub3coKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGh5cGVydGltZXIuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVzdWx0IG9mIGdldFRpbWUoKS5cbiAgICogQHJldHVybiB7RGF0ZX0gY3VycmVudCB0aW1lXG4gICAqL1xuICB0aW1lci52YWx1ZU9mID0gdGltZXIuZ2V0VGltZTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IGh5cGVyLXRpbWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKi9cbiAgdGltZXIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRpbWVyLmdldFRpbWUoKS50b1N0cmluZygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSB0aW1lb3V0LCB3aGljaCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdGltZW91dCBvY2N1cnMgaW4gaHlwZXItdGltZS5cbiAgICogU2VlIGFsc28gc2V0VHJpZ2dlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICBGdW5jdGlvbiBleGVjdXRlZCB3aGVuIGRlbGF5IGlzIGV4Y2VlZGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgICAgICAgIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHMuIFdoZW4gdGhlIGRlbGF5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21hbGxlciBvciBlcXVhbCB0byB6ZXJvLCB0aGUgY2FsbGJhY2sgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgaW1tZWRpYXRlbHkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJucyBhIHRpbWVvdXRJZCB3aGljaCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgdGltZW91dCB1c2luZyBjbGVhclRpbWVvdXQoKS5cbiAgICovXG4gIHRpbWVyLnNldFRpbWVvdXQgPSBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXkpIHtcbiAgICB2YXIgaWQgPSBpZFNlcSsrO1xuICAgIHZhciB0aW1lc3RhbXAgPSB0aW1lci5ub3coKSArIGRlbGF5O1xuICAgIGlmIChpc05hTih0aW1lc3RhbXApKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkZWxheSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGEgbmV3IHRpbWVvdXQgdG8gdGhlIHF1ZXVlXG4gICAgX3F1ZXVlVGltZW91dCh7XG4gICAgICBpZDogaWQsXG4gICAgICB0eXBlOiBUWVBFLlRJTUVPVVQsXG4gICAgICB0aW1lOiB0aW1lc3RhbXAsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9KTtcblxuICAgIC8vIHJlc2NoZWR1bGUgdGhlIHRpbWVvdXRzXG4gICAgX3NjaGVkdWxlKCk7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIHRyaWdnZXIsIHdoaWNoIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB0aW1lb3V0IG9jY3VycyBpbiBoeXBlci10aW1lLlxuICAgKiBTZWUgYWxzbyBnZXRUaW1lb3V0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIEZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGltZW91dCBvY2N1cnMuXG4gICAqIEBwYXJhbSB7RGF0ZSB8IG51bWJlciB8IHN0cmluZyB9IHRpbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBhYnNvbHV0ZSBtb21lbnQgaW4gdGltZSAoRGF0ZSkgd2hlbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayB3aWxsIGJlIHRyaWdnZXJlZC4gV2hlbiB0aGUgZGF0ZSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgRGF0ZSBpbiB0aGUgcGFzdCwgdGhlIGNhbGxiYWNrIGlzIHRyaWdnZXJlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybnMgYSB0cmlnZ2VySWQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgIHRyaWdnZXIgdXNpbmcgY2xlYXJUcmlnZ2VyKCkuXG4gICAqL1xuICB0aW1lci5zZXRUcmlnZ2VyID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aW1lKSB7XG4gICAgdmFyIGlkID0gaWRTZXErKztcbiAgICB2YXIgdGltZXN0YW1wID0gdG9UaW1lc3RhbXAodGltZSk7XG5cbiAgICAvLyBhZGQgYSBuZXcgdGltZW91dCB0byB0aGUgcXVldWVcbiAgICBfcXVldWVUaW1lb3V0KHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHR5cGU6IFRZUEUuVFJJR0dFUixcbiAgICAgIHRpbWU6IHRpbWVzdGFtcCxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgIH0pO1xuXG4gICAgLy8gcmVzY2hlZHVsZSB0aGUgdGltZW91dHNcbiAgICBfc2NoZWR1bGUoKTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgY2FsbGJhY2sgZXZlcnkgaW50ZXJ2YWwuIE9wdGlvbmFsbHksIGEgc3RhcnQgZGF0ZSBjYW4gYmUgcHJvdmlkZWRcbiAgICogdG8gc3BlY2lmeSB0aGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgbXVzdCBiZSB0cmlnZ2VyZWQuXG4gICAqIFNlZSBhbHNvIHNldFRpbWVvdXQgYW5kIHNldFRyaWdnZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgRnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiBkZWxheSBpcyBleGNlZWRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsICAgICAgICAgICBJbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuIFdoZW4gaW50ZXJ2YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBzbWFsbGVyIHRoYW4gemVybyBvciBpcyBpbmZpbml0eSwgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgd2lsbCBiZSBzZXQgdG8gemVybyBhbmQgdHJpZ2dlcmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBhIG1heGltdW0gcmF0ZS5cbiAgICogQHBhcmFtIHtEYXRlIHwgbnVtYmVyIHwgc3RyaW5nfSBbZmlyc3RUaW1lXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGFic29sdXRlIG1vbWVudCBpbiB0aW1lIChEYXRlKSB3aGVuIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrIHdpbGwgYmUgdHJpZ2dlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5IGRlZmF1bHQsIGZpcnN0VGltZSA9IG5vdygpICsgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJucyBhIGludGVydmFsSWQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgIHRyaWdnZXIgdXNpbmcgY2xlYXJJbnRlcnZhbCgpLlxuICAgKi9cbiAgdGltZXIuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbihjYWxsYmFjaywgaW50ZXJ2YWwsIGZpcnN0VGltZSkge1xuICAgIHZhciBpZCA9IGlkU2VxKys7XG5cbiAgICB2YXIgX2ludGVydmFsID0gTnVtYmVyKGludGVydmFsKTtcbiAgICBpZiAoaXNOYU4oX2ludGVydmFsKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW50ZXJ2YWwgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAoX2ludGVydmFsIDwgMCB8fCAhaXNGaW5pdGUoX2ludGVydmFsKSkge1xuICAgICAgX2ludGVydmFsID0gMDtcbiAgICB9XG5cbiAgICB2YXIgX2ZpcnN0VGltZSA9IChmaXJzdFRpbWUgIT0gdW5kZWZpbmVkKSA/XG4gICAgICAgIHRvVGltZXN0YW1wKGZpcnN0VGltZSkgOlxuICAgICAgICBudWxsO1xuXG4gICAgdmFyIG5vdyA9IHRpbWVyLm5vdygpO1xuICAgIHZhciBfdGltZSA9IChfZmlyc3RUaW1lICE9IG51bGwpID8gX2ZpcnN0VGltZSA6IChub3cgKyBfaW50ZXJ2YWwpO1xuXG4gICAgdmFyIHRpbWVvdXQgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICB0eXBlOiBUWVBFLklOVEVSVkFMLFxuICAgICAgaW50ZXJ2YWw6IF9pbnRlcnZhbCxcbiAgICAgIHRpbWU6IF90aW1lLFxuICAgICAgZmlyc3RUaW1lOiBfZmlyc3RUaW1lICE9IG51bGwgPyBfZmlyc3RUaW1lIDogX3RpbWUsXG4gICAgICBvY2N1cnJlbmNlOiAwLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfTtcblxuICAgIGlmIChfdGltZSA8IG5vdykge1xuICAgICAgLy8gdXBkYXRlIHNjaGVkdWxlIHdoZW4gaW4gdGhlIHBhc3RcbiAgICAgIF9yZXNjaGVkdWxlSW50ZXJ2YWwodGltZW91dCwgbm93KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSBuZXcgdGltZW91dCB0byB0aGUgcXVldWVcbiAgICBfcXVldWVUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgLy8gcmVzY2hlZHVsZSB0aGUgdGltZW91dHNcbiAgICBfc2NoZWR1bGUoKTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogQ2FuY2VsIGEgdGltZW91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dElkICAgVGhlIGlkIG9mIGEgdGltZW91dFxuICAgKi9cbiAgdGltZXIuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24odGltZW91dElkKSB7XG4gICAgLy8gdGVzdCB3aGV0aGVyIHRpbWVvdXQgaXMgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkXG4gICAgaWYgKGN1cnJlbnRbdGltZW91dElkXSkge1xuICAgICAgZGVsZXRlIGN1cnJlbnRbdGltZW91dElkXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSB0aW1lb3V0IGluIHRoZSBxdWV1ZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZW91dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aW1lb3V0c1tpXS5pZCA9PT0gdGltZW91dElkKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGlzIHRpbWVvdXQgZnJvbSB0aGUgcXVldWVcbiAgICAgICAgdGltZW91dHMuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIC8vIHJlc2NoZWR1bGUgdGltZW91dHNcbiAgICAgICAgX3NjaGVkdWxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FuY2VsIGEgdHJpZ2dlclxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJpZ2dlcklkICAgVGhlIGlkIG9mIGEgdHJpZ2dlclxuICAgKi9cbiAgdGltZXIuY2xlYXJUcmlnZ2VyID0gdGltZXIuY2xlYXJUaW1lb3V0O1xuXG4gIHRpbWVyLmNsZWFySW50ZXJ2YWwgPSB0aW1lci5jbGVhclRpbWVvdXQ7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IHdpdGggdGhlIGlkJ3Mgb2YgYWxsIHRpbWVvdXRzXG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gVGltZW91dCBpZCdzXG4gICAqL1xuICB0aW1lci5saXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aW1lb3V0cy5tYXAoZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICAgIHJldHVybiB0aW1lb3V0LmlkO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgdGltZW91dHNcbiAgICovXG4gIHRpbWVyLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGVtcHR5IHRoZSBxdWV1ZVxuICAgIGN1cnJlbnQgPSB7fTtcbiAgICB0aW1lb3V0cyA9IFtdO1xuXG4gICAgLy8gcmVzY2hlZHVsZVxuICAgIF9zY2hlZHVsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSB0aW1lci4gVGhpcyB3aWxsIGNsZWFyIGFsbCB0aW1lb3V0cywgYW5kIGNsb3NlIGNvbm5lY3Rpb25zXG4gICAqIHRvIGEgbWFzdGVyIG9yIHRvIHNsYXZlIHRpbWVycy5cbiAgICovXG4gIHRpbWVyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGltZXIuY2xlYXIoKTtcbiAgICBpZiAoY2xpZW50KSBjbGllbnQuZGVzdHJveSgpO1xuICAgIGlmIChzZXJ2ZXIpIHNlcnZlci5kZXN0cm95KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uXG4gICAqIEByZXR1cm5zIHt7cGFjZWQ6IGJvb2xlYW4sIHJhdGU6IG51bWJlciwgZGV0ZXJtaW5pc3RpYzogYm9vbGVhbiwgdGltZTogKiwgbWFzdGVyOiAqfX1cbiAgICogICAgICAgICAgICAgICAgUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldENvbmZpZyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhY2VkOiBwYWNlZCxcbiAgICAgIHJhdGU6IHJhdGUsXG4gICAgICBkZXRlcm1pbmlzdGljOiBkZXRlcm1pbmlzdGljLFxuICAgICAgdGltZTogY29uZmlndXJlZFRpbWUsXG4gICAgICBtYXN0ZXI6IG1hc3RlcixcbiAgICAgIHBvcnQ6IHBvcnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgY29uZmlndXJhdGlvbiwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IG1vZGU6IHNsYXZlIG9yIG5vcm1hbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3ZhbGlkYXRlQ29uZmlnIChvcHRpb25zKSB7XG4gICAgLy8gdmFsaWRhdGUgd3JpdGFibGUgb3B0aW9uc1xuICAgIGlmIChjbGllbnQgfHwgb3B0aW9ucy5tYXN0ZXIpIHtcbiAgICAgIC8vIHdoZW4gd2UgYXJlIGEgc2xhdmUsIHdlIGNhbid0IGFkanVzdCB0aGUgY29uZmlnLCBleGNlcHQgZm9yXG4gICAgICAvLyBjaGFuZ2luZyB0aGUgbWFzdGVyIHVybCBvciBiZWNvbWluZyBhIG1hc3RlciBpdHNlbGYgKHBvcnQgY29uZmlndXJlZClcbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ21hc3RlcicgJiYgcHJvcCAhPT0gJ3NsYXZlJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5IGNvbmZpZ3VyYXRpb24gb3B0aW9uIFwiJyAgKyBwcm9wICsnXCIsIHRpbWVyIGlzIGNvbmZpZ3VyZWQgYXMgc2xhdmUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHt7cGFjZWQ6IGJvb2xlYW4sIHJhdGU6IG51bWJlciwgZGV0ZXJtaW5pc3RpYzogYm9vbGVhbiwgdGltZTogKiwgbWFzdGVyOiAqfX0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3NldENvbmZpZyhvcHRpb25zKSB7XG4gICAgaWYgKCdkZXRlcm1pbmlzdGljJyBpbiBvcHRpb25zKSB7XG4gICAgICBkZXRlcm1pbmlzdGljID0gb3B0aW9ucy5kZXRlcm1pbmlzdGljID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgncGFjZWQnIGluIG9wdGlvbnMpIHtcbiAgICAgIHBhY2VkID0gb3B0aW9ucy5wYWNlZCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpbXBvcnRhbnQ6IGFwcGx5IHRpbWUgYmVmb3JlIHJhdGVcbiAgICBpZiAoJ3RpbWUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGh5cGVyVGltZSA9IHRvVGltZXN0YW1wKG9wdGlvbnMudGltZSk7XG4gICAgICBzdGFydFRpbWUgPSB1dGlsLnN5c3RlbU5vdygpO1xuXG4gICAgICAvLyB1cGRhdGUgaW50ZXJ2YWxzXG4gICAgICBfcmVzY2hlZHVsZUludGVydmFscyhoeXBlclRpbWUpO1xuXG4gICAgICBjb25maWd1cmVkVGltZSA9IG5ldyBEYXRlKGh5cGVyVGltZSkudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoJ3JhdGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciBuZXdSYXRlID0gTnVtYmVyKG9wdGlvbnMucmF0ZSk7XG4gICAgICBpZiAoaXNOYU4obmV3UmF0ZSkgfHwgbmV3UmF0ZSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcmF0ZSAnICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yYXRlKSArICcuIFJhdGUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBpbXBvcnRhbnQ6IGZpcnN0IGdldCB0aGUgbmV3IGh5cGVyVGltZSwgdGhlbiBhZGp1c3QgdGhlIHN0YXJ0VGltZVxuICAgICAgaHlwZXJUaW1lID0gdGltZXIubm93KCk7XG4gICAgICBzdGFydFRpbWUgPSB1dGlsLnN5c3RlbU5vdygpO1xuICAgICAgcmF0ZSA9IG5ld1JhdGU7XG4gICAgfVxuXG4gICAgaWYgKCdtYXN0ZXInIGluIG9wdGlvbnMpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIHRpbWVzeW5jIHNsYXZlLCBjb25uZWN0IHRvIG1hc3RlciB2aWEgYSB3ZWJzb2NrZXRcbiAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgY2xpZW50LmRlc3Ryb3koKTtcbiAgICAgICAgY2xpZW50ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbWFzdGVyID0gb3B0aW9ucy5tYXN0ZXI7XG4gICAgICBpZiAob3B0aW9ucy5tYXN0ZXIgIT0gbnVsbCkge1xuICAgICAgICBjbGllbnQgPSBjcmVhdGVTbGF2ZShvcHRpb25zLm1hc3Rlcik7XG5cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlDb25maWcoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBfZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgX3NldENvbmZpZyhjb25maWcpO1xuICAgICAgICAgIHZhciBjdXJyID0gX2dldENvbmZpZygpO1xuICAgICAgICAgIHRpbWVyLmVtaXQoJ2NvbmZpZycsIGN1cnIsIHByZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xpZW50Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAodGltZSkgICB7IGFwcGx5Q29uZmlnKHt0aW1lOiB0aW1lfSkgfSk7XG4gICAgICAgIGNsaWVudC5vbignY29uZmlnJywgZnVuY3Rpb24gKGNvbmZpZykgeyBhcHBseUNvbmZpZyhjb25maWcpIH0pO1xuICAgICAgICBjbGllbnQub24oJ2Vycm9yJywgIGZ1bmN0aW9uIChlcnIpICAgIHsgdGltZXIuZW1pdCgnZXJyb3InLCBlcnIpIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIG1hc3RlclxuICAgIGlmICgncG9ydCcgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHNlcnZlcikge1xuICAgICAgICBzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBzZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBwb3J0ID0gb3B0aW9ucy5wb3J0O1xuICAgICAgaWYgKG9wdGlvbnMucG9ydCkge1xuICAgICAgICBzZXJ2ZXIgPSBjcmVhdGVNYXN0ZXIodGltZXIubm93LCB0aW1lci5jb25maWcsIG9wdGlvbnMucG9ydCk7XG4gICAgICAgIHNlcnZlci5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IHRpbWVyLmVtaXQoJ2Vycm9yJywgZXJyKSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXNjaGVkdWxlIHJ1bm5pbmcgdGltZW91dHNcbiAgICBfc2NoZWR1bGUoKTtcblxuICAgIGlmIChzZXJ2ZXIpIHtcbiAgICAgIC8vIGJyb2FkY2FzdCBjaGFuZ2VkIGNvbmZpZ1xuICAgICAgc2VydmVyLmJyb2FkY2FzdENvbmZpZygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNjaGVkdWxlIGFsbCBpbnRlcnZhbHMgYWZ0ZXIgYSBuZXcgdGltZSBoYXMgYmVlbiBzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub3dcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNjaGVkdWxlSW50ZXJ2YWxzKG5vdykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZW91dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0aW1lb3V0ID0gdGltZW91dHNbaV07XG4gICAgICBpZiAodGltZW91dC50eXBlID09PSBUWVBFLklOVEVSVkFMKSB7XG4gICAgICAgIF9yZXNjaGVkdWxlSW50ZXJ2YWwodGltZW91dCwgbm93KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzY2hlZHVsZSB0aGUgaW50ZXJ2YWxzIGFmdGVyIGEgbmV3IHRpbWUgaGFzIGJlZW4gc2V0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGltZW91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gbm93XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzY2hlZHVsZUludGVydmFsKHRpbWVvdXQsIG5vdykge1xuICAgIHRpbWVvdXQub2NjdXJyZW5jZSA9IE1hdGgucm91bmQoKG5vdyAtIHRpbWVvdXQuZmlyc3RUaW1lKSAvIHRpbWVvdXQuaW50ZXJ2YWwpO1xuICAgIHRpbWVvdXQudGltZSA9IHRpbWVvdXQuZmlyc3RUaW1lICsgdGltZW91dC5vY2N1cnJlbmNlICogdGltZW91dC5pbnRlcnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0aW1lb3V0IHRvIHRoZSBxdWV1ZS4gQWZ0ZXIgdGhlIHF1ZXVlIGhhcyBiZWVuIGNoYW5nZWQsIHRoZSBxdWV1ZVxuICAgKiBtdXN0IGJlIHJlc2NoZWR1bGVkIGJ5IGV4ZWN1dGluZyBfcmVzY2hlZHVsZSgpXG4gICAqIEBwYXJhbSB7e2lkOiBudW1iZXIsIHR5cGU6IG51bWJlciwgdGltZTogbnVtYmVyLCBjYWxsYmFjazogRnVuY3Rpb259fSB0aW1lb3V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfcXVldWVUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAvLyBpbnNlcnQgdGhlIG5ldyB0aW1lb3V0IGF0IHRoZSByaWdodCBwbGFjZSBpbiB0aGUgYXJyYXksIHNvcnRlZCBieSB0aW1lXG4gICAgaWYgKHRpbWVvdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpID0gdGltZW91dHMubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID49IDAgJiYgdGltZW91dHNbaV0udGltZSA+IHRpbWVvdXQudGltZSkge1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIC8vIGluc2VydCB0aGUgbmV3IHRpbWVvdXQgaW4gdGhlIHF1ZXVlLiBOb3RlIHRoYXQgdGhlIHRpbWVvdXQgaXNcbiAgICAgIC8vIGluc2VydGVkICphZnRlciogZXhpc3RpbmcgdGltZW91dHMgd2l0aCB0aGUgZXhhY3QgKnNhbWUqIHRpbWUsXG4gICAgICAvLyBzbyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmUgZXhlY3V0ZWQgaXMgZGV0ZXJtaW5pc3RpY1xuICAgICAgdGltZW91dHMuc3BsaWNlKGkgKyAxLCAwLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBxdWV1ZSBpcyBlbXB0eSwgYXBwZW5kIHRoZSBuZXcgdGltZW91dFxuICAgICAgdGltZW91dHMucHVzaCh0aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHRpbWVvdXRcbiAgICogQHBhcmFtIHt7aWQ6IG51bWJlciwgdHlwZTogbnVtYmVyLCB0aW1lOiBudW1iZXIsIGNhbGxiYWNrOiBmdW5jdGlvbn19IHRpbWVvdXRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKiAgICAgICAgICAgICBUaGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgd2hlbiB0aGUgdGltZW91dCdzIGNhbGxiYWNrIGlzXG4gICAqICAgICAgICAgICAgIGZpbmlzaGVkLiBDYWxsZWQgd2l0aG91dCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZXhlY1RpbWVvdXQodGltZW91dCwgY2FsbGJhY2spIHtcbiAgICAvLyBzdG9yZSB0aGUgdGltZW91dCBpbiB0aGUgcXVldWUgd2l0aCB0aW1lb3V0cyBpbiBwcm9ncmVzc1xuICAgIC8vIGl0IGNhbiBiZSBjbGVhcmVkIHdoZW4gYSBjbGVhclRpbWVvdXQgaXMgZXhlY3V0ZWQgaW5zaWRlIHRoZSBjYWxsYmFja1xuICAgIGN1cnJlbnRbdGltZW91dC5pZF0gPSB0aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgLy8gaW4gY2FzZSBvZiBhbiBpbnRlcnZhbCB3ZSBoYXZlIHRvIHJlc2NoZWR1bGUgb24gbmV4dCBjeWNsZVxuICAgICAgLy8gaW50ZXJ2YWwgbXVzdCBub3QgYmUgY2xlYXJlZCB3aGlsZSBleGVjdXRpbmcgdGhlIGNhbGxiYWNrXG4gICAgICBpZiAodGltZW91dC50eXBlID09PSBUWVBFLklOVEVSVkFMICYmIGN1cnJlbnRbdGltZW91dC5pZF0pIHtcbiAgICAgICAgdGltZW91dC5vY2N1cnJlbmNlKys7XG4gICAgICAgIHRpbWVvdXQudGltZSA9IHRpbWVvdXQuZmlyc3RUaW1lICsgdGltZW91dC5vY2N1cnJlbmNlICogdGltZW91dC5pbnRlcnZhbDtcbiAgICAgICAgX3F1ZXVlVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygncXVldWUgdGltZW91dCcsIHRpbWVyLmdldFRpbWUoKS50b0lTT1N0cmluZygpLCBuZXcgRGF0ZSh0aW1lb3V0LnRpbWUpLnRvSVNPU3RyaW5nKCksIHRpbWVvdXQub2NjdXJyZW5jZSkgLy8gVE9ETzogY2xlYW51cFxuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgdGhlIHRpbWVvdXQgZnJvbSB0aGUgcXVldWUgd2l0aCB0aW1lb3V0cyBpbiBwcm9ncmVzc1xuICAgICAgZGVsZXRlIGN1cnJlbnRbdGltZW91dC5pZF07XG5cbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gZXhlY3V0ZSB0aGUgY2FsbGJhY2tcbiAgICB0cnkge1xuICAgICAgaWYgKHRpbWVvdXQuY2FsbGJhY2subGVuZ3RoID09IDApIHtcbiAgICAgICAgLy8gc3luY2hyb25vdXMgdGltZW91dCwgIGxpa2UgYHRpbWVyLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgey4uLn0sIGRlbGF5KWBcbiAgICAgICAgdGltZW91dC5jYWxsYmFjaygpO1xuICAgICAgICBmaW5pc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFzeW5jaHJvbm91cyB0aW1lb3V0LCBsaWtlIGB0aW1lci5zZXRUaW1lb3V0KGZ1bmN0aW9uIChkb25lKSB7Li4uOyBkb25lKCk7IH0sIGRlbGF5KWBcbiAgICAgICAgdGltZW91dC5jYWxsYmFjayhmaW5pc2gpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZW1pdCBvciBsb2cgdGhlIGVycm9yXG4gICAgICBpZiAoaGFzTGlzdGVuZXJzKHRpbWVyLCAnZXJyb3InKSkge1xuICAgICAgICB0aW1lci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yJywgZXJyKTtcbiAgICAgIH1cblxuICAgICAgZmluaXNoKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgdGltZW91dHMgb2NjdXJyaW5nIGJlZm9yZSBvciBvbiB0aGUgcHJvdmlkZWQgdGltZSBmcm9tIHRoZVxuICAgKiBxdWV1ZSBhbmQgcmV0dXJuIHRoZW0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lICAgIEEgdGltZXN0YW1wXG4gICAqIEByZXR1cm5zIHtBcnJheX0gcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBleHBpcmVkIHRpbWVvdXRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0RXhwaXJlZFRpbWVvdXRzKHRpbWUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCB0aW1lb3V0cy5sZW5ndGggJiYgKCh0aW1lb3V0c1tpXS50aW1lIDw9IHRpbWUpIHx8ICFpc0Zpbml0ZSh0aW1lb3V0c1tpXS50aW1lKSkpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgdmFyIGV4cGlyZWQgPSB0aW1lb3V0cy5zcGxpY2UoMCwgaSk7XG5cbiAgICBpZiAoZGV0ZXJtaW5pc3RpYyA9PSBmYWxzZSkge1xuICAgICAgLy8gdGhlIGFycmF5IHdpdGggZXhwaXJlZCB0aW1lb3V0cyBpcyBpbiBkZXRlcm1pbmlzdGljIG9yZGVyXG4gICAgICAvLyBzaHVmZmxlIHRoZW1cbiAgICAgIHV0aWwuc2h1ZmZsZShleHBpcmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwaXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNjaGVkdWxlIGFsbCBxdWV1ZWQgdGltZW91dHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9zY2hlZHVsZSgpIHtcbiAgICAvLyBkbyBub3QgX3NjaGVkdWxlIHdoZW4gdGhlcmUgYXJlIHRpbWVvdXRzIGluIHByb2dyZXNzXG4gICAgLy8gdGhpcyBjYW4gYmUgdGhlIGNhc2Ugd2l0aCBhc3luYyB0aW1lb3V0cyBpbiBub24tcGFjZWQgbW9kZS5cbiAgICAvLyBfc2NoZWR1bGUgd2lsbCBiZSBleGVjdXRlZCBhZ2FpbiB3aGVuIGFsbCBhc3luYyB0aW1lb3V0cyBhcmUgZmluaXNoZWQuXG4gICAgaWYgKCFwYWNlZCAmJiBPYmplY3Qua2V5cyhjdXJyZW50KS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSB0aW1lb3V0c1swXTtcblxuICAgIC8vIGNhbmNlbCB0aW1lciB3aGVuIHJ1bm5pbmdcbiAgICBpZiAodGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHJ1bm5pbmcgJiYgbmV4dCkge1xuICAgICAgLy8gc2NoZWR1bGUgbmV4dCB0aW1lb3V0XG4gICAgICB2YXIgdGltZSA9IG5leHQudGltZTtcbiAgICAgIHZhciBkZWxheSA9IHRpbWUgLSB0aW1lci5ub3coKTtcbiAgICAgIHZhciByZWFsRGVsYXkgPSBwYWNlZCA/IGRlbGF5IC8gcmF0ZSA6IDA7XG5cbiAgICAgIGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgICAgLy8gd2hlbiBydW5uaW5nIGluIG5vbi1wYWNlZCBtb2RlLCB1cGRhdGUgdGhlIGh5cGVyVGltZSB0b1xuICAgICAgICAvLyBhZGp1c3QgdGhlIHRpbWUgb2YgdGhlIGN1cnJlbnQgZXZlbnRcbiAgICAgICAgaWYgKCFwYWNlZCkge1xuICAgICAgICAgIGh5cGVyVGltZSA9ICh0aW1lID4gaHlwZXJUaW1lICYmIGlzRmluaXRlKHRpbWUpKSA/IHRpbWUgOiBoeXBlclRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBncmFiIGFsbCBleHBpcmVkIHRpbWVvdXRzIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgIHZhciBleHBpcmVkID0gX2dldEV4cGlyZWRUaW1lb3V0cyh0aW1lKTtcbiAgICAgICAgLy8gbm90ZTogZXhwaXJlZC5sZW5ndGggY2FuIG5ldmVyIGJlIHplcm8gKG9uIGV2ZXJ5IGNoYW5nZSBvZiB0aGUgcXVldWUsIHdlIHJlc2NoZWR1bGUpXG5cbiAgICAgICAgLy8gZXhlY3V0ZSBhbGwgZXhwaXJlZCB0aW1lb3V0c1xuICAgICAgICBpZiAocGFjZWQpIHtcbiAgICAgICAgICAvLyBpbiBwYWNlZCBtb2RlLCB3ZSBmaXJlIGFsbCB0aW1lb3V0cyBpbiBwYXJhbGxlbCxcbiAgICAgICAgICAvLyBhbmQgZG9uJ3QgYXdhaXQgdGhlaXIgY29tcGxldGlvbiAodGhleSBjYW4gZG8gYXN5bmMgb3BlcmF0aW9ucylcbiAgICAgICAgICBleHBpcmVkLmZvckVhY2goZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIF9leGVjVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHNjaGVkdWxlIHRoZSBuZXh0IHJvdW5kXG4gICAgICAgICAgX3NjaGVkdWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaW4gbm9uLXBhY2VkIG1vZGUsIHdlIGV4ZWN1dGUgYWxsIGV4cGlyZWQgdGltZW91dHMgc2VyaWFsbHksXG4gICAgICAgICAgLy8gYW5kIHdhaXQgZm9yIHRoZWlyIGNvbXBsZXRpb24gaW4gb3JkZXIgdG8gZ3VhcmFudGVlIGRldGVybWluaXN0aWNcbiAgICAgICAgICAvLyBvcmRlciBvZiBleGVjdXRpb25cbiAgICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBleHBpcmVkLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICBfZXhlY1RpbWVvdXQodGltZW91dCwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgcm91bmRcbiAgICAgICAgICAgICAgX3NjaGVkdWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgTWF0aC5yb3VuZChyZWFsRGVsYXkpKTtcbiAgICAgIC8vIE5vdGU6IE1hdGgucm91bmQocmVhbERlbGF5KSBpcyB0byBkZWZlYXQgYSBidWcgaW4gbm9kZS5qcyB2MC4xMC4zMCxcbiAgICAgIC8vICAgICAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzgwNjVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIERhdGUsIG51bWJlciwgb3IgSVNPU3RyaW5nIHRvIGEgbnVtYmVyIHRpbWVzdGFtcCxcbiAgICogYW5kIHZhbGlkYXRlIHdoZXRoZXIgaXQncyBhIHZhbGlkIERhdGUuIFRoZSBudW1iZXIgSW5maW5pdHkgaXMgYWxzb1xuICAgKiBhY2NlcHRlZCBhcyBhIHZhbGlkIHRpbWVzdGFtcFxuICAgKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IGRhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm5zIGEgdW5peCB0aW1lc3RhbXAsIGEgbnVtYmVyXG4gICAqL1xuICBmdW5jdGlvbiB0b1RpbWVzdGFtcChkYXRlKSB7XG4gICAgdmFyIHZhbHVlID1cbiAgICAgICAgKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykgPyBkYXRlIDogICAgICAgICAgIC8vIG51bWJlclxuICAgICAgICAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpICAgICA/IGRhdGUudmFsdWVPZigpIDogLy8gRGF0ZVxuICAgICAgICBuZXcgRGF0ZShkYXRlKS52YWx1ZU9mKCk7ICAgICAgICAgICAgICAgICAgICAgLy8gSVNPU3RyaW5nLCBtb21lbnRqcywgLi4uXG5cbiAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGRhdGUgJyArIEpTT04uc3RyaW5naWZ5KGRhdGUpICsgJy4gJyArXG4gICAgICAgICAgJ0RhdGUsIG51bWJlciwgb3IgSVNPU3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRpbWVyLCAncnVubmluZycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBydW5uaW5nO1xuICAgIH1cbiAgfSk7XG5cbiAgdGltZXIuY29uZmlnKG9wdGlvbnMpOyAgLy8gYXBwbHkgb3B0aW9uc1xuICB0aW1lci5jb250aW51ZSgpOyAgICAgICAvLyBzdGFydCB0aGUgdGltZXJcblxuICByZXR1cm4gdGltZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwZXJ0aW1lcjtcblxufSx7XCIuL3N5bmNocm9uaXphdGlvbi9tYXN0ZXJcIjozNixcIi4vc3luY2hyb25pemF0aW9uL3NsYXZlXCI6MzcsXCIuL3V0aWxcIjo0MSxcImV2ZW50LWVtaXR0ZXJcIjozMCxcImV2ZW50LWVtaXR0ZXIvaGFzLWxpc3RlbmVyc1wiOjI5fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5XZWJTb2NrZXQgPT09ICd1bmRlZmluZWQnKSA/XG4gICAgcmVxdWlyZSgnd3MnKSA6XG4gICAgd2luZG93LldlYlNvY2tldDtcblxufSx7XCJ3c1wiOjYyfV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vV2ViU29ja2V0Jyk7XG52YXIgZW1pdHRlciA9IHJlcXVpcmUoJy4vc29ja2V0LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2RlYnVnJykoJ2h5cGVydGltZXI6bWFzdGVyJyk7XG5cbmV4cG9ydHMuY3JlYXRlTWFzdGVyID0gZnVuY3Rpb24gKG5vdywgY29uZmlnLCBwb3J0KSB7XG4gIHZhciBtYXN0ZXIgPSBuZXcgV2ViU29ja2V0LlNlcnZlcih7cG9ydDogcG9ydH0pO1xuXG4gIG1hc3Rlci5vbignY29ubmVjdGlvbicsIGZ1bmN0aW9uICh3cykge1xuICAgIGRlYnVnKCduZXcgY29ubmVjdGlvbicpO1xuXG4gICAgdmFyIF9lbWl0dGVyID0gZW1pdHRlcih3cyk7XG5cbiAgICAvLyBwaW5nIHRpbWVzeW5jIG1lc3NhZ2VzIChmb3IgdGhlIHRpbWVzeW5jIG1vZHVsZSlcbiAgICBfZW1pdHRlci5vbigndGltZScsIGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgIGNhbGxiYWNrKHRpbWUpO1xuICAgICAgZGVidWcoJ3NlbmQgdGltZSAnICsgbmV3IERhdGUodGltZSkudG9JU09TdHJpbmcoKSk7XG4gICAgfSk7XG5cbiAgICAvLyBzZW5kIHRoZSBtYXN0ZXJzIGNvbmZpZyB0byB0aGUgbmV3IGNvbm5lY3Rpb25cbiAgICB2YXIgY29uZmlnID0gc2FuaXRpemVkQ29uZmlnKCk7XG4gICAgZGVidWcoJ3NlbmQgY29uZmlnJywgY29uZmlnKTtcbiAgICBfZW1pdHRlci5zZW5kKCdjb25maWcnLCBjb25maWcpO1xuXG4gICAgd3MuZW1pdHRlciA9IF9lbWl0dGVyOyAvLyB1c2VkIGJ5IGJyb2FkY2FzdFxuICB9KTtcblxuICBtYXN0ZXIuYnJvYWRjYXN0ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgZGVidWcoJ2Jyb2FkY2FzdCcsIGV2ZW50LCBkYXRhKTtcbiAgICBtYXN0ZXIuY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICAgIGNsaWVudC5lbWl0dGVyLnNlbmQoZXZlbnQsIGRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hc3Rlci5icm9hZGNhc3RDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgbWFzdGVyLmJyb2FkY2FzdCgnY29uZmlnJywgc2FuaXRpemVkQ29uZmlnKCkpO1xuICB9O1xuXG4gIG1hc3Rlci5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgbWFzdGVyLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Rlc3Ryb3llZCcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNhbml0aXplZENvbmZpZygpIHtcbiAgICB2YXIgY3VyciA9IGNvbmZpZygpO1xuICAgIGRlbGV0ZSBjdXJyLnRpbWU7XG4gICAgZGVsZXRlIGN1cnIubWFzdGVyO1xuICAgIGRlbGV0ZSBjdXJyLnBvcnQ7XG4gICAgcmV0dXJuIGN1cnI7XG4gIH1cblxuICBkZWJ1ZygnbGlzdGVuaW5nIGF0IHdzOi8vbG9jYWxob3N0OicgKyBwb3J0KTtcblxuICByZXR1cm4gbWFzdGVyO1xufTtcblxufSx7XCIuLi9kZWJ1Z1wiOjMzLFwiLi9XZWJTb2NrZXRcIjozNSxcIi4vc29ja2V0LWVtaXR0ZXJcIjozOH1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL1dlYlNvY2tldCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLi9Qcm9taXNlJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLi9kZWJ1ZycpKCdoeXBlcnRpbWVyOnNsYXZlJyk7XG52YXIgZW1pdHRlciA9IHJlcXVpcmUoJy4vc29ja2V0LWVtaXR0ZXInKTtcbnZhciBzdGF0ID0gcmVxdWlyZSgnLi9zdGF0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBUT0RPOiBtYWtlIHRoZXNlIGNvbnN0YW50cyBjb25maWd1cmFibGVcbnZhciBJTlRFUlZBTCA9IDM2MDAwMDA7IC8vIG9uY2UgYW4gaG91clxudmFyIERFTEFZID0gMTAwMDsgICAgICAgLy8gZGVsYXkgYmV0d2VlbiBpbmRpdmlkdWFsIHJlcXVlc3RzXG52YXIgUkVQRUFUID0gNTsgICAgICAgICAvLyBudW1iZXIgb2YgdGltZXMgdG8gcmVxdWVzdCB0aGUgdGltZSBmb3IgZGV0ZXJtaW5pbmcgbGF0ZW5jeVxuXG5leHBvcnRzLmNyZWF0ZVNsYXZlID0gZnVuY3Rpb24gKHVybCkge1xuICB2YXIgd3MgPSBuZXcgV2ViU29ja2V0KHVybCk7XG4gIHZhciBzbGF2ZSA9IGVtaXR0ZXIod3MpO1xuICB2YXIgaXNGaXJzdCA9IHRydWU7XG4gIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2YXIgc3luY1RpbWVyID0gbnVsbDtcblxuICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RlZCcpO1xuICAgIHN5bmMoKTtcbiAgICBzeW5jVGltZXIgPSBzZXRJbnRlcnZhbChzeW5jLCBJTlRFUlZBTCk7XG4gIH07XG5cbiAgc2xhdmUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgICBjbGVhckludGVydmFsKHN5bmNUaW1lcik7XG4gICAgc3luY1RpbWVyID0gbnVsbDtcblxuICAgIHdzLmNsb3NlKCk7XG5cbiAgICBkZWJ1ZygnZGVzdHJveWVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN5bmMgd2l0aCB0aGUgdGltZSBvZiB0aGUgbWFzdGVyLiBFbWl0cyBhICdjaGFuZ2UnIG1lc3NhZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgLy8gcmV0cmlldmUgbGF0ZW5jeSwgdGhlbiB3YWl0IDEgc2VjXG4gICAgZnVuY3Rpb24gZ2V0TGF0ZW5jeUFuZFdhaXQoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldExhdGVuY3koc2xhdmUpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxhdGVuY3kpIHsgcmVzdWx0ID0gbGF0ZW5jeSB9KSAgLy8gc3RvcmUgdGhlIHJldHJpZXZlZCBsYXRlbmN5XG4gICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpICAgIHsgY29uc29sZS5sb2coZXJyKSB9KSAgLy8ganVzdCBsb2cgZmFpbGVkIHJlcXVlc3RzXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC53YWl0KERFTEFZKSB9KSAgLy8gd2FpdCAxIHNlY1xuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdH0pOyAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcmV0cmlldmVkIGxhdGVuY3lcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbFxuICAgICAgICAucmVwZWF0KGdldExhdGVuY3lBbmRXYWl0LCBSRVBFQVQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChhbGwpIHtcbiAgICAgICAgICBkZWJ1ZygnbGF0ZW5jaWVzJywgYWxsKTtcblxuICAgICAgICAgIC8vIGZpbHRlciBhd2F5IGZhaWxlZCByZXF1ZXN0c1xuICAgICAgICAgIHZhciBsYXRlbmNpZXMgPSBhbGwuZmlsdGVyKGZ1bmN0aW9uIChsYXRlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gbGF0ZW5jeSAhPT0gbnVsbDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGltaXQgZm9yIG91dGxpZXJzXG4gICAgICAgICAgdmFyIGxpbWl0ID0gc3RhdC5tZWRpYW4obGF0ZW5jaWVzKSArIHN0YXQuc3RkKGxhdGVuY2llcyk7XG5cbiAgICAgICAgICAvLyBmaWx0ZXIgYXdheSBvdXRsaWVyczogYWxsIGxhdGVuY2llcyBsYXJnZXJlcSB0aGFuIHRoZSBtZWFuK3N0ZFxuICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGxhdGVuY2llcy5maWx0ZXIoZnVuY3Rpb24gKGxhdGVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXRlbmN5IDwgbGltaXQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyByZXR1cm4gdGhlIG1lYW4gbGF0ZW5jeVxuICAgICAgICAgIHJldHVybiAoZmlsdGVyZWQubGVuZ3RoID4gMCkgPyBzdGF0Lm1lYW4oZmlsdGVyZWQpIDogbnVsbDtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxhdGVuY3kpIHtcbiAgICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNsYXZlLnJlcXVlc3QoJ3RpbWUnKS50aGVuKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgdmFyIHRpbWUgPSB0aW1lc3RhbXAgKyBsYXRlbmN5O1xuICAgICAgICAgICAgICBzbGF2ZS5lbWl0KCdjaGFuZ2UnLCB0aW1lKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRpbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgc2xhdmUuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhlIHRpbWUgb2YgdGhlIG1hc3RlciBhbmQgY2FsY3VsYXRlIHRoZSBsYXRlbmN5IGZyb20gdGhlXG4gICAqIHJvdW5kdHJpcCB0aW1lXG4gICAqIEBwYXJhbSB7e3JlcXVlc3Q6IGZ1bmN0aW9ufX0gZW1pdHRlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48bnVtYmVyIHwgbnVsbD59IHJldHVybnMgdGhlIGxhdGVuY3lcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldExhdGVuY3koZW1pdHRlcikge1xuICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICByZXR1cm4gZW1pdHRlci5yZXF1ZXN0KCd0aW1lJylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgIHZhciBlbmQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHZhciBsYXRlbmN5ID0gKGVuZCAtIHN0YXJ0KSAvIDI7XG4gICAgICAgICAgdmFyIHRpbWUgPSB0aW1lc3RhbXAgKyBsYXRlbmN5O1xuXG4gICAgICAgICAgLy8gYXBwbHkgdGhlIGZpcnN0IGV2ZXIgcmV0cmlldmVkIG9mZnNldCBpbW1lZGlhdGVseS5cbiAgICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgaXNGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB0aW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbGF0ZW5jeTtcbiAgICAgICAgfSlcbiAgfVxuXG4gIHJldHVybiBzbGF2ZTtcbn07XG5cblxufSx7XCIuLi9Qcm9taXNlXCI6MzIsXCIuLi9kZWJ1Z1wiOjMzLFwiLi9XZWJTb2NrZXRcIjozNSxcIi4vc29ja2V0LWVtaXR0ZXJcIjozOCxcIi4vc3RhdFwiOjM5LFwiLi91dGlsXCI6NDB9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUdXJuIGEgV2ViU29ja2V0IGluIGFuIGV2ZW50IGVtaXR0ZXIuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnQtZW1pdHRlcicpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLy4uL1Byb21pc2UnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2RlYnVnJykoJ2h5cGVydGltZXI6c29ja2V0Jyk7XG5cbnZhciBUSU1FT1VUID0gNjAwMDA7IC8vIG1zXG4vLyBUT0RPOiBtYWtlIHRpbWVvdXQgYSBjb25maWd1cmF0aW9uIHNldHRpbmdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gIHZhciBlbWl0dGVyID0gZXZlbnRFbWl0dGVyKHtcbiAgICBzb2NrZXQ6IHNvY2tldCxcbiAgICBzZW5kOiBzZW5kLFxuICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNlbmQgYW4gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gc2VuZCAoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZW52ZWxvcGUgPSB7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfTtcbiAgICBkZWJ1Zygnc2VuZCcsIGVudmVsb3BlKTtcbiAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShlbnZlbG9wZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYW4gZXZlbnQsIGF3YWl0IGEgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIHRoZSByZXBseVxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdCAoZXZlbnQsIGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLy8gcHV0IHRoZSBkYXRhIGluIGFuIGVudmVsb3BlIHdpdGggaWRcbiAgICAgIHZhciBpZCA9IGdldElkKCk7XG4gICAgICB2YXIgZW52ZWxvcGUgPSB7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9O1xuXG4gICAgICAvLyBhZGQgdGhlIHJlcXVlc3QgdG8gdGhlIGxpc3Qgd2l0aCByZXF1ZXN0cyBpbiBwcm9ncmVzc1xuICAgICAgcXVldWVbaWRdID0ge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICByZWplY3Q6IHJlamVjdCxcbiAgICAgICAgdGltZW91dDogc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0JykpO1xuICAgICAgICB9LCBUSU1FT1VUKVxuICAgICAgfTtcblxuICAgICAgZGVidWcoJ3JlcXVlc3QnLCBlbnZlbG9wZSk7XG4gICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShlbnZlbG9wZSkpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtjb25zb2xlLmxvZygnRVJST1InLCBlcnIpfSk7XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciwgaGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICovXG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgdmFyIGVudmVsb3BlID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICBkZWJ1ZygncmVjZWl2ZScsIGVudmVsb3BlKTtcblxuICAgIC8vIG1hdGNoIHRoZSByZXF1ZXN0IGZyb20gdGhlIGlkIGluIHRoZSByZXNwb25zZVxuICAgIHZhciByZXF1ZXN0ID0gcXVldWVbZW52ZWxvcGUuaWRdO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAvLyBpbmNvbWluZyByZXNwb25zZVxuICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICBkZWxldGUgcXVldWVbZW52ZWxvcGUuaWRdO1xuICAgICAgcmVxdWVzdC5yZXNvbHZlKGVudmVsb3BlLmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnaWQnIGluIGVudmVsb3BlKSB7XG4gICAgICAvLyBpbmNvbWluZyByZXF1ZXN0XG4gICAgICBlbWl0dGVyLmVtaXQoZW52ZWxvcGUuZXZlbnQsIGVudmVsb3BlLmRhdGEsIGZ1bmN0aW9uIChyZXBseSkge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgaWQ6IGVudmVsb3BlLmlkLFxuICAgICAgICAgIGRhdGE6IHJlcGx5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBzb2NrZXQuT1BFTiB8fCBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gc29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICBkZWJ1ZygncmVwbHknLCByZXNwb25zZSk7XG4gICAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnY2FuY2VsIHJlcGx5JywgcmVzcG9uc2UsICcoc29ja2V0IGlzIGNsb3NlZCknKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gcmVndWxhciBpbmNvbWluZyBtZXNzYWdlXG4gICAgICBlbWl0dGVyLmVtaXQoZW52ZWxvcGUuZXZlbnQsIGVudmVsb3BlLmRhdGEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcXVldWUgPSB7fTsgICAvLyBxdWV1ZSB3aXRoIHJlcXVlc3RzIGluIHByb2dyZXNzXG5cbiAgLy8gZ2V0IGEgdW5pcXVlIGlkIChzaW1wbGUgY291bnRlcilcbiAgZnVuY3Rpb24gZ2V0SWQgKCkge1xuICAgIHJldHVybiBfaWQrKztcbiAgfVxuICB2YXIgX2lkID0gMDtcblxuICByZXR1cm4gZW1pdHRlcjtcbn07XG5cbn0se1wiLi4vZGVidWdcIjozMyxcIi4vLi4vUHJvbWlzZVwiOjMyLFwiZXZlbnQtZW1pdHRlclwiOjMwfV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gYmFzaWMgc3RhdGlzdGljYWwgZnVuY3Rpb25zXG5cbmV4cG9ydHMuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn07XG5cbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGEgKyBiO1xufTtcblxuZXhwb3J0cy5zdW0gPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKGV4cG9ydHMuYWRkKTtcbn07XG5cbmV4cG9ydHMubWVhbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIGV4cG9ydHMuc3VtKGFycikgLyBhcnIubGVuZ3RoO1xufTtcblxuZXhwb3J0cy5zdGQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZXhwb3J0cy52YXJpYW5jZShhcnIpKTtcbn07XG5cbmV4cG9ydHMudmFyaWFuY2UgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG5cbiAgdmFyIF9tZWFuID0gZXhwb3J0cy5tZWFuKGFycik7XG4gIHJldHVybiBhcnJcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coeCAtIF9tZWFuLCAyKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlZHVjZShleHBvcnRzLmFkZCkgLyAoYXJyLmxlbmd0aCAtIDEpO1xufTtcblxuZXhwb3J0cy5tZWRpYW4gPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoIDwgMikgcmV0dXJuIGFyclswXTtcblxuICB2YXIgc29ydGVkID0gYXJyLnNsaWNlKCkuc29ydChleHBvcnRzLmNvbXBhcmUpO1xuICBpZiAoc29ydGVkLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAvLyBldmVuXG4gICAgcmV0dXJuIChhcnJbYXJyLmxlbmd0aCAvIDIgLSAxXSArIGFyclthcnIubGVuZ3RoIC8gMl0pIC8gMjtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBvZGRcbiAgICByZXR1cm4gYXJyWyhhcnIubGVuZ3RoIC0gMSkgLyAyXTtcbiAgfVxufTtcblxufSx7fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLi9Qcm9taXNlJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBhIHByb21pc2UgYWZ0ZXIgYSBkZWxheVxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5ICAgIEEgZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUmVzb2x2ZXMgYWZ0ZXIgZ2l2ZW4gZGVsYXlcbiAqL1xuZXhwb3J0cy53YWl0ID0gZnVuY3Rpb24oZGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXBlYXQgYSBnaXZlbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gYSBudW1iZXIgb2YgdGltZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuICAgQSBmdW5jdGlvbiByZXR1cm5pbmcgYSBwcm9taXNlXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZXNcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMucmVwZWF0ID0gZnVuY3Rpb24gKGZuLCB0aW1lcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHJlY3Vyc2UoKSB7XG4gICAgICBpZiAoY291bnQgPCB0aW1lcykge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBmbigpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgIHJlY3Vyc2UoKTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlY3Vyc2UoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlcGVhdCBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2sgZnVuY3Rpb24gd2hpbHN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gICBBIGZ1bmN0aW9uIHJldHVybmluZyB0cnVlIG9yIGZhbHNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgICBBIGNhbGxiYWNrIHJldHVybmluZyBhIFByb21pc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5leHBvcnRzLndoaWxzdCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gcmVjdXJzZSgpIHtcbiAgICAgIGlmIChjb25kaXRpb24oKSkge1xuICAgICAgICBjYWxsYmFjaygpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlY3Vyc2UoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjdXJzZSgpO1xuICB9KTtcbn07XG5cbn0se1wiLi4vUHJvbWlzZVwiOjMyfV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHR5cGVvZiBEYXRlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgY3VycmVudCB0aW1lXG4gICAqIEByZXR1cm4ge251bWJlcn0gQ3VycmVudCB0aW1lXG4gICAqL1xuICBleHBvcnRzLnN5c3RlbU5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfVxufVxuZWxzZSB7XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVcbiAgICogQHJldHVybiB7bnVtYmVyfSBDdXJyZW50IHRpbWVcbiAgICovXG4gIGV4cG9ydHMuc3lzdGVtTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNodWZmbGUgYW4gYXJyYXlcbiAqXG4gKiArIEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YVxuICogQCBodHRwOi8vanNmcm9taGVsbC5jb20vYXJyYXkvc2h1ZmZsZSBbdjEuMF1cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBvICAgQXJyYXkgdG8gYmUgc2h1ZmZsZWRcbiAqIEByZXR1cm5zIHtBcnJheX0gICBSZXR1cm5zIHRoZSBzaHVmZmxlZCBhcnJheVxuICovXG5leHBvcnRzLnNodWZmbGUgPSBmdW5jdGlvbiAobyl7XG4gIGZvcih2YXIgaiwgeCwgaSA9IG8ubGVuZ3RoOyBpOyBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSksIHggPSBvWy0taV0sIG9baV0gPSBvW2pdLCBvW2pdID0geCk7XG4gIHJldHVybiBvO1xufTtcblxufSx7fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG5cdC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG5cdHJldHVybiB0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiZcblx0XHRjb25zb2xlLmxvZyAmJlxuXHRcdGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIi4vY29tbW9uXCI6NDMsXCJfcHJvY2Vzc1wiOjYzfV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0Ly8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5cdFx0Ly8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuXG5cdFx0Ly8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc3QgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcblx0XHRcdGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG5cbn0se1wibXNcIjo0NH1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuXG59LHt9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKVxuXG59LHtcIi4vbGliXCI6NTB9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcC9yYXcnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFN0YXRlczpcbi8vXG4vLyAwIC0gcGVuZGluZ1xuLy8gMSAtIGZ1bGZpbGxlZCB3aXRoIF92YWx1ZVxuLy8gMiAtIHJlamVjdGVkIHdpdGggX3ZhbHVlXG4vLyAzIC0gYWRvcHRlZCB0aGUgc3RhdGUgb2YgYW5vdGhlciBwcm9taXNlLCBfdmFsdWVcbi8vXG4vLyBvbmNlIHRoZSBzdGF0ZSBpcyBubyBsb25nZXIgcGVuZGluZyAoMCkgaXQgaXMgaW1tdXRhYmxlXG5cbi8vIEFsbCBgX2AgcHJlZml4ZWQgcHJvcGVydGllcyB3aWxsIGJlIHJlZHVjZWQgdG8gYF97cmFuZG9tIG51bWJlcn1gXG4vLyBhdCBidWlsZCB0aW1lIHRvIG9iZnVzY2F0ZSB0aGVtIGFuZCBkaXNjb3VyYWdlIHRoZWlyIHVzZS5cbi8vIFdlIGRvbid0IHVzZSBzeW1ib2xzIG9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBmdWxseSBoaWRlIHRoZW1cbi8vIGJlY2F1c2UgdGhlIHBlcmZvcm1hbmNlIGlzbid0IGdvb2QgZW5vdWdoLlxuXG5cbi8vIHRvIGF2b2lkIHVzaW5nIHRyeS9jYXRjaCBpbnNpZGUgY3JpdGljYWwgZnVuY3Rpb25zLCB3ZVxuLy8gZXh0cmFjdCB0aGVtIHRvIGhlcmUuXG52YXIgTEFTVF9FUlJPUiA9IG51bGw7XG52YXIgSVNfRVJST1IgPSB7fTtcbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2FsbE9uZShmbiwgYSkge1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5mdW5jdGlvbiB0cnlDYWxsVHdvKGZuLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgZm4oYSwgYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICB9XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuXzM3ID0gMDtcbiAgdGhpcy5fMTIgPSBudWxsO1xuICB0aGlzLl81OSA9IFtdO1xuICBpZiAoZm4gPT09IG5vb3ApIHJldHVybjtcbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblByb21pc2UuXzk5ID0gbm9vcDtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBQcm9taXNlKSB7XG4gICAgcmV0dXJuIHNhZmVUaGVuKHRoaXMsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gIGhhbmRsZSh0aGlzLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzKSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBzYWZlVGhlbihzZWxmLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICByZXR1cm4gbmV3IHNlbGYuY29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXMgPSBuZXcgUHJvbWlzZShub29wKTtcbiAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIGhhbmRsZShzZWxmLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzKSk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICB3aGlsZSAoc2VsZi5fMzcgPT09IDMpIHtcbiAgICBzZWxmID0gc2VsZi5fMTI7XG4gIH1cbiAgaWYgKHNlbGYuXzM3ID09PSAwKSB7XG4gICAgc2VsZi5fNTkucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzYXAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNiID0gc2VsZi5fMzcgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICBpZiAoc2VsZi5fMzcgPT09IDEpIHtcbiAgICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl8xMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fMTIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gdHJ5Q2FsbE9uZShjYiwgc2VsZi5fMTIpO1xuICAgIGlmIChyZXQgPT09IElTX0VSUk9SKSB7XG4gICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgTEFTVF9FUlJPUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHtcbiAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgc2VsZixcbiAgICAgIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJylcbiAgICApO1xuICB9XG4gIGlmIChcbiAgICBuZXdWYWx1ZSAmJlxuICAgICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgKSB7XG4gICAgdmFyIHRoZW4gPSBnZXRUaGVuKG5ld1ZhbHVlKTtcbiAgICBpZiAodGhlbiA9PT0gSVNfRVJST1IpIHtcbiAgICAgIHJldHVybiByZWplY3Qoc2VsZiwgTEFTVF9FUlJPUik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoZW4gPT09IHNlbGYudGhlbiAmJlxuICAgICAgbmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlXG4gICAgKSB7XG4gICAgICBzZWxmLl8zNyA9IDM7XG4gICAgICBzZWxmLl8xMiA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRvUmVzb2x2ZSh0aGVuLmJpbmQobmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc2VsZi5fMzcgPSAxO1xuICBzZWxmLl8xMiA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5cbmZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICBzZWxmLl8zNyA9IDI7XG4gIHNlbGYuXzEyID0gbmV3VmFsdWU7XG4gIGZpbmFsZShzZWxmKTtcbn1cbmZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fNTkubGVuZ3RoOyBpKyspIHtcbiAgICBoYW5kbGUoc2VsZiwgc2VsZi5fNTlbaV0pO1xuICB9XG4gIHNlbGYuXzU5ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSl7XG4gIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG59XG5cbi8qKlxuICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAqL1xuZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBwcm9taXNlKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciByZXMgPSB0cnlDYWxsVHdvKGZuLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgfSlcbiAgaWYgKCFkb25lICYmIHJlcyA9PT0gSVNfRVJST1IpIHtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3QocHJvbWlzZSwgTEFTVF9FUlJPUik7XG4gIH1cbn1cblxufSx7XCJhc2FwL3Jhd1wiOjJ9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzO1xuICBzZWxmLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0sIDApO1xuICB9KTtcbn07XG5cbn0se1wiLi9jb3JlLmpzXCI6NDZ9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBFUzYgZXh0ZW5zaW9ucyB0byB0aGUgY29yZSBQcm9taXNlcy9BKyBBUElcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cbnZhciBUUlVFID0gdmFsdWVQcm9taXNlKHRydWUpO1xudmFyIEZBTFNFID0gdmFsdWVQcm9taXNlKGZhbHNlKTtcbnZhciBOVUxMID0gdmFsdWVQcm9taXNlKG51bGwpO1xudmFyIFVOREVGSU5FRCA9IHZhbHVlUHJvbWlzZSh1bmRlZmluZWQpO1xudmFyIFpFUk8gPSB2YWx1ZVByb21pc2UoMCk7XG52YXIgRU1QVFlTVFJJTkcgPSB2YWx1ZVByb21pc2UoJycpO1xuXG5mdW5jdGlvbiB2YWx1ZVByb21pc2UodmFsdWUpIHtcbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShQcm9taXNlLl85OSk7XG4gIHAuXzM3ID0gMTtcbiAgcC5fMTIgPSB2YWx1ZTtcbiAgcmV0dXJuIHA7XG59XG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIE5VTEw7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gVU5ERUZJTkVEO1xuICBpZiAodmFsdWUgPT09IHRydWUpIHJldHVybiBUUlVFO1xuICBpZiAodmFsdWUgPT09IGZhbHNlKSByZXR1cm4gRkFMU0U7XG4gIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIFpFUk87XG4gIGlmICh2YWx1ZSA9PT0gJycpIHJldHVybiBFTVBUWVNUUklORztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoZW4gPSB2YWx1ZS50aGVuO1xuICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVQcm9taXNlKHZhbHVlKTtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb21pc2UgJiYgdmFsLnRoZW4gPT09IFByb21pc2UucHJvdG90eXBlLnRoZW4pIHtcbiAgICAgICAgICB3aGlsZSAodmFsLl8zNyA9PT0gMykge1xuICAgICAgICAgICAgdmFsID0gdmFsLl8xMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbC5fMzcgPT09IDEpIHJldHVybiByZXMoaSwgdmFsLl8xMik7XG4gICAgICAgICAgaWYgKHZhbC5fMzcgPT09IDIpIHJlamVjdCh2YWwuXzEyKTtcbiAgICAgICAgICB2YWwudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsKSk7XG4gICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdCh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qIFByb3RvdHlwZSBNZXRob2RzICovXG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG5cbn0se1wiLi9jb3JlLmpzXCI6NDZ9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZigpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZigpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG59LHtcIi4vY29yZS5qc1wiOjQ2fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xucmVxdWlyZSgnLi9kb25lLmpzJyk7XG5yZXF1aXJlKCcuL2ZpbmFsbHkuanMnKTtcbnJlcXVpcmUoJy4vZXM2LWV4dGVuc2lvbnMuanMnKTtcbnJlcXVpcmUoJy4vbm9kZS1leHRlbnNpb25zLmpzJyk7XG5cbn0se1wiLi9jb3JlLmpzXCI6NDYsXCIuL2RvbmUuanNcIjo0NyxcIi4vZXM2LWV4dGVuc2lvbnMuanNcIjo0OCxcIi4vZmluYWxseS5qc1wiOjQ5LFwiLi9ub2RlLWV4dGVuc2lvbnMuanNcIjo1MX1dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIHRoZW4vcHJvbWlzZSBzcGVjaWZpYyBleHRlbnNpb25zIHRoYXQgYXJlIG9ubHkgdXNlZnVsXG4vLyBmb3Igbm9kZS5qcyBpbnRlcm9wXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cblByb21pc2UuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGZuLCBhcmd1bWVudENvdW50KSB7XG4gIGFyZ3VtZW50Q291bnQgPSBhcmd1bWVudENvdW50IHx8IEluZmluaXR5O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCxcbiAgICAgICAgYXJndW1lbnRDb3VudCA+IDAgPyBhcmd1bWVudENvdW50IDogMCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgIGVsc2UgcmVzb2x2ZShyZXMpO1xuICAgICAgfSlcbiAgICAgIHZhciByZXMgPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIGlmIChyZXMgJiZcbiAgICAgICAgKFxuICAgICAgICAgIHR5cGVvZiByZXMgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIHJlcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApICYmXG4gICAgICAgIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5Qcm9taXNlLm5vZGVpZnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGNhbGxiYWNrID1cbiAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicgPyBhcmdzLnBvcCgpIDogbnVsbDtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykubm9kZWlmeShjYWxsYmFjaywgY3R4KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGV4KTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2suY2FsbChjdHgsIG51bGwsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVycik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG59LHtcIi4vY29yZS5qc1wiOjQ2LFwiYXNhcFwiOjF9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5hcmd1bWVudHNbNF1bNDVdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxufSx7XCIuL2xpYlwiOjU3LFwiZHVwXCI6NDV9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcC9yYXcnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFN0YXRlczpcbi8vXG4vLyAwIC0gcGVuZGluZ1xuLy8gMSAtIGZ1bGZpbGxlZCB3aXRoIF92YWx1ZVxuLy8gMiAtIHJlamVjdGVkIHdpdGggX3ZhbHVlXG4vLyAzIC0gYWRvcHRlZCB0aGUgc3RhdGUgb2YgYW5vdGhlciBwcm9taXNlLCBfdmFsdWVcbi8vXG4vLyBvbmNlIHRoZSBzdGF0ZSBpcyBubyBsb25nZXIgcGVuZGluZyAoMCkgaXQgaXMgaW1tdXRhYmxlXG5cbi8vIEFsbCBgX2AgcHJlZml4ZWQgcHJvcGVydGllcyB3aWxsIGJlIHJlZHVjZWQgdG8gYF97cmFuZG9tIG51bWJlcn1gXG4vLyBhdCBidWlsZCB0aW1lIHRvIG9iZnVzY2F0ZSB0aGVtIGFuZCBkaXNjb3VyYWdlIHRoZWlyIHVzZS5cbi8vIFdlIGRvbid0IHVzZSBzeW1ib2xzIG9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBmdWxseSBoaWRlIHRoZW1cbi8vIGJlY2F1c2UgdGhlIHBlcmZvcm1hbmNlIGlzbid0IGdvb2QgZW5vdWdoLlxuXG5cbi8vIHRvIGF2b2lkIHVzaW5nIHRyeS9jYXRjaCBpbnNpZGUgY3JpdGljYWwgZnVuY3Rpb25zLCB3ZVxuLy8gZXh0cmFjdCB0aGVtIHRvIGhlcmUuXG52YXIgTEFTVF9FUlJPUiA9IG51bGw7XG52YXIgSVNfRVJST1IgPSB7fTtcbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2FsbE9uZShmbiwgYSkge1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5mdW5jdGlvbiB0cnlDYWxsVHdvKGZuLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgZm4oYSwgYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICB9XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuXzQ1ID0gMDtcbiAgdGhpcy5fODEgPSAwO1xuICB0aGlzLl82NSA9IG51bGw7XG4gIHRoaXMuXzU0ID0gbnVsbDtcbiAgaWYgKGZuID09PSBub29wKSByZXR1cm47XG4gIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG59XG5Qcm9taXNlLl8xMCA9IG51bGw7XG5Qcm9taXNlLl85NyA9IG51bGw7XG5Qcm9taXNlLl82MSA9IG5vb3A7XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gUHJvbWlzZSkge1xuICAgIHJldHVybiBzYWZlVGhlbih0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKG5vb3ApO1xuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gc2FmZVRoZW4oc2VsZiwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIG5ldyBzZWxmLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICBoYW5kbGUoc2VsZiwgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgd2hpbGUgKHNlbGYuXzgxID09PSAzKSB7XG4gICAgc2VsZiA9IHNlbGYuXzY1O1xuICB9XG4gIGlmIChQcm9taXNlLl8xMCkge1xuICAgIFByb21pc2UuXzEwKHNlbGYpO1xuICB9XG4gIGlmIChzZWxmLl84MSA9PT0gMCkge1xuICAgIGlmIChzZWxmLl80NSA9PT0gMCkge1xuICAgICAgc2VsZi5fNDUgPSAxO1xuICAgICAgc2VsZi5fNTQgPSBkZWZlcnJlZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuXzQ1ID09PSAxKSB7XG4gICAgICBzZWxmLl80NSA9IDI7XG4gICAgICBzZWxmLl81NCA9IFtzZWxmLl81NCwgZGVmZXJyZWRdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl81NC5wdXNoKGRlZmVycmVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaGFuZGxlUmVzb2x2ZWQoc2VsZiwgZGVmZXJyZWQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVSZXNvbHZlZChzZWxmLCBkZWZlcnJlZCkge1xuICBhc2FwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuXzgxID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgaWYgKHNlbGYuXzgxID09PSAxKSB7XG4gICAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fNjUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIHNlbGYuXzY1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhbGxPbmUoY2IsIHNlbGYuXzY1KTtcbiAgICBpZiAocmV0ID09PSBJU19FUlJPUikge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIExBU1RfRVJST1IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB7XG4gICAgcmV0dXJuIHJlamVjdChcbiAgICAgIHNlbGYsXG4gICAgICBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgbmV3VmFsdWUgJiZcbiAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICkge1xuICAgIHZhciB0aGVuID0gZ2V0VGhlbihuZXdWYWx1ZSk7XG4gICAgaWYgKHRoZW4gPT09IElTX0VSUk9SKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHNlbGYsIExBU1RfRVJST1IpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0aGVuID09PSBzZWxmLnRoZW4gJiZcbiAgICAgIG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVxuICAgICkge1xuICAgICAgc2VsZi5fODEgPSAzO1xuICAgICAgc2VsZi5fNjUgPSBuZXdWYWx1ZTtcbiAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkb1Jlc29sdmUodGhlbi5iaW5kKG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbGYuXzgxID0gMTtcbiAgc2VsZi5fNjUgPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fODEgPSAyO1xuICBzZWxmLl82NSA9IG5ld1ZhbHVlO1xuICBpZiAoUHJvbWlzZS5fOTcpIHtcbiAgICBQcm9taXNlLl85NyhzZWxmLCBuZXdWYWx1ZSk7XG4gIH1cbiAgZmluYWxlKHNlbGYpO1xufVxuZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgaWYgKHNlbGYuXzQ1ID09PSAxKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuXzU0KTtcbiAgICBzZWxmLl81NCA9IG51bGw7XG4gIH1cbiAgaWYgKHNlbGYuXzQ1ID09PSAyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl81NC5sZW5ndGg7IGkrKykge1xuICAgICAgaGFuZGxlKHNlbGYsIHNlbGYuXzU0W2ldKTtcbiAgICB9XG4gICAgc2VsZi5fNTQgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2Upe1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgcHJvbWlzZSkge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgcmVzID0gdHJ5Q2FsbFR3byhmbiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIH0pXG4gIGlmICghZG9uZSAmJiByZXMgPT09IElTX0VSUk9SKSB7XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIExBU1RfRVJST1IpO1xuICB9XG59XG5cbn0se1wiYXNhcC9yYXdcIjoyfV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuYXJndW1lbnRzWzRdWzQ3XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcbn0se1wiLi9jb3JlLmpzXCI6NTMsXCJkdXBcIjo0N31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGZpbGUgY29udGFpbnMgdGhlIEVTNiBleHRlbnNpb25zIHRvIHRoZSBjb3JlIFByb21pc2VzL0ErIEFQSVxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxudmFyIFRSVUUgPSB2YWx1ZVByb21pc2UodHJ1ZSk7XG52YXIgRkFMU0UgPSB2YWx1ZVByb21pc2UoZmFsc2UpO1xudmFyIE5VTEwgPSB2YWx1ZVByb21pc2UobnVsbCk7XG52YXIgVU5ERUZJTkVEID0gdmFsdWVQcm9taXNlKHVuZGVmaW5lZCk7XG52YXIgWkVSTyA9IHZhbHVlUHJvbWlzZSgwKTtcbnZhciBFTVBUWVNUUklORyA9IHZhbHVlUHJvbWlzZSgnJyk7XG5cbmZ1bmN0aW9uIHZhbHVlUHJvbWlzZSh2YWx1ZSkge1xuICB2YXIgcCA9IG5ldyBQcm9taXNlKFByb21pc2UuXzYxKTtcbiAgcC5fODEgPSAxO1xuICBwLl82NSA9IHZhbHVlO1xuICByZXR1cm4gcDtcbn1cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gdmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gTlVMTDtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBVTkRFRklORUQ7XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkgcmV0dXJuIFRSVUU7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHJldHVybiBGQUxTRTtcbiAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gWkVSTztcbiAgaWYgKHZhbHVlID09PSAnJykgcmV0dXJuIEVNUFRZU1RSSU5HO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHZhbHVlLnRoZW47XG4gICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3QoZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZVByb21pc2UodmFsdWUpO1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUHJvbWlzZSAmJiB2YWwudGhlbiA9PT0gUHJvbWlzZS5wcm90b3R5cGUudGhlbikge1xuICAgICAgICAgIHdoaWxlICh2YWwuXzgxID09PSAzKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuXzY1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsLl84MSA9PT0gMSkgcmV0dXJuIHJlcyhpLCB2YWwuXzY1KTtcbiAgICAgICAgICBpZiAodmFsLl84MSA9PT0gMikgcmVqZWN0KHZhbC5fNjUpO1xuICAgICAgICAgIHZhbC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWwpKTtcbiAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgfVxuICB9KTtcbn07XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpe1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyogUHJvdG90eXBlIE1ldGhvZHMgKi9cblxuUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblxufSx7XCIuL2NvcmUuanNcIjo1M31dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmFyZ3VtZW50c1s0XVs0OV1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXG59LHtcIi4vY29yZS5qc1wiOjUzLFwiZHVwXCI6NDl9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5yZXF1aXJlKCcuL2RvbmUuanMnKTtcbnJlcXVpcmUoJy4vZmluYWxseS5qcycpO1xucmVxdWlyZSgnLi9lczYtZXh0ZW5zaW9ucy5qcycpO1xucmVxdWlyZSgnLi9ub2RlLWV4dGVuc2lvbnMuanMnKTtcbnJlcXVpcmUoJy4vc3luY2hyb25vdXMuanMnKTtcblxufSx7XCIuL2NvcmUuanNcIjo1MyxcIi4vZG9uZS5qc1wiOjU0LFwiLi9lczYtZXh0ZW5zaW9ucy5qc1wiOjU1LFwiLi9maW5hbGx5LmpzXCI6NTYsXCIuL25vZGUtZXh0ZW5zaW9ucy5qc1wiOjU4LFwiLi9zeW5jaHJvbm91cy5qc1wiOjU5fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgdGhlbi9wcm9taXNlIHNwZWNpZmljIGV4dGVuc2lvbnMgdGhhdCBhcmUgb25seSB1c2VmdWxcbi8vIGZvciBub2RlLmpzIGludGVyb3BcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxuUHJvbWlzZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoZm4sIGFyZ3VtZW50Q291bnQpIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBhcmd1bWVudENvdW50ID09PSAnbnVtYmVyJyAmJiBhcmd1bWVudENvdW50ICE9PSBJbmZpbml0eVxuICApIHtcbiAgICByZXR1cm4gZGVub2RlaWZ5V2l0aENvdW50KGZuLCBhcmd1bWVudENvdW50KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVub2RlaWZ5V2l0aG91dENvdW50KGZuKTtcbiAgfVxufVxuXG52YXIgY2FsbGJhY2tGbiA9IChcbiAgJ2Z1bmN0aW9uIChlcnIsIHJlcykgeycgK1xuICAnaWYgKGVycikgeyByaihlcnIpOyB9IGVsc2UgeyBycyhyZXMpOyB9JyArXG4gICd9J1xuKTtcbmZ1bmN0aW9uIGRlbm9kZWlmeVdpdGhDb3VudChmbiwgYXJndW1lbnRDb3VudCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50Q291bnQ7IGkrKykge1xuICAgIGFyZ3MucHVzaCgnYScgKyBpKTtcbiAgfVxuICB2YXIgYm9keSA9IFtcbiAgICAncmV0dXJuIGZ1bmN0aW9uICgnICsgYXJncy5qb2luKCcsJykgKyAnKSB7JyxcbiAgICAndmFyIHNlbGYgPSB0aGlzOycsXG4gICAgJ3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocnMsIHJqKSB7JyxcbiAgICAndmFyIHJlcyA9IGZuLmNhbGwoJyxcbiAgICBbJ3NlbGYnXS5jb25jYXQoYXJncykuY29uY2F0KFtjYWxsYmFja0ZuXSkuam9pbignLCcpLFxuICAgICcpOycsXG4gICAgJ2lmIChyZXMgJiYnLFxuICAgICcodHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcmVzID09PSBcImZ1bmN0aW9uXCIpICYmJyxcbiAgICAndHlwZW9mIHJlcy50aGVuID09PSBcImZ1bmN0aW9uXCInLFxuICAgICcpIHtycyhyZXMpO30nLFxuICAgICd9KTsnLFxuICAgICd9OydcbiAgXS5qb2luKCcnKTtcbiAgcmV0dXJuIEZ1bmN0aW9uKFsnUHJvbWlzZScsICdmbiddLCBib2R5KShQcm9taXNlLCBmbik7XG59XG5mdW5jdGlvbiBkZW5vZGVpZnlXaXRob3V0Q291bnQoZm4pIHtcbiAgdmFyIGZuTGVuZ3RoID0gTWF0aC5tYXgoZm4ubGVuZ3RoIC0gMSwgMyk7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5MZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaCgnYScgKyBpKTtcbiAgfVxuICB2YXIgYm9keSA9IFtcbiAgICAncmV0dXJuIGZ1bmN0aW9uICgnICsgYXJncy5qb2luKCcsJykgKyAnKSB7JyxcbiAgICAndmFyIHNlbGYgPSB0aGlzOycsXG4gICAgJ3ZhciBhcmdzOycsXG4gICAgJ3ZhciBhcmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOycsXG4gICAgJ2lmIChhcmd1bWVudHMubGVuZ3RoID4gJyArIGZuTGVuZ3RoICsgJykgeycsXG4gICAgJ2FyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCArIDEpOycsXG4gICAgJ2ZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7JyxcbiAgICAnYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsnLFxuICAgICd9JyxcbiAgICAnfScsXG4gICAgJ3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocnMsIHJqKSB7JyxcbiAgICAndmFyIGNiID0gJyArIGNhbGxiYWNrRm4gKyAnOycsXG4gICAgJ3ZhciByZXM7JyxcbiAgICAnc3dpdGNoIChhcmdMZW5ndGgpIHsnLFxuICAgIGFyZ3MuY29uY2F0KFsnZXh0cmEnXSkubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJ2Nhc2UgJyArIChpbmRleCkgKyAnOicgK1xuICAgICAgICAncmVzID0gZm4uY2FsbCgnICsgWydzZWxmJ10uY29uY2F0KGFyZ3Muc2xpY2UoMCwgaW5kZXgpKS5jb25jYXQoJ2NiJykuam9pbignLCcpICsgJyk7JyArXG4gICAgICAgICdicmVhazsnXG4gICAgICApO1xuICAgIH0pLmpvaW4oJycpLFxuICAgICdkZWZhdWx0OicsXG4gICAgJ2FyZ3NbYXJnTGVuZ3RoXSA9IGNiOycsXG4gICAgJ3JlcyA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOycsXG4gICAgJ30nLFxuICAgIFxuICAgICdpZiAocmVzICYmJyxcbiAgICAnKHR5cGVvZiByZXMgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJlcyA9PT0gXCJmdW5jdGlvblwiKSAmJicsXG4gICAgJ3R5cGVvZiByZXMudGhlbiA9PT0gXCJmdW5jdGlvblwiJyxcbiAgICAnKSB7cnMocmVzKTt9JyxcbiAgICAnfSk7JyxcbiAgICAnfTsnXG4gIF0uam9pbignJyk7XG5cbiAgcmV0dXJuIEZ1bmN0aW9uKFxuICAgIFsnUHJvbWlzZScsICdmbiddLFxuICAgIGJvZHlcbiAgKShQcm9taXNlLCBmbik7XG59XG5cblByb21pc2Uubm9kZWlmeSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPVxuICAgICAgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJyA/IGFyZ3MucG9wKCkgOiBudWxsO1xuICAgIHZhciBjdHggPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKS5ub2RlaWZ5KGNhbGxiYWNrLCBjdHgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXgpO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGN0eCwgbnVsbCwgdmFsdWUpO1xuICAgIH0pO1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbn0se1wiLi9jb3JlLmpzXCI6NTMsXCJhc2FwXCI6MX1dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuUHJvbWlzZS5lbmFibGVTeW5jaHJvbm91cyA9IGZ1bmN0aW9uICgpIHtcbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKSA9PSAwO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKSA9PSAxO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpID09IDI7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuXzgxID09PSAzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fNjUuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGEgdmFsdWUgb2YgYW4gdW5mdWxmaWxsZWQgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fNjU7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0UmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl84MSA9PT0gMykge1xuICAgICAgcmV0dXJuIHRoaXMuXzY1LmdldFJlYXNvbigpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBhIHJlamVjdGlvbiByZWFzb24gb2YgYSBub24tcmVqZWN0ZWQgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fNjU7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuXzgxID09PSAzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fNjUuZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuXzgxID09PSAtMSB8fCB0aGlzLl84MSA9PT0gLTIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl84MTtcbiAgfTtcbn07XG5cblByb21pc2UuZGlzYWJsZVN5bmNocm9ub3VzID0gZnVuY3Rpb24oKSB7XG4gIFByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmdldFZhbHVlID0gdW5kZWZpbmVkO1xuICBQcm9taXNlLnByb3RvdHlwZS5nZXRSZWFzb24gPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmdldFN0YXRlID0gdW5kZWZpbmVkO1xufTtcblxufSx7XCIuL2NvcmUuanNcIjo1M31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB3aWR0aCA9IDI1NjsvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XHJcbnZhciBjaHVua3MgPSA2Oy8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcclxudmFyIGRpZ2l0cyA9IDUyOy8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcclxudmFyIHBvb2wgPSBbXTsvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XHJcbnZhciBHTE9CQUwgPSB0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbDtcclxuXHJcbi8vXHJcbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cclxuLy9cclxudmFyIHN0YXJ0ZGVub20gPSBNYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcclxuICAgIHNpZ25pZmljYW5jZSA9IE1hdGgucG93KDIsIGRpZ2l0cyksXHJcbiAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXHJcbiAgICBtYXNrID0gd2lkdGggLSAxO1xyXG5cclxuXHJcbnZhciBvbGRSYW5kb20gPSBNYXRoLnJhbmRvbTtcclxuXHJcbi8vXHJcbi8vIHNlZWRyYW5kb20oKVxyXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cclxuLy9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWVkLCBvcHRpb25zKSB7XHJcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nbG9iYWwgPT09IHRydWUpIHtcclxuICAgIG9wdGlvbnMuZ2xvYmFsID0gZmFsc2U7XHJcbiAgICBNYXRoLnJhbmRvbSA9IG1vZHVsZS5leHBvcnRzKHNlZWQsIG9wdGlvbnMpO1xyXG4gICAgb3B0aW9ucy5nbG9iYWwgPSB0cnVlO1xyXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tO1xyXG4gIH1cclxuICB2YXIgdXNlX2VudHJvcHkgPSAob3B0aW9ucyAmJiBvcHRpb25zLmVudHJvcHkpIHx8IGZhbHNlO1xyXG4gIHZhciBrZXkgPSBbXTtcclxuXHJcbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXHJcbiAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKFxyXG4gICAgdXNlX2VudHJvcHkgPyBbc2VlZCwgdG9zdHJpbmcocG9vbCldIDpcclxuICAgIDAgaW4gYXJndW1lbnRzID8gc2VlZCA6IGF1dG9zZWVkKCksIDMpLCBrZXkpO1xyXG5cclxuICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cclxuICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XHJcblxyXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXHJcbiAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xyXG5cclxuICAvLyBPdmVycmlkZSBNYXRoLnJhbmRvbVxyXG5cclxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXHJcbiAgLy8gcmFuZG9tbmVzcyBpbiBldmVyeSBiaXQgb2YgdGhlIG1hbnRpc3NhIG9mIHRoZSBJRUVFIDc1NCB2YWx1ZS5cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAgICAgICAgIC8vIENsb3N1cmUgdG8gcmV0dXJuIGEgcmFuZG9tIGRvdWJsZTpcclxuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxyXG4gICAgICAgIGQgPSBzdGFydGRlbm9tLCAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cclxuICAgICAgICB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxyXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XHJcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcclxuICAgICAgZCAqPSB3aWR0aDsgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxyXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cclxuICAgIH1cclxuICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXHJcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xyXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIE1hdGggdW50aWxcclxuICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXHJcbiAgICB9XHJcbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cclxuICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMucmVzZXRHbG9iYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgTWF0aC5yYW5kb20gPSBvbGRSYW5kb207XHJcbn07XHJcblxyXG4vL1xyXG4vLyBBUkM0XHJcbi8vXHJcbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2ZcclxuLy8gYW4gYXJyYXkgb2YgYXQgbW9zdCAod2lkdGgpIGludGVnZXJzIHRoYXQgc2hvdWxkIGJlIDAgPD0geCA8ICh3aWR0aCkuXHJcbi8vXHJcbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXHJcbi8vIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBmcm9tIEFSQzQuICBJdHMgcmV0dXJuIHZhbHVlIGlzIGEgbnVtYmVyIHhcclxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxyXG4vL1xyXG4vKiogQGNvbnN0cnVjdG9yICovXHJcbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XHJcbiAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXHJcbiAgICAgIG1lID0gdGhpcywgaSA9IDAsIGogPSBtZS5pID0gbWUuaiA9IDAsIHMgPSBtZS5TID0gW107XHJcblxyXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXHJcbiAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxyXG5cclxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxyXG4gIHdoaWxlIChpIDwgd2lkdGgpIHtcclxuICAgIHNbaV0gPSBpKys7XHJcbiAgfVxyXG4gIGZvciAoaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XHJcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xyXG4gICAgc1tqXSA9IHQ7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXHJcbiAgKG1lLmcgPSBmdW5jdGlvbihjb3VudCkge1xyXG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXHJcbiAgICB2YXIgdCwgciA9IDAsXHJcbiAgICAgICAgaSA9IG1lLmksIGogPSBtZS5qLCBzID0gbWUuUztcclxuICAgIHdoaWxlIChjb3VudC0tKSB7XHJcbiAgICAgIHQgPSBzW2kgPSBtYXNrICYgKGkgKyAxKV07XHJcbiAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoKHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyB0KV0pICsgKHNbal0gPSB0KSldO1xyXG4gICAgfVxyXG4gICAgbWUuaSA9IGk7IG1lLmogPSBqO1xyXG4gICAgcmV0dXJuIHI7XHJcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHkgZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy5cclxuICAgIC8vIFNlZSBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMDA5XHJcbiAgfSkod2lkdGgpO1xyXG59XHJcblxyXG4vL1xyXG4vLyBmbGF0dGVuKClcclxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxyXG4vL1xyXG5mdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcclxuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKVswXSwgcHJvcDtcclxuICBpZiAoZGVwdGggJiYgdHlwID09ICdvJykge1xyXG4gICAgZm9yIChwcm9wIGluIG9iaikge1xyXG4gICAgICB0cnkgeyByZXN1bHQucHVzaChmbGF0dGVuKG9ialtwcm9wXSwgZGVwdGggLSAxKSk7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAocmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IHR5cCA9PSAncycgPyBvYmogOiBvYmogKyAnXFwwJyk7XHJcbn1cclxuXHJcbi8vXHJcbi8vIG1peGtleSgpXHJcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcclxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXHJcbi8vXHJcbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcclxuICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJywgc21lYXIsIGogPSAwO1xyXG4gIHdoaWxlIChqIDwgc3RyaW5nc2VlZC5sZW5ndGgpIHtcclxuICAgIGtleVttYXNrICYgal0gPVxyXG4gICAgICBtYXNrICYgKChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKykpO1xyXG4gIH1cclxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcclxufVxyXG5cclxuLy9cclxuLy8gYXV0b3NlZWQoKVxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCBmb3IgYXV0b3NlZWRpbmcsIHVzaW5nIHdpbmRvdy5jcnlwdG8gaWYgYXZhaWxhYmxlLlxyXG4vL1xyXG4vKiogQHBhcmFtIHtVaW50OEFycmF5PX0gc2VlZCAqL1xyXG5mdW5jdGlvbiBhdXRvc2VlZChzZWVkKSB7XHJcbiAgdHJ5IHtcclxuICAgIEdMT0JBTC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHNlZWQgPSBuZXcgVWludDhBcnJheSh3aWR0aCkpO1xyXG4gICAgcmV0dXJuIHRvc3RyaW5nKHNlZWQpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBbK25ldyBEYXRlLCBHTE9CQUwsIEdMT0JBTC5uYXZpZ2F0b3IgJiYgR0xPQkFMLm5hdmlnYXRvci5wbHVnaW5zLFxyXG4gICAgICAgICAgICBHTE9CQUwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XHJcbiAgfVxyXG59XHJcblxyXG4vL1xyXG4vLyB0b3N0cmluZygpXHJcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xyXG4vL1xyXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XHJcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XHJcbn1cclxuXHJcbi8vXHJcbi8vIFdoZW4gc2VlZHJhbmRvbS5qcyBpcyBsb2FkZWQsIHdlIGltbWVkaWF0ZWx5IG1peCBhIGZldyBiaXRzXHJcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXHJcbi8vIG5vdCB3YW50IHRvIGludGVmZXJlIHdpdGggZGV0ZXJtaW5zdGljIFBSTkcgc3RhdGUgbGF0ZXIsXHJcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBNYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXHJcbi8vIGluaXRpYWxpemF0aW9uLlxyXG4vL1xyXG5taXhrZXkoTWF0aC5yYW5kb20oKSwgcG9vbCk7XHJcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcmV0ID0gJycsIHZhbHVlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcblx0XHR2YWx1ZSA9IGV4cG9ydHMucmFuZG9tKCkgKiAxNiB8IDA7XG5cdFx0Ly8gSW5zZXJ0IHRoZSBoeXBlbnNcblx0XHRpZiAoaSA+IDQgJiYgaSA8IDIxICYmICEgKGkgJSA0KSkge1xuXHRcdFx0cmV0ICs9ICctJztcblx0XHR9XG5cdFx0Ly8gQWRkIHRoZSBuZXh0IHJhbmRvbSBjaGFyYWN0ZXJcblx0XHRyZXQgKz0gKFxuXHRcdFx0KGkgPT09IDEyKSA/IDQgOiAoXG5cdFx0XHRcdChpID09PSAxNikgPyAodmFsdWUgJiAzIHwgOCkgOiB2YWx1ZVxuXHRcdFx0KVxuXHRcdCkudG9TdHJpbmcoMTYpO1xuXHR9XG5cdHJldHVybiByZXQ7XG59O1xuXG52YXIgdXVpZFJlZ2V4ID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS00WzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9JC87XG5leHBvcnRzLmlzVVVJRCA9IGZ1bmN0aW9uKHV1aWQpIHtcblx0cmV0dXJuIHV1aWRSZWdleC50ZXN0KHV1aWQpO1xufTtcblxuZXhwb3J0cy5yYW5kb20gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIE1hdGgucmFuZG9tKCk7XG59O1xuXG5cbn0se31dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICdXZWJTb2NrZXQgb2JqZWN0J1xuICApO1xufTtcblxufSx7fV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxufSx7fV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG59LHt9XSw2NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxufSx7fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5cbn0se1wiLi9kZWNvZGVcIjo2NSxcIi4vZW5jb2RlXCI6NjZ9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxufSx7XCIuL3V0aWxcIjo2OSxcInB1bnljb2RlXCI6NjQsXCJxdWVyeXN0cmluZ1wiOjY3fV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG59LHt9XX0se30sWzIwXSkoMjApXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/directive.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\n/**\n * Brands a function as a directive factory function so that lit-html will call\n * the function during template rendering, rather than passing as a value.\n *\n * A _directive_ is a function that takes a Part as an argument. It has the\n * signature: `(part: Part) => void`.\n *\n * A directive _factory_ is a function that takes arguments for data and\n * configuration and returns a directive. Users of directive usually refer to\n * the directive factory as the directive. For example, \"The repeat directive\".\n *\n * Usually a template author will invoke a directive factory in their template\n * with relevant arguments, which will then return a directive function.\n *\n * Here's an example of using the `repeat()` directive factory that takes an\n * array and a function to render an item:\n *\n * ```js\n * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`\n * ```\n *\n * When `repeat` is invoked, it returns a directive function that closes over\n * `items` and the template function. When the outer template is rendered, the\n * return directive function is called with the Part for the expression.\n * `repeat` then performs it's custom logic to render multiple items.\n *\n * @param f The directive factory function. Must be a function that returns a\n * function of the signature `(part: Part) => void`. The returned function will\n * be called with the part object.\n *\n * @example\n *\n * import {directive, html} from 'lit-html';\n *\n * const immutable = directive((v) => (part) => {\n *   if (part.value !== v) {\n *     part.setValue(v)\n *   }\n * });\n */\nconst directive_directive = (f) => ((...args) => {\n    const d = f(...args);\n    directives.set(d, true);\n    return d;\n});\nconst isDirective = (o) => {\n    return typeof o === 'function' && directives.has(o);\n};\n//# sourceMappingURL=directive.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/dom.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * True if the custom elements polyfill is in use.\n */\nconst isCEPolyfill = window.customElements !== undefined &&\n    window.customElements.polyfillWrapFlushCallback !==\n        undefined;\n/**\n * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),\n * into another container (could be the same container), before `before`. If\n * `before` is null, it appends the nodes to the container.\n */\nconst reparentNodes = (container, start, end = null, before = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.insertBefore(start, before);\n        start = n;\n    }\n};\n/**\n * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from\n * `container`.\n */\nconst removeNodes = (container, start, end = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.removeChild(start);\n        start = n;\n    }\n};\n//# sourceMappingURL=dom.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/part.js\n/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nconst noChange = {};\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nconst nothing = {};\n//# sourceMappingURL=part.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nconst nodeMarker = `\x3c!--${marker}--\x3e`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nconst boundAttributeSuffix = '$lit$';\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nclass Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const nodesToRemove = [];\n        const stack = [];\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        // Keeps track of the last index associated with a part. We try to delete\n        // unnecessary nodes, but we never want to associate two different parts\n        // to the same index. They must have a constant node between.\n        let lastPartIndex = 0;\n        let index = -1;\n        let partIndex = 0;\n        const { strings, values: { length } } = result;\n        while (partIndex < length) {\n            const node = walker.nextNode();\n            if (node === null) {\n                // We've exhausted the content inside a nested template element.\n                // Because we still have parts (the outer for-loop), we know:\n                // - There is a template in the stack\n                // - The walker will find a nextNode outside the template\n                walker.currentNode = stack.pop();\n                continue;\n            }\n            index++;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (node.hasAttributes()) {\n                    const attributes = node.attributes;\n                    const { length } = attributes;\n                    // Per\n                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                    // attributes are not guaranteed to be returned in document order.\n                    // In particular, Edge/IE can return them out of order, so we cannot\n                    // assume a correspondence between part index and attribute index.\n                    let count = 0;\n                    for (let i = 0; i < length; i++) {\n                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n                            count++;\n                        }\n                    }\n                    while (count-- > 0) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute\n                        const stringForPart = strings[partIndex];\n                        // Find the attribute name\n                        const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                        // Find the corresponding attribute\n                        // All bound attributes have had a suffix added in\n                        // TemplateResult#getHTML to opt out of special attribute\n                        // handling. To look up the attribute value we also need to add\n                        // the suffix.\n                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n                        const attributeValue = node.getAttribute(attributeLookupName);\n                        node.removeAttribute(attributeLookupName);\n                        const statics = attributeValue.split(markerRegex);\n                        this.parts.push({ type: 'attribute', index, name, strings: statics });\n                        partIndex += statics.length - 1;\n                    }\n                }\n                if (node.tagName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const data = node.data;\n                if (data.indexOf(marker) >= 0) {\n                    const parent = node.parentNode;\n                    const strings = data.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        let insert;\n                        let s = strings[i];\n                        if (s === '') {\n                            insert = createMarker();\n                        }\n                        else {\n                            const match = lastAttributeNameRegex.exec(s);\n                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                                s = s.slice(0, match.index) + match[1] +\n                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n                            }\n                            insert = document.createTextNode(s);\n                        }\n                        parent.insertBefore(insert, node);\n                        this.parts.push({ type: 'node', index: ++index });\n                    }\n                    // If there's no text, we must insert a comment to mark our place.\n                    // Else, we can trust it will stick around after cloning.\n                    if (strings[lastIndex] === '') {\n                        parent.insertBefore(createMarker(), node);\n                        nodesToRemove.push(node);\n                    }\n                    else {\n                        node.data = strings[lastIndex];\n                    }\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                if (node.data === marker) {\n                    const parent = node.parentNode;\n                    // Add a new marker node to be the startNode of the Part if any of\n                    // the following are true:\n                    //  * We don't have a previousSibling\n                    //  * The previousSibling is already the start of a previous part\n                    if (node.previousSibling === null || index === lastPartIndex) {\n                        index++;\n                        parent.insertBefore(createMarker(), node);\n                    }\n                    lastPartIndex = index;\n                    this.parts.push({ type: 'node', index });\n                    // If we don't have a nextSibling, keep this node so we have an end.\n                    // Else, we can remove it to save future costs.\n                    if (node.nextSibling === null) {\n                        node.data = '';\n                    }\n                    else {\n                        nodesToRemove.push(node);\n                        index--;\n                    }\n                    partIndex++;\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        this.parts.push({ type: 'node', index: -1 });\n                        partIndex++;\n                    }\n                }\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nconst endsWith = (str, suffix) => {\n    const index = str.length - suffix.length;\n    return index >= 0 && str.slice(index) === suffix;\n};\nconst isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nconst createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst lastAttributeNameRegex = /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-instance.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nclass template_instance_TemplateInstance {\n    constructor(template, processor, options) {\n        this.__parts = [];\n        this.template = template;\n        this.processor = processor;\n        this.options = options;\n    }\n    update(values) {\n        let i = 0;\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.setValue(values[i]);\n            }\n            i++;\n        }\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.commit();\n            }\n        }\n    }\n    _clone() {\n        // There are a number of steps in the lifecycle of a template instance's\n        // DOM fragment:\n        //  1. Clone - create the instance fragment\n        //  2. Adopt - adopt into the main document\n        //  3. Process - find part markers and create parts\n        //  4. Upgrade - upgrade custom elements\n        //  5. Update - set node, attribute, property, etc., values\n        //  6. Connect - connect to the document. Optional and outside of this\n        //     method.\n        //\n        // We have a few constraints on the ordering of these steps:\n        //  * We need to upgrade before updating, so that property values will pass\n        //    through any property setters.\n        //  * We would like to process before upgrading so that we're sure that the\n        //    cloned fragment is inert and not disturbed by self-modifying DOM.\n        //  * We want custom elements to upgrade even in disconnected fragments.\n        //\n        // Given these constraints, with full custom elements support we would\n        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n        //\n        // But Safari dooes not implement CustomElementRegistry#upgrade, so we\n        // can not implement that order and still have upgrade-before-update and\n        // upgrade disconnected fragments. So we instead sacrifice the\n        // process-before-upgrade constraint, since in Custom Elements v1 elements\n        // must not modify their light DOM in the constructor. We still have issues\n        // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n        // that don't strictly adhere to the no-modification rule because shadow\n        // DOM, which may be created in the constructor, is emulated by being placed\n        // in the light DOM.\n        //\n        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n        // in one step.\n        //\n        // The Custom Elements v1 polyfill supports upgrade(), so the order when\n        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n        // Connect.\n        const fragment = isCEPolyfill ?\n            this.template.element.content.cloneNode(true) :\n            document.importNode(this.template.element.content, true);\n        const stack = [];\n        const parts = this.template.parts;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        let partIndex = 0;\n        let nodeIndex = 0;\n        let part;\n        let node = walker.nextNode();\n        // Loop through all the nodes and parts of a template\n        while (partIndex < parts.length) {\n            part = parts[partIndex];\n            if (!isTemplatePartActive(part)) {\n                this.__parts.push(undefined);\n                partIndex++;\n                continue;\n            }\n            // Progress the tree walker until we find our next part's node.\n            // Note that multiple parts may share the same node (attribute parts\n            // on a single element), so this loop may not run at all.\n            while (nodeIndex < part.index) {\n                nodeIndex++;\n                if (node.nodeName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n                if ((node = walker.nextNode()) === null) {\n                    // We've exhausted the content inside a nested template element.\n                    // Because we still have parts (the outer for-loop), we know:\n                    // - There is a template in the stack\n                    // - The walker will find a nextNode outside the template\n                    walker.currentNode = stack.pop();\n                    node = walker.nextNode();\n                }\n            }\n            // We've arrived at our part's node.\n            if (part.type === 'node') {\n                const part = this.processor.handleTextExpression(this.options);\n                part.insertAfterNode(node.previousSibling);\n                this.__parts.push(part);\n            }\n            else {\n                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n            }\n            partIndex++;\n        }\n        if (isCEPolyfill) {\n            document.adoptNode(fragment);\n            customElements.upgrade(fragment);\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=template-instance.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-result.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\nconst commentMarker = ` ${marker} `;\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nclass template_result_TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a `<template>` element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isCommentBinding = false;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            // For each binding we want to determine the kind of marker to insert\n            // into the template source before it's parsed by the browser's HTML\n            // parser. The marker type is based on whether the expression is in an\n            // attribute, text, or comment poisition.\n            //   * For node-position bindings we insert a comment with the marker\n            //     sentinel as its text content, like \x3c!--{{lit-guid}}--\x3e.\n            //   * For attribute bindings we insert just the marker sentinel for the\n            //     first binding, so that we support unquoted attribute bindings.\n            //     Subsequent bindings can use a comment marker because multi-binding\n            //     attributes must be quoted.\n            //   * For comment bindings we insert just the marker sentinel so we don't\n            //     close the comment.\n            //\n            // The following code scans the template source, but is *not* an HTML\n            // parser. We don't need to track the tree structure of the HTML, only\n            // whether a binding is inside a comment, and if not, if it appears to be\n            // the first binding in an attribute.\n            const commentOpen = s.lastIndexOf('\x3c!--');\n            // We're in comment position if we have a comment open with no following\n            // comment close. Because <-- can appear in an attribute value there can\n            // be false positives.\n            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&\n                s.indexOf('--\x3e', commentOpen + 1) === -1;\n            // Check to see if we have an attribute-like sequence preceeding the\n            // expression. This can match \"name=value\" like structures in text,\n            // comments, and attribute values, so there can be false-positives.\n            const attributeMatch = lastAttributeNameRegex.exec(s);\n            if (attributeMatch === null) {\n                // We're only in this branch if we don't have a attribute-like\n                // preceeding sequence. For comments, this guards against unusual\n                // attribute values like <div foo=\"\x3c!--${'bar'}\">. Cases like\n                // \x3c!-- foo=${'bar'}--\x3e are handled correctly in the attribute branch\n                // below.\n                html += s + (isCommentBinding ? commentMarker : nodeMarker);\n            }\n            else {\n                // For attributes we use just a marker sentinel, and also append a\n                // $lit$ suffix to the name to opt-out of attribute-specific parsing\n                // that IE and Edge do for style and certain SVG attributes.\n                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +\n                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +\n                    marker;\n            }\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nclass template_result_SVGTemplateResult extends template_result_TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/parts.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n\n\n\n\nconst isPrimitive = (value) => {\n    return (value === null ||\n        !(typeof value === 'object' || typeof value === 'function'));\n};\nconst isIterable = (value) => {\n    return Array.isArray(value) ||\n        // tslint:disable-next-line:no-any\n        !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attibute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nclass AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new parts_AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = this.parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (isPrimitive(v) || !isIterable(v)) {\n                    text += typeof v === 'string' ? v : String(v);\n                }\n                else {\n                    for (const t of v) {\n                        text += typeof t === 'string' ? t : String(t);\n                    }\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\nclass parts_AttributePart {\n    constructor(committer) {\n        this.value = undefined;\n        this.committer = committer;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it'll\n            // call setAttribute. If the value is a directive, it'll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nclass parts_NodePart {\n    constructor(options) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.options = options;\n    }\n    /**\n     * Appends this part into a container.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendInto(container) {\n        this.startNode = container.appendChild(createMarker());\n        this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n     * such as those that appear in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part.__insert(this.startNode = createMarker());\n        part.__insert(this.endNode = createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref.__insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        const value = this.__pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this.__commitText(value);\n            }\n        }\n        else if (value instanceof template_result_TemplateResult) {\n            this.__commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this.__commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this.__commitIterable(value);\n        }\n        else if (value === nothing) {\n            this.value = nothing;\n            this.clear();\n        }\n        else {\n            // Fallback, will render the string representation\n            this.__commitText(value);\n        }\n    }\n    __insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    __commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this.__insert(value);\n        this.value = value;\n    }\n    __commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? '' : value;\n        // If `value` isn't already a string, we explicitly convert it here in case\n        // it can't be implicitly converted - i.e. it's a symbol.\n        const valueAsString = typeof value === 'string' ? value : String(value);\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.data = valueAsString;\n        }\n        else {\n            this.__commitNode(document.createTextNode(valueAsString));\n        }\n        this.value = value;\n    }\n    __commitTemplateResult(value) {\n        const template = this.options.templateFactory(value);\n        if (this.value instanceof template_instance_TemplateInstance &&\n            this.value.template === template) {\n            this.value.update(value.values);\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use its syntax extension, etc. The template factory comes\n            // from the render function options so that it can control template\n            // caching and preprocessing.\n            const instance = new template_instance_TemplateInstance(template, value.processor, this.options);\n            const fragment = instance._clone();\n            instance.update(value.values);\n            this.__commitNode(fragment);\n            this.value = instance;\n        }\n    }\n    __commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new parts_NodePart(this.options);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nclass parts_BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n            throw new Error('Boolean attributes can only contain a single expression');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const value = !!this.__pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n            this.value = value;\n        }\n        this.__pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nclass PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            // tslint:disable-next-line:no-any\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nclass PropertyPart extends parts_AttributePart {\n}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the thrid\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\ntry {\n    const options = {\n        get capture() {\n            eventOptionsSupported = true;\n            return false;\n        }\n    };\n    // tslint:disable-next-line:no-any\n    window.addEventListener('test', options, options);\n    // tslint:disable-next-line:no-any\n    window.removeEventListener('test', options, options);\n}\ncatch (_e) {\n}\nclass parts_EventPart {\n    constructor(element, eventName, eventContext) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n        this.eventContext = eventContext;\n        this.__boundHandleEvent = (e) => this.handleEvent(e);\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const newListener = this.__pendingValue;\n        const oldListener = this.value;\n        const shouldRemoveListener = newListener == null ||\n            oldListener != null &&\n                (newListener.capture !== oldListener.capture ||\n                    newListener.once !== oldListener.once ||\n                    newListener.passive !== oldListener.passive);\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        if (shouldAddListener) {\n            this.__options = getOptions(newListener);\n            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        this.value = newListener;\n        this.__pendingValue = noChange;\n    }\n    handleEvent(event) {\n        if (typeof this.value === 'function') {\n            this.value.call(this.eventContext || this.element, event);\n        }\n        else {\n            this.value.handleEvent(event);\n        }\n    }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) => o &&\n    (eventOptionsSupported ?\n        { capture: o.capture, passive: o.passive, once: o.once } :\n        o.capture);\n//# sourceMappingURL=parts.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/default-template-processor.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Creates Parts when a template is instantiated.\n */\nclass default_template_processor_DefaultTemplateProcessor {\n    /**\n     * Create parts for an attribute-position binding, given the event, attribute\n     * name, and string literals.\n     *\n     * @param element The element containing the binding\n     * @param name  The attribute name\n     * @param strings The string literals. There are always at least two strings,\n     *   event for fully-controlled bindings with a single expression.\n     */\n    handleAttributeExpressions(element, name, strings, options) {\n        const prefix = name[0];\n        if (prefix === '.') {\n            const committer = new PropertyCommitter(element, name.slice(1), strings);\n            return committer.parts;\n        }\n        if (prefix === '@') {\n            return [new parts_EventPart(element, name.slice(1), options.eventContext)];\n        }\n        if (prefix === '?') {\n            return [new parts_BooleanAttributePart(element, name.slice(1), strings)];\n        }\n        const committer = new AttributeCommitter(element, name, strings);\n        return committer.parts;\n    }\n    /**\n     * Create parts for a text-position binding.\n     * @param templateFactory\n     */\n    handleTextExpression(options) {\n        return new parts_NodePart(options);\n    }\n}\nconst defaultTemplateProcessor = new default_template_processor_DefaultTemplateProcessor();\n//# sourceMappingURL=default-template-processor.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-factory.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nfunction templateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    // If the TemplateStringsArray is new, generate a key from the strings\n    // This key is shared between all templates with identical content\n    const key = result.strings.join(marker);\n    // Check if we already have a Template for this key\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        // If we have not seen this key before, create a new Template\n        template = new Template(result, result.getTemplateElement());\n        // Cache the Template for this key\n        templateCache.keyString.set(key, template);\n    }\n    // Cache all future queries for this TemplateStringsArray\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n}\nconst templateCaches = new Map();\n//# sourceMappingURL=template-factory.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/render.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n\nconst render_parts = new WeakMap();\n/**\n * Renders a template result or other value to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result Any value renderable by NodePart - typically a TemplateResult\n *     created by evaluating a template tag like `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nconst render = (result, container, options) => {\n    let part = render_parts.get(container);\n    if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        render_parts.set(container, part = new parts_NodePart(Object.assign({ templateFactory: templateFactory }, options)));\n        part.appendInto(container);\n    }\n    part.setValue(result);\n    part.commit();\n};\n//# sourceMappingURL=render.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lit-html.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @module lit-html\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\n\n\n\n\n// TODO(justinfagnani): remove line when we get NodePart moving methods\n\n\n\n\n\n\n\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n(window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.1.2');\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nconst lit_html_html = (strings, ...values) => new template_result_TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nconst svg = (strings, ...values) => new template_result_SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/modify-template.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module shady-render\n */\n\nconst walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nfunction removeNodesFromTemplate(template, nodesToRemove) {\n    const { element: { content }, parts } = template;\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let part = parts[partIndex];\n    let nodeIndex = -1;\n    let removeCount = 0;\n    const nodesToRemoveInTemplate = [];\n    let currentRemovingNode = null;\n    while (walker.nextNode()) {\n        nodeIndex++;\n        const node = walker.currentNode;\n        // End removal if stepped past the removing node\n        if (node.previousSibling === currentRemovingNode) {\n            currentRemovingNode = null;\n        }\n        // A node to remove was found in the template\n        if (nodesToRemove.has(node)) {\n            nodesToRemoveInTemplate.push(node);\n            // Track node we're removing\n            if (currentRemovingNode === null) {\n                currentRemovingNode = node;\n            }\n        }\n        // When removing, increment count by which to adjust subsequent part indices\n        if (currentRemovingNode !== null) {\n            removeCount++;\n        }\n        while (part !== undefined && part.index === nodeIndex) {\n            // If part is in a removed node deactivate it by setting index to -1 or\n            // adjust the index as needed.\n            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n            // go to the next active part.\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n            part = parts[partIndex];\n        }\n    }\n    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));\n}\nconst countNodes = (node) => {\n    let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;\n    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n    while (walker.nextNode()) {\n        count++;\n    }\n    return count;\n};\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n    for (let i = startIndex + 1; i < parts.length; i++) {\n        const part = parts[i];\n        if (isTemplatePartActive(part)) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nfunction insertNodeIntoTemplate(template, node, refNode = null) {\n    const { element: { content }, parts } = template;\n    // If there's no refNode, then put node at end of template.\n    // No part indices need to be shifted in this case.\n    if (refNode === null || refNode === undefined) {\n        content.appendChild(node);\n        return;\n    }\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let insertCount = 0;\n    let walkerIndex = -1;\n    while (walker.nextNode()) {\n        walkerIndex++;\n        const walkerNode = walker.currentNode;\n        if (walkerNode === refNode) {\n            insertCount = countNodes(node);\n            refNode.parentNode.insertBefore(node, refNode);\n        }\n        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n            // If we've inserted the node, simply adjust all subsequent parts\n            if (insertCount > 0) {\n                while (partIndex !== -1) {\n                    parts[partIndex].index += insertCount;\n                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n                }\n                return;\n            }\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n    }\n}\n//# sourceMappingURL=modify-template.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/shady-render.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @module shady-render\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\n\n\n\n\n\n\n\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\nlet compatibleShadyCSSVersion = true;\nif (typeof window.ShadyCSS === 'undefined') {\n    compatibleShadyCSSVersion = false;\n}\nelse if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n    console.warn(`Incompatible ShadyCSS version detected. ` +\n        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +\n        `@webcomponents/shadycss@1.3.1.`);\n    compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName) => (result) => {\n    const cacheKey = getTemplateCacheKey(result.type, scopeName);\n    let templateCache = templateCaches.get(cacheKey);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(cacheKey, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    const key = result.strings.join(marker);\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (compatibleShadyCSSVersion) {\n            window.ShadyCSS.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.keyString.set(key, template);\n    }\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n};\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName) => {\n    TEMPLATE_TYPES.forEach((type) => {\n        const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n        if (templates !== undefined) {\n            templates.keyString.forEach((template) => {\n                const { element: { content } } = template;\n                // IE 11 doesn't support the iterable param Set constructor\n                const styles = new Set();\n                Array.from(content.querySelectorAll('style')).forEach((s) => {\n                    styles.add(s);\n                });\n                removeNodesFromTemplate(template, styles);\n            });\n        }\n    });\n};\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles = (scopeName, renderedDOM, template) => {\n    shadyRenderSet.add(scopeName);\n    // If `renderedDOM` is stamped from a Template, then we need to edit that\n    // Template's underlying template element. Otherwise, we create one here\n    // to give to ShadyCSS, which still requires one while scoping.\n    const templateElement = !!template ? template.element : document.createElement('template');\n    // Move styles out of rendered DOM and store.\n    const styles = renderedDOM.querySelectorAll('style');\n    const { length } = styles;\n    // If there are no styles, skip unnecessary work\n    if (length === 0) {\n        // Ensure prepareTemplateStyles is called to support adding\n        // styles via `prepareAdoptedCssText` since that requires that\n        // `prepareTemplateStyles` is called.\n        //\n        // ShadyCSS will only update styles containing @apply in the template\n        // given to `prepareTemplateStyles`. If no lit Template was given,\n        // ShadyCSS will not be able to update uses of @apply in any relevant\n        // template. However, this is not a problem because we only create the\n        // template for the purpose of supporting `prepareAdoptedCssText`,\n        // which doesn't support @apply at all.\n        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n        return;\n    }\n    const condensedStyle = document.createElement('style');\n    // Collect styles into a single style. This helps us make sure ShadyCSS\n    // manipulations will not prevent us from being able to fix up template\n    // part indices.\n    // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n    // currently does this anyway. When it does not, this should be changed.\n    for (let i = 0; i < length; i++) {\n        const style = styles[i];\n        style.parentNode.removeChild(style);\n        condensedStyle.textContent += style.textContent;\n    }\n    // Remove styles from nested templates in this scope.\n    removeStylesFromLitTemplates(scopeName);\n    // And then put the condensed style into the \"root\" template passed in as\n    // `template`.\n    const content = templateElement.content;\n    if (!!template) {\n        insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n    }\n    else {\n        content.insertBefore(condensedStyle, content.firstChild);\n    }\n    // Note, it's important that ShadyCSS gets the template that `lit-html`\n    // will actually render so that it can update the style inside when\n    // needed (e.g. @apply native Shadow DOM case).\n    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n    const style = content.querySelector('style');\n    if (window.ShadyCSS.nativeShadow && style !== null) {\n        // When in native Shadow DOM, ensure the style created by ShadyCSS is\n        // included in initially rendered output (`renderedDOM`).\n        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n    }\n    else if (!!template) {\n        // When no style is left in the template, parts will be broken as a\n        // result. To fix this, we put back the style node ShadyCSS removed\n        // and then tell lit to remove that node from the template.\n        // There can be no style in the template in 2 cases (1) when Shady DOM\n        // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n        // is in use ShadyCSS removes the style if it contains no content.\n        // NOTE, ShadyCSS creates its own style so we can safely add/remove\n        // `condensedStyle` here.\n        content.insertBefore(condensedStyle, content.firstChild);\n        const removes = new Set();\n        removes.add(condensedStyle);\n        removeNodesFromTemplate(template, removes);\n    }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nconst shady_render_render = (result, container, options) => {\n    if (!options || typeof options !== 'object' || !options.scopeName) {\n        throw new Error('The `scopeName` option is required.');\n    }\n    const scopeName = options.scopeName;\n    const hasRendered = render_parts.has(container);\n    const needsScoping = compatibleShadyCSSVersion &&\n        container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&\n        !!container.host;\n    // Handle first render to a scope specially...\n    const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n    // On first scope render, render into a fragment; this cannot be a single\n    // fragment that is reused since nested renders can occur synchronously.\n    const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n    render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));\n    // When performing first scope render,\n    // (1) We've rendered into a fragment so that there's a chance to\n    // `prepareTemplateStyles` before sub-elements hit the DOM\n    // (which might cause them to render based on a common pattern of\n    // rendering in a custom element's `connectedCallback`);\n    // (2) Scope the template with ShadyCSS one time only for this scope.\n    // (3) Render the fragment into the container and make sure the\n    // container knows its `part` is the one we just rendered. This ensures\n    // DOM will be re-used on subsequent renders.\n    if (firstScopeRender) {\n        const part = render_parts.get(renderContainer);\n        render_parts.delete(renderContainer);\n        // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n        // that should apply to `renderContainer` even if the rendered value is\n        // not a TemplateInstance. However, it will only insert scoped styles\n        // into the document if `prepareTemplateStyles` has already been called\n        // for the given scope name.\n        const template = part.value instanceof template_instance_TemplateInstance ?\n            part.value.template :\n            undefined;\n        prepareTemplateStyles(scopeName, renderContainer, template);\n        removeNodes(container, container.firstChild);\n        container.appendChild(renderContainer);\n        render_parts.set(container, part);\n    }\n    // After elements have hit the DOM, update styling if this is the\n    // initial render to this container.\n    // This is needed whenever dynamic changes are made so it would be\n    // safest to do every render; however, this would regress performance\n    // so we leave it up to the user to call `ShadyCSS.styleElement`\n    // for dynamic changes.\n    if (!hasRendered && needsScoping) {\n        window.ShadyCSS.styleElement(container.host);\n    }\n};\n//# sourceMappingURL=shady-render.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/updating-element.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nvar _a;\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\nwindow.JSCompiler_renameProperty =\n    (prop, _obj) => prop;\nconst defaultConverter = {\n    toAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                return value ? '' : null;\n            case Object:\n            case Array:\n                // if the value is `null` or `undefined` pass this through\n                // to allow removing/no change behavior.\n                return value == null ? value : JSON.stringify(value);\n        }\n        return value;\n    },\n    fromAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                return value !== null;\n            case Number:\n                return value === null ? null : Number(value);\n            case Object:\n            case Array:\n                return JSON.parse(value);\n        }\n        return value;\n    }\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nconst notEqual = (value, old) => {\n    // This ensures (old==NaN, value==NaN) always returns false\n    return old !== value && (old === old || value === value);\n};\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    hasChanged: notEqual\n};\nconst microtaskPromise = Promise.resolve(true);\nconst STATE_HAS_UPDATED = 1;\nconst STATE_UPDATE_REQUESTED = 1 << 2;\nconst STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;\nconst STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;\nconst STATE_HAS_CONNECTED = 1 << 5;\n/**\n * The Closure JS Compiler doesn't currently have good support for static\n * property semantics where \"this\" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */\nconst finalized = 'finalized';\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n */\nclass UpdatingElement extends HTMLElement {\n    constructor() {\n        super();\n        this._updateState = 0;\n        this._instanceProperties = undefined;\n        this._updatePromise = microtaskPromise;\n        this._hasConnectedResolver = undefined;\n        /**\n         * Map with keys for any properties that have changed since the last\n         * update cycle with previous values.\n         */\n        this._changedProperties = new Map();\n        /**\n         * Map with keys of properties that should be reflected when updated.\n         */\n        this._reflectingProperties = undefined;\n        this.initialize();\n    }\n    /**\n     * Returns a list of attributes corresponding to the registered properties.\n     * @nocollapse\n     */\n    static get observedAttributes() {\n        // note: piggy backing on this to ensure we're finalized.\n        this.finalize();\n        const attributes = [];\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this._classProperties.forEach((v, p) => {\n            const attr = this._attributeNameForProperty(p, v);\n            if (attr !== undefined) {\n                this._attributeToPropertyMap.set(attr, p);\n                attributes.push(attr);\n            }\n        });\n        return attributes;\n    }\n    /**\n     * Ensures the private `_classProperties` property metadata is created.\n     * In addition to `finalize` this is also called in `createProperty` to\n     * ensure the `@property` decorator can add property metadata.\n     */\n    /** @nocollapse */\n    static _ensureClassProperties() {\n        // ensure private storage for property declarations.\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {\n            this._classProperties = new Map();\n            // NOTE: Workaround IE11 not supporting Map constructor argument.\n            const superProperties = Object.getPrototypeOf(this)._classProperties;\n            if (superProperties !== undefined) {\n                superProperties.forEach((v, k) => this._classProperties.set(k, v));\n            }\n        }\n    }\n    /**\n     * Creates a property accessor on the element prototype if one does not exist.\n     * The property setter calls the property's `hasChanged` property option\n     * or uses a strict identity check to determine whether or not to request\n     * an update.\n     * @nocollapse\n     */\n    static createProperty(name, options = defaultPropertyDeclaration) {\n        // Note, since this can be called by the `@property` decorator which\n        // is called before `finalize`, we ensure storage exists for property\n        // metadata.\n        this._ensureClassProperties();\n        this._classProperties.set(name, options);\n        // Do not generate an accessor if the prototype already has one, since\n        // it would be lost otherwise and that would never be the user's intention;\n        // Instead, we expect users to call `requestUpdate` themselves from\n        // user-defined accessors. Note that if the super has an accessor we will\n        // still overwrite it\n        if (options.noAccessor || this.prototype.hasOwnProperty(name)) {\n            return;\n        }\n        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n        Object.defineProperty(this.prototype, name, {\n            // tslint:disable-next-line:no-any no symbol in index\n            get() {\n                return this[key];\n            },\n            set(value) {\n                const oldValue = this[name];\n                this[key] = value;\n                this._requestUpdate(name, oldValue);\n            },\n            configurable: true,\n            enumerable: true\n        });\n    }\n    /**\n     * Creates property accessors for registered properties and ensures\n     * any superclasses are also finalized.\n     * @nocollapse\n     */\n    static finalize() {\n        // finalize any superclasses\n        const superCtor = Object.getPrototypeOf(this);\n        if (!superCtor.hasOwnProperty(finalized)) {\n            superCtor.finalize();\n        }\n        this[finalized] = true;\n        this._ensureClassProperties();\n        // initialize Map populated in observedAttributes\n        this._attributeToPropertyMap = new Map();\n        // make any properties\n        // Note, only process \"own\" properties since this element will inherit\n        // any properties defined on the superClass, and finalization ensures\n        // the entire prototype chain is finalized.\n        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n            const props = this.properties;\n            // support symbols in properties (IE11 does not support this)\n            const propKeys = [\n                ...Object.getOwnPropertyNames(props),\n                ...(typeof Object.getOwnPropertySymbols === 'function') ?\n                    Object.getOwnPropertySymbols(props) :\n                    []\n            ];\n            // This for/of is ok because propKeys is an array\n            for (const p of propKeys) {\n                // note, use of `any` is due to TypeSript lack of support for symbol in\n                // index types\n                // tslint:disable-next-line:no-any no symbol in index\n                this.createProperty(p, props[p]);\n            }\n        }\n    }\n    /**\n     * Returns the property name for the given attribute `name`.\n     * @nocollapse\n     */\n    static _attributeNameForProperty(name, options) {\n        const attribute = options.attribute;\n        return attribute === false ?\n            undefined :\n            (typeof attribute === 'string' ?\n                attribute :\n                (typeof name === 'string' ? name.toLowerCase() : undefined));\n    }\n    /**\n     * Returns true if a property should request an update.\n     * Called when a property value is set and uses the `hasChanged`\n     * option for the property if present or a strict identity check.\n     * @nocollapse\n     */\n    static _valueHasChanged(value, old, hasChanged = notEqual) {\n        return hasChanged(value, old);\n    }\n    /**\n     * Returns the property value for the given attribute value.\n     * Called via the `attributeChangedCallback` and uses the property's\n     * `converter` or `converter.fromAttribute` property option.\n     * @nocollapse\n     */\n    static _propertyValueFromAttribute(value, options) {\n        const type = options.type;\n        const converter = options.converter || defaultConverter;\n        const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);\n        return fromAttribute ? fromAttribute(value, type) : value;\n    }\n    /**\n     * Returns the attribute value for the given property value. If this\n     * returns undefined, the property will *not* be reflected to an attribute.\n     * If this returns null, the attribute will be removed, otherwise the\n     * attribute will be set to the value.\n     * This uses the property's `reflect` and `type.toAttribute` property options.\n     * @nocollapse\n     */\n    static _propertyValueToAttribute(value, options) {\n        if (options.reflect === undefined) {\n            return;\n        }\n        const type = options.type;\n        const converter = options.converter;\n        const toAttribute = converter && converter.toAttribute ||\n            defaultConverter.toAttribute;\n        return toAttribute(value, type);\n    }\n    /**\n     * Performs element initialization. By default captures any pre-set values for\n     * registered properties.\n     */\n    initialize() {\n        this._saveInstanceProperties();\n        // ensures first update will be caught by an early access of\n        // `updateComplete`\n        this._requestUpdate();\n    }\n    /**\n     * Fixes any properties set on the instance before upgrade time.\n     * Otherwise these would shadow the accessor and break these properties.\n     * The properties are stored in a Map which is played back after the\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n     * (<=41), properties created for native platform properties like (`id` or\n     * `name`) may not have default values set in the element constructor. On\n     * these browsers native properties appear on instances and therefore their\n     * default value will overwrite any element default (e.g. if the element sets\n     * this.id = 'id' in the constructor, the 'id' will become '' since this is\n     * the native platform default).\n     */\n    _saveInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.constructor\n            ._classProperties.forEach((_v, p) => {\n            if (this.hasOwnProperty(p)) {\n                const value = this[p];\n                delete this[p];\n                if (!this._instanceProperties) {\n                    this._instanceProperties = new Map();\n                }\n                this._instanceProperties.set(p, value);\n            }\n        });\n    }\n    /**\n     * Applies previously saved instance properties.\n     */\n    _applyInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        // tslint:disable-next-line:no-any\n        this._instanceProperties.forEach((v, p) => this[p] = v);\n        this._instanceProperties = undefined;\n    }\n    connectedCallback() {\n        this._updateState = this._updateState | STATE_HAS_CONNECTED;\n        // Ensure first connection completes an update. Updates cannot complete\n        // before connection and if one is pending connection the\n        // `_hasConnectionResolver` will exist. If so, resolve it to complete the\n        // update, otherwise requestUpdate.\n        if (this._hasConnectedResolver) {\n            this._hasConnectedResolver();\n            this._hasConnectedResolver = undefined;\n        }\n    }\n    /**\n     * Allows for `super.disconnectedCallback()` in extensions while\n     * reserving the possibility of making non-breaking feature additions\n     * when disconnecting at some point in the future.\n     */\n    disconnectedCallback() {\n    }\n    /**\n     * Synchronizes property values when attributes change.\n     */\n    attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n            this._attributeToProperty(name, value);\n        }\n    }\n    _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\n        const ctor = this.constructor;\n        const attr = ctor._attributeNameForProperty(name, options);\n        if (attr !== undefined) {\n            const attrValue = ctor._propertyValueToAttribute(value, options);\n            // an undefined value does not change the attribute.\n            if (attrValue === undefined) {\n                return;\n            }\n            // Track if the property is being reflected to avoid\n            // setting the property again via `attributeChangedCallback`. Note:\n            // 1. this takes advantage of the fact that the callback is synchronous.\n            // 2. will behave incorrectly if multiple attributes are in the reaction\n            // stack at time of calling. However, since we process attributes\n            // in `update` this should not be possible (or an extreme corner case\n            // that we'd like to discover).\n            // mark state reflecting\n            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;\n            if (attrValue == null) {\n                this.removeAttribute(attr);\n            }\n            else {\n                this.setAttribute(attr, attrValue);\n            }\n            // mark state not reflecting\n            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;\n        }\n    }\n    _attributeToProperty(name, value) {\n        // Use tracking info to avoid deserializing attribute value if it was\n        // just set from a property setter.\n        if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {\n            return;\n        }\n        const ctor = this.constructor;\n        const propName = ctor._attributeToPropertyMap.get(name);\n        if (propName !== undefined) {\n            const options = ctor._classProperties.get(propName) || defaultPropertyDeclaration;\n            // mark state reflecting\n            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;\n            this[propName] =\n                // tslint:disable-next-line:no-any\n                ctor._propertyValueFromAttribute(value, options);\n            // mark state not reflecting\n            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;\n        }\n    }\n    /**\n     * This private version of `requestUpdate` does not access or return the\n     * `updateComplete` promise. This promise can be overridden and is therefore\n     * not free to access.\n     */\n    _requestUpdate(name, oldValue) {\n        let shouldRequestUpdate = true;\n        // If we have a property key, perform property update steps.\n        if (name !== undefined) {\n            const ctor = this.constructor;\n            const options = ctor._classProperties.get(name) || defaultPropertyDeclaration;\n            if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {\n                if (!this._changedProperties.has(name)) {\n                    this._changedProperties.set(name, oldValue);\n                }\n                // Add to reflecting properties set.\n                // Note, it's important that every change has a chance to add the\n                // property to `_reflectingProperties`. This ensures setting\n                // attribute + property reflects correctly.\n                if (options.reflect === true &&\n                    !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {\n                    if (this._reflectingProperties === undefined) {\n                        this._reflectingProperties = new Map();\n                    }\n                    this._reflectingProperties.set(name, options);\n                }\n            }\n            else {\n                // Abort the request if the property should not be considered changed.\n                shouldRequestUpdate = false;\n            }\n        }\n        if (!this._hasRequestedUpdate && shouldRequestUpdate) {\n            this._enqueueUpdate();\n        }\n    }\n    /**\n     * Requests an update which is processed asynchronously. This should\n     * be called when an element should update based on some state not triggered\n     * by setting a property. In this case, pass no arguments. It should also be\n     * called when manually implementing a property setter. In this case, pass the\n     * property `name` and `oldValue` to ensure that any configured property\n     * options are honored. Returns the `updateComplete` Promise which is resolved\n     * when the update completes.\n     *\n     * @param name {PropertyKey} (optional) name of requesting property\n     * @param oldValue {any} (optional) old value of requesting property\n     * @returns {Promise} A Promise that is resolved when the update completes.\n     */\n    requestUpdate(name, oldValue) {\n        this._requestUpdate(name, oldValue);\n        return this.updateComplete;\n    }\n    /**\n     * Sets up the element to asynchronously update.\n     */\n    async _enqueueUpdate() {\n        // Mark state updating...\n        this._updateState = this._updateState | STATE_UPDATE_REQUESTED;\n        let resolve;\n        let reject;\n        const previousUpdatePromise = this._updatePromise;\n        this._updatePromise = new Promise((res, rej) => {\n            resolve = res;\n            reject = rej;\n        });\n        try {\n            // Ensure any previous update has resolved before updating.\n            // This `await` also ensures that property changes are batched.\n            await previousUpdatePromise;\n        }\n        catch (e) {\n            // Ignore any previous errors. We only care that the previous cycle is\n            // done. Any error should have been handled in the previous update.\n        }\n        // Make sure the element has connected before updating.\n        if (!this._hasConnected) {\n            await new Promise((res) => this._hasConnectedResolver = res);\n        }\n        try {\n            const result = this.performUpdate();\n            // If `performUpdate` returns a Promise, we await it. This is done to\n            // enable coordinating updates with a scheduler. Note, the result is\n            // checked to avoid delaying an additional microtask unless we need to.\n            if (result != null) {\n                await result;\n            }\n        }\n        catch (e) {\n            reject(e);\n        }\n        resolve(!this._hasRequestedUpdate);\n    }\n    get _hasConnected() {\n        return (this._updateState & STATE_HAS_CONNECTED);\n    }\n    get _hasRequestedUpdate() {\n        return (this._updateState & STATE_UPDATE_REQUESTED);\n    }\n    get hasUpdated() {\n        return (this._updateState & STATE_HAS_UPDATED);\n    }\n    /**\n     * Performs an element update. Note, if an exception is thrown during the\n     * update, `firstUpdated` and `updated` will not be called.\n     *\n     * You can override this method to change the timing of updates. If this\n     * method is overridden, `super.performUpdate()` must be called.\n     *\n     * For instance, to schedule updates to occur just before the next frame:\n     *\n     * ```\n     * protected async performUpdate(): Promise<unknown> {\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n     *   super.performUpdate();\n     * }\n     * ```\n     */\n    performUpdate() {\n        // Mixin instance properties once, if they exist.\n        if (this._instanceProperties) {\n            this._applyInstanceProperties();\n        }\n        let shouldUpdate = false;\n        const changedProperties = this._changedProperties;\n        try {\n            shouldUpdate = this.shouldUpdate(changedProperties);\n            if (shouldUpdate) {\n                this.update(changedProperties);\n            }\n        }\n        catch (e) {\n            // Prevent `firstUpdated` and `updated` from running when there's an\n            // update exception.\n            shouldUpdate = false;\n            throw e;\n        }\n        finally {\n            // Ensure element can accept additional updates after an exception.\n            this._markUpdated();\n        }\n        if (shouldUpdate) {\n            if (!(this._updateState & STATE_HAS_UPDATED)) {\n                this._updateState = this._updateState | STATE_HAS_UPDATED;\n                this.firstUpdated(changedProperties);\n            }\n            this.updated(changedProperties);\n        }\n    }\n    _markUpdated() {\n        this._changedProperties = new Map();\n        this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;\n    }\n    /**\n     * Returns a Promise that resolves when the element has completed updating.\n     * The Promise value is a boolean that is `true` if the element completed the\n     * update without triggering another update. The Promise result is `false` if\n     * a property was set inside `updated()`. If the Promise is rejected, an\n     * exception was thrown during the update.\n     *\n     * To await additional asynchronous work, override the `_getUpdateComplete`\n     * method. For example, it is sometimes useful to await a rendered element\n     * before fulfilling this Promise. To do this, first await\n     * `super._getUpdateComplete()`, then any subsequent state.\n     *\n     * @returns {Promise} The Promise returns a boolean that indicates if the\n     * update resolved without triggering another update.\n     */\n    get updateComplete() {\n        return this._getUpdateComplete();\n    }\n    /**\n     * Override point for the `updateComplete` promise.\n     *\n     * It is not safe to override the `updateComplete` getter directly due to a\n     * limitation in TypeScript which means it is not possible to call a\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n     * This method should be overridden instead. For example:\n     *\n     *   class MyElement extends LitElement {\n     *     async _getUpdateComplete() {\n     *       await super._getUpdateComplete();\n     *       await this._myChild.updateComplete;\n     *     }\n     *   }\n     */\n    _getUpdateComplete() {\n        return this._updatePromise;\n    }\n    /**\n     * Controls whether or not `update` should be called when the element requests\n     * an update. By default, this method always returns `true`, but this can be\n     * customized to control when to update.\n     *\n     * * @param _changedProperties Map of changed properties with old values\n     */\n    shouldUpdate(_changedProperties) {\n        return true;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes.\n     * It can be overridden to render and keep updated element DOM.\n     * Setting properties inside this method will *not* trigger\n     * another update.\n     *\n     * * @param _changedProperties Map of changed properties with old values\n     */\n    update(_changedProperties) {\n        if (this._reflectingProperties !== undefined &&\n            this._reflectingProperties.size > 0) {\n            // Use forEach so this works even if for/of loops are compiled to for\n            // loops expecting arrays\n            this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));\n            this._reflectingProperties = undefined;\n        }\n    }\n    /**\n     * Invoked whenever the element is updated. Implement to perform\n     * post-updating tasks via DOM APIs, for example, focusing an element.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * * @param _changedProperties Map of changed properties with old values\n     */\n    updated(_changedProperties) {\n    }\n    /**\n     * Invoked when the element is first updated. Implement to perform one time\n     * work on the element after update.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * * @param _changedProperties Map of changed properties with old values\n     */\n    firstUpdated(_changedProperties) {\n    }\n}\n_a = finalized;\n/**\n * Marks class as having finished creating properties.\n */\nUpdatingElement[_a] = true;\n//# sourceMappingURL=updating-element.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/decorators.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst legacyCustomElement = (tagName, clazz) => {\n    window.customElements.define(tagName, clazz);\n    // Cast as any because TS doesn't recognize the return type as being a\n    // subtype of the decorated class when clazz is typed as\n    // `Constructor<HTMLElement>` for some reason.\n    // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n    // applied to elements however.\n    // tslint:disable-next-line:no-any\n    return clazz;\n};\nconst standardCustomElement = (tagName, descriptor) => {\n    const { kind, elements } = descriptor;\n    return {\n        kind,\n        elements,\n        // This callback is called once the class is otherwise fully defined\n        finisher(clazz) {\n            window.customElements.define(tagName, clazz);\n        }\n    };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * @param tagName the name of the custom element to define\n */\nconst customElement = (tagName) => (classOrDescriptor) => (typeof classOrDescriptor === 'function') ?\n    legacyCustomElement(tagName, classOrDescriptor) :\n    standardCustomElement(tagName, classOrDescriptor);\nconst standardProperty = (options, element) => {\n    // When decorating an accessor, pass it through and add property metadata.\n    // Note, the `hasOwnProperty` check in `createProperty` ensures we don't\n    // stomp over the user's accessor.\n    if (element.kind === 'method' && element.descriptor &&\n        !('value' in element.descriptor)) {\n        return Object.assign({}, element, { finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            } });\n    }\n    else {\n        // createProperty() takes care of defining the property, but we still\n        // must return some kind of descriptor, so return a descriptor for an\n        // unused prototype field. The finisher calls createProperty().\n        return {\n            kind: 'field',\n            key: Symbol(),\n            placement: 'own',\n            descriptor: {},\n            // When @babel/plugin-proposal-decorators implements initializers,\n            // do this instead of the initializer below. See:\n            // https://github.com/babel/babel/issues/9260 extras: [\n            //   {\n            //     kind: 'initializer',\n            //     placement: 'own',\n            //     initializer: descriptor.initializer,\n            //   }\n            // ],\n            initializer() {\n                if (typeof element.initializer === 'function') {\n                    this[element.key] = element.initializer.call(this);\n                }\n            },\n            finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            }\n        };\n    }\n};\nconst legacyProperty = (options, proto, name) => {\n    proto.constructor\n        .createProperty(name, options);\n};\n/**\n * A property decorator which creates a LitElement property which reflects a\n * corresponding attribute value. A `PropertyDeclaration` may optionally be\n * supplied to configure property features.\n *\n * @ExportDecoratedItems\n */\nfunction property(options) {\n    // tslint:disable-next-line:no-any decorator\n    return (protoOrDescriptor, name) => (name !== undefined) ?\n        legacyProperty(options, protoOrDescriptor, name) :\n        standardProperty(options, protoOrDescriptor);\n}\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @ExportDecoratedItems\n */\nfunction query(selector) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            get() {\n                return this.renderRoot.querySelector(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n *\n * @ExportDecoratedItems\n */\nfunction queryAll(selector) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            get() {\n                return this.renderRoot.querySelectorAll(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\nconst legacyQuery = (descriptor, proto, name) => {\n    Object.defineProperty(proto, name, descriptor);\n};\nconst standardQuery = (descriptor, element) => ({\n    kind: 'method',\n    placement: 'prototype',\n    key: element.key,\n    descriptor,\n});\nconst standardEventOptions = (options, element) => {\n    return Object.assign({}, element, { finisher(clazz) {\n            Object.assign(clazz.prototype[element.key], options);\n        } });\n};\nconst legacyEventOptions = \n// tslint:disable-next-line:no-any legacy decorator\n(options, proto, name) => {\n    Object.assign(proto[name], options);\n};\n/**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifis event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * @example\n *\n *     class MyElement {\n *\n *       clicked = false;\n *\n *       render() {\n *         return html`<div @click=${this._onClick}`><button></button></div>`;\n *       }\n *\n *       @eventOptions({capture: true})\n *       _onClick(e) {\n *         this.clicked = true;\n *       }\n *     }\n */\nconst eventOptions = (options) => \n// Return value typed as any to prevent TypeScript from complaining that\n// standard decorator function signature does not match TypeScript decorator\n// signature\n// TODO(kschaaf): unclear why it was only failing on this decorator and not\n// the others\n((protoOrDescriptor, name) => (name !== undefined) ?\n    legacyEventOptions(options, protoOrDescriptor, name) :\n    standardEventOptions(options, protoOrDescriptor));\n//# sourceMappingURL=decorators.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/css-tag.js\n/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nconst supportsAdoptingStyleSheets = ('adoptedStyleSheets' in Document.prototype) &&\n    ('replace' in CSSStyleSheet.prototype);\nconst constructionToken = Symbol();\nclass CSSResult {\n    constructor(cssText, safeToken) {\n        if (safeToken !== constructionToken) {\n            throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');\n        }\n        this.cssText = cssText;\n    }\n    // Note, this is a getter so that it's lazy. In practice, this means\n    // stylesheets are not created until the first element instance is made.\n    get styleSheet() {\n        if (this._styleSheet === undefined) {\n            // Note, if `adoptedStyleSheets` is supported then we assume CSSStyleSheet\n            // is constructable.\n            if (supportsAdoptingStyleSheets) {\n                this._styleSheet = new CSSStyleSheet();\n                this._styleSheet.replaceSync(this.cssText);\n            }\n            else {\n                this._styleSheet = null;\n            }\n        }\n        return this._styleSheet;\n    }\n    toString() {\n        return this.cssText;\n    }\n}\n/**\n * Wrap a value for interpolation in a css tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\nconst unsafeCSS = (value) => {\n    return new CSSResult(String(value), constructionToken);\n};\nconst textFromCSSResult = (value) => {\n    if (value instanceof CSSResult) {\n        return value.cssText;\n    }\n    else if (typeof value === 'number') {\n        return value;\n    }\n    else {\n        throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but\n            take care to ensure page security.`);\n    }\n};\n/**\n * Template tag which which can be used with LitElement's `style` property to\n * set element styles. For security reasons, only literal string values may be\n * used. To incorporate non-literal values `unsafeCSS` may be used inside a\n * template string part.\n */\nconst css = (strings, ...values) => {\n    const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);\n    return new CSSResult(cssText, constructionToken);\n};\n//# sourceMappingURL=css-tag.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lit-element.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n\n\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n(window['litElementVersions'] || (window['litElementVersions'] = []))\n    .push('2.2.1');\n/**\n * Minimal implementation of Array.prototype.flat\n * @param arr the array to flatten\n * @param result the accumlated result\n */\nfunction arrayFlat(styles, result = []) {\n    for (let i = 0, length = styles.length; i < length; i++) {\n        const value = styles[i];\n        if (Array.isArray(value)) {\n            arrayFlat(value, result);\n        }\n        else {\n            result.push(value);\n        }\n    }\n    return result;\n}\n/** Deeply flattens styles array. Uses native flat if available. */\nconst flattenStyles = (styles) => styles.flat ? styles.flat(Infinity) : arrayFlat(styles);\nclass lit_element_LitElement extends UpdatingElement {\n    /** @nocollapse */\n    static finalize() {\n        // The Closure JS Compiler does not always preserve the correct \"this\"\n        // when calling static super methods (b/137460243), so explicitly bind.\n        super.finalize.call(this);\n        // Prepare styling that is stamped at first render time. Styling\n        // is built from user provided `styles` or is inherited from the superclass.\n        this._styles =\n            this.hasOwnProperty(JSCompiler_renameProperty('styles', this)) ?\n                this._getUniqueStyles() :\n                this._styles || [];\n    }\n    /** @nocollapse */\n    static _getUniqueStyles() {\n        // Take care not to call `this.styles` multiple times since this generates\n        // new CSSResults each time.\n        // TODO(sorvell): Since we do not cache CSSResults by input, any\n        // shared styles will generate new stylesheet objects, which is wasteful.\n        // This should be addressed when a browser ships constructable\n        // stylesheets.\n        const userStyles = this.styles;\n        const styles = [];\n        if (Array.isArray(userStyles)) {\n            const flatStyles = flattenStyles(userStyles);\n            // As a performance optimization to avoid duplicated styling that can\n            // occur especially when composing via subclassing, de-duplicate styles\n            // preserving the last item in the list. The last item is kept to\n            // try to preserve cascade order with the assumption that it's most\n            // important that last added styles override previous styles.\n            const styleSet = flatStyles.reduceRight((set, s) => {\n                set.add(s);\n                // on IE set.add does not return the set.\n                return set;\n            }, new Set());\n            // Array.from does not work on Set in IE\n            styleSet.forEach((v) => styles.unshift(v));\n        }\n        else if (userStyles) {\n            styles.push(userStyles);\n        }\n        return styles;\n    }\n    /**\n     * Performs element initialization. By default this calls `createRenderRoot`\n     * to create the element `renderRoot` node and captures any pre-set values for\n     * registered properties.\n     */\n    initialize() {\n        super.initialize();\n        this.renderRoot =\n            this.createRenderRoot();\n        // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\n        // element's getRootNode(). While this could be done, we're choosing not to\n        // support this now since it would require different logic around de-duping.\n        if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\n            this.adoptStyles();\n        }\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element's DOM is rendered. For example, to render into the element's\n     * childNodes, return `this`.\n     * @returns {Element|DocumentFragment} Returns a node into which to render.\n     */\n    createRenderRoot() {\n        return this.attachShadow({ mode: 'open' });\n    }\n    /**\n     * Applies styling to the element shadowRoot using the `static get styles`\n     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\n     * available and will fallback otherwise. When Shadow DOM is polyfilled,\n     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\n     * is available but `adoptedStyleSheets` is not, styles are appended to the\n     * end of the `shadowRoot` to [mimic spec\n     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n     */\n    adoptStyles() {\n        const styles = this.constructor._styles;\n        if (styles.length === 0) {\n            return;\n        }\n        // There are three separate cases here based on Shadow DOM support.\n        // (1) shadowRoot polyfilled: use ShadyCSS\n        // (2) shadowRoot.adoptedStyleSheets available: use it.\n        // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\n        // rendering\n        if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\n            window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);\n        }\n        else if (supportsAdoptingStyleSheets) {\n            this.renderRoot.adoptedStyleSheets =\n                styles.map((s) => s.styleSheet);\n        }\n        else {\n            // This must be done after rendering so the actual style insertion is done\n            // in `update`.\n            this._needsShimAdoptedStyleSheets = true;\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // Note, first update/render handles styleElement so we only call this if\n        // connected after first update.\n        if (this.hasUpdated && window.ShadyCSS !== undefined) {\n            window.ShadyCSS.styleElement(this);\n        }\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes\n     * and calls `render` to render DOM via lit-html. Setting properties inside\n     * this method will *not* trigger another update.\n     * * @param _changedProperties Map of changed properties with old values\n     */\n    update(changedProperties) {\n        super.update(changedProperties);\n        const templateResult = this.render();\n        if (templateResult instanceof template_result_TemplateResult) {\n            this.constructor\n                .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });\n        }\n        // When native Shadow DOM is used but adoptedStyles are not supported,\n        // insert styling after rendering to ensure adoptedStyles have highest\n        // priority.\n        if (this._needsShimAdoptedStyleSheets) {\n            this._needsShimAdoptedStyleSheets = false;\n            this.constructor._styles.forEach((s) => {\n                const style = document.createElement('style');\n                style.textContent = s.cssText;\n                this.renderRoot.appendChild(style);\n            });\n        }\n    }\n    /**\n     * Invoked on each update to perform rendering tasks. This method must return\n     * a lit-html TemplateResult. Setting properties inside this method will *not*\n     * trigger the element to update.\n     */\n    render() {\n    }\n}\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n *\n * Note this property name is a string to prevent breaking Closure JS Compiler\n * optimizations. See updating-element.ts for more information.\n */\nlit_element_LitElement['finalized'] = true;\n/**\n * Render method used to render the lit-html TemplateResult to the element's\n * DOM.\n * @param {TemplateResult} Template to render.\n * @param {Element|DocumentFragment} Node into which to render.\n * @param {String} Element name.\n * @nocollapse\n */\nlit_element_LitElement.render = shady_render_render;\n//# sourceMappingURL=lit-element.js.map\n// EXTERNAL MODULE: ./node_modules/solid-auth-client/browser/index.js\nvar browser = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/evejs/dist/eve.custom.js\nvar eve_custom = __webpack_require__(1);\nvar eve_custom_default = /*#__PURE__*/__webpack_require__.n(eve_custom);\n\n// CONCATENATED MODULE: ./src/agents/hello-agent.js\n\n\nfunction HelloAgent(id){\n  // execute super constructor\n  eve_custom_default.a.Agent.call(this, id);\n\n  // connect to all transports configured by the system\n  this.connect(eve_custom_default.a.system.transports.getAll());\n\n}\n\n// extend the eve.Agent prototype\nHelloAgent.prototype = Object.create(eve_custom_default.a.Agent.prototype);\nHelloAgent.prototype.constructor = HelloAgent;\n\nHelloAgent.prototype.sayHello = function(to) {\n  this.send(to, 'Hello ' + to + '!');\n};\n\nHelloAgent.prototype.receive = function(from, message) {\n  //slog(this.id+\" received from :\"+from + ' this message: ' + JSON.stringify(message));\n  console.log(this.id+\" received from :\"+from + ' this message: ' + JSON.stringify(message));\n\n  if (JSON.stringify(message).indexOf('Hello') === 0) {\n    // reply to the greeting\n    this.send(from, 'Hi ' + from + ', nice to meet you!');\n  }\n};\n\n\nHelloAgent.prototype.broadcast = function(message){\n  var me = this\n  var allAgents = Object.keys(this.connections[0].transport.agents);\n//  console.log(allAgents)\n  allAgents.forEach(function (agent){\n    me.send(agent, message);\n  })\n}\n\nHelloAgent.prototype.sendMulti = function(recipients, message){\n  var me = this\n  recipients.forEach(function (agent){\n  //  console.log(agent, message)\n    me.send(agent, message);\n  })\n}\n\n\n\n\n// CONCATENATED MODULE: ./src/component/login-element.js\n\n\n\n\nclass login_element_LoginElement extends lit_element_LitElement {\n\n  static get properties() {\n    return {\n      name: {type: String},\n      webId: {type: String},\n    };\n  }\n\n  constructor() {\n    super();\n    this.webId = null\n  }\n\n  render(){\n    return lit_html_html`\n    \x3c!-- if this.webId == null , login button is diaplayed --\x3e\n    ${this.webId == null ?\n      lit_html_html`\n      <button @click=${this.login}>Login</button>\n      `\n      : lit_html_html`\n      \x3c!-- else logout button is displayed --\x3e\n      <button @click=${this.logout}>Logout</button>\n      ${this.webId}\n      `\n    }\n    `;\n  }\n\n  firstUpdated(){\n    this.agent = new HelloAgent(this.name);\n    browser[\"trackSession\"](session => {\n      if (!session){\n        this.webId=null\n        this.agent.send('Messages',  {action:\"info\", info:\"Not logged\"});\n      }\n      else{\n        this.webId = session.webId\n        this.agent.send('Messages',  {action:\"info\", info:\"Login \"+this.webId});\n      }\n    })\n  }\n\n  login(event) {\n    this.popupLogin();\n  }\n\n  logout(event) {\n    browser[\"logout\"]().then(() => alert('Goodbye!'));\n  }\n\n  async popupLogin() {\n    let session = await browser[\"currentSession\"]();\n    let popupUri = './dist-popup/popup.html';\n    if (!session)\n    session = await browser[\"popupLogin\"]({popupUri });\n  }\n\n}\n\ncustomElements.define('login-element', login_element_LoginElement);\n\n// CONCATENATED MODULE: ./src/component/messages-element.js\n\n\n\nclass messages_element_MessagesElement extends lit_element_LitElement {\n\n  static get properties() {\n    return {\n      name: {type: String},\n      messages: {type: Array}\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = \"unknown\"\n    this.messages =  []\n  }\n  render(){\n    return lit_html_html`\n    <p>${this.name}</p>\n  \x3c!--  <pre class=\"pre-scrollable\">--\x3e\n    <ul id=\"messageslist\" style=\"height: 20vh; overflow: auto\">\n    ${this.messages.map((m) => lit_html_html`<li><b>Agent ${m.from}</b> say \"${m.message}\"</li>`)}\n    </ul>\n\n  \x3c!--  </pre>--\x3e\n    `;\n  }\n\n  firstUpdated(){\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    this.agent.receive = function(from, message) {\n\n      if (message.hasOwnProperty(\"action\")){\n        switch(message.action) {\n          case \"info\":\n          app.addInfo(from, message)\n          break;\n          default:\n          console.log(\"Unknown action \",message)\n        }\n      }\n    };\n  }\n\n  addInfo(from, message){\n    this.messages.reverse()\n    this.messages = [... this.messages, {message: JSON.stringify(message), from: from}]\n    this.messages.reverse()\n  }\n\n}\n\ncustomElements.define('messages-element', messages_element_MessagesElement);\n\n// CONCATENATED MODULE: ./src/component/app-element.js\n\n\n\n\n\nclass app_element_AppElement extends lit_element_LitElement {\n\n  static get properties() {\n    return {\n      something: {type: String},\n    };\n  }\n\n  constructor() {\n    super();\n    this.something = \"world\"\n  }\n\n  render(){\n    return lit_html_html`\n    Hello <b>${this.something}</b> from app-element !\n    <login-element name=\"Login\"></login-element>\n    <messages-element name=\"Messages\"></messages-element>\n    `;\n  }\n\n}\n\ncustomElements.define('app-element', app_element_AppElement);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL2RpcmVjdGl2ZS5qcz83ODFjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvZG9tLmpzP2I0NTMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9wYXJ0LmpzP2Q1NTIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi90ZW1wbGF0ZS5qcz9lMzJiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUtaW5zdGFuY2UuanM/ZWFlOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL3RlbXBsYXRlLXJlc3VsdC5qcz8xOGMwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvcGFydHMuanM/NWM4ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL2RlZmF1bHQtdGVtcGxhdGUtcHJvY2Vzc29yLmpzP2QwNTgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi90ZW1wbGF0ZS1mYWN0b3J5LmpzPzNlYTkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9yZW5kZXIuanM/YzI2OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGl0LWh0bWwuanM/MDFhMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL21vZGlmeS10ZW1wbGF0ZS5qcz83NjZiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvc2hhZHktcmVuZGVyLmpzP2E5YzkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi91cGRhdGluZy1lbGVtZW50LmpzP2IyMmIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi9kZWNvcmF0b3JzLmpzP2Q0OTkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi9jc3MtdGFnLmpzPzZiYmIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpdC1lbGVtZW50LmpzPzA5MDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FnZW50cy9oZWxsby1hZ2VudC5qcz9kM2MzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvbG9naW4tZWxlbWVudC5qcz8xMjNkIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvbWVzc2FnZXMtZWxlbWVudC5qcz9mZDczIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvYXBwLWVsZW1lbnQuanM/MjE0NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUMsS0FBSyxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNPLE1BQU0sbUJBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBLHFDOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQ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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsd0JBQXdCLElBQUk7QUFDNUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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VztBQUNmOztBQUVBO0FBQ0Esd0JBQXdCLHlCQUFtQjtBQUMzQztBQUNBO0FBQ0Esb0JBQW9CLHFCQUFlLEVBQUUsV0FBVztBQUNoRDs7QUFFQTs7QUFFQSx1Q0FBdUMsMEJBQVk7OztBQ2pFSjtBQUNPOztBQUV0RCxNQUFNLGdDQUFlLFNBQVMsc0JBQVU7O0FBRXhDO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFJO0FBQ2YsU0FBUyxVQUFVO0FBQ25CO0FBQ0EsOENBQThDO0FBQzlDLE1BQU0seUJBQXlCLGFBQUksZ0JBQWdCLE9BQU8sWUFBWSxVQUFVO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLDZDQUE2QztBQUN0RjtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxnQ0FBZTs7O0FDdERWOztBQUVwQjtBQUNHOztBQUU5QixNQUFNLHNCQUFVLFNBQVMsc0JBQVU7O0FBRW5DO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFJO0FBQ2YsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFxQyxzQkFBVSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuY29uc3QgZGlyZWN0aXZlcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEJyYW5kcyBhIGZ1bmN0aW9uIGFzIGEgZGlyZWN0aXZlIGZhY3RvcnkgZnVuY3Rpb24gc28gdGhhdCBsaXQtaHRtbCB3aWxsIGNhbGxcbiAqIHRoZSBmdW5jdGlvbiBkdXJpbmcgdGVtcGxhdGUgcmVuZGVyaW5nLCByYXRoZXIgdGhhbiBwYXNzaW5nIGFzIGEgdmFsdWUuXG4gKlxuICogQSBfZGlyZWN0aXZlXyBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBQYXJ0IGFzIGFuIGFyZ3VtZW50LiBJdCBoYXMgdGhlXG4gKiBzaWduYXR1cmU6IGAocGFydDogUGFydCkgPT4gdm9pZGAuXG4gKlxuICogQSBkaXJlY3RpdmUgX2ZhY3RvcnlfIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcmd1bWVudHMgZm9yIGRhdGEgYW5kXG4gKiBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgZGlyZWN0aXZlLiBVc2VycyBvZiBkaXJlY3RpdmUgdXN1YWxseSByZWZlciB0b1xuICogdGhlIGRpcmVjdGl2ZSBmYWN0b3J5IGFzIHRoZSBkaXJlY3RpdmUuIEZvciBleGFtcGxlLCBcIlRoZSByZXBlYXQgZGlyZWN0aXZlXCIuXG4gKlxuICogVXN1YWxseSBhIHRlbXBsYXRlIGF1dGhvciB3aWxsIGludm9rZSBhIGRpcmVjdGl2ZSBmYWN0b3J5IGluIHRoZWlyIHRlbXBsYXRlXG4gKiB3aXRoIHJlbGV2YW50IGFyZ3VtZW50cywgd2hpY2ggd2lsbCB0aGVuIHJldHVybiBhIGRpcmVjdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBvZiB1c2luZyB0aGUgYHJlcGVhdCgpYCBkaXJlY3RpdmUgZmFjdG9yeSB0aGF0IHRha2VzIGFuXG4gKiBhcnJheSBhbmQgYSBmdW5jdGlvbiB0byByZW5kZXIgYW4gaXRlbTpcbiAqXG4gKiBgYGBqc1xuICogaHRtbGA8dWw+PCR7cmVwZWF0KGl0ZW1zLCAoaXRlbSkgPT4gaHRtbGA8bGk+JHtpdGVtfTwvbGk+YCl9PC91bD5gXG4gKiBgYGBcbiAqXG4gKiBXaGVuIGByZXBlYXRgIGlzIGludm9rZWQsIGl0IHJldHVybnMgYSBkaXJlY3RpdmUgZnVuY3Rpb24gdGhhdCBjbG9zZXMgb3ZlclxuICogYGl0ZW1zYCBhbmQgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLiBXaGVuIHRoZSBvdXRlciB0ZW1wbGF0ZSBpcyByZW5kZXJlZCwgdGhlXG4gKiByZXR1cm4gZGlyZWN0aXZlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBQYXJ0IGZvciB0aGUgZXhwcmVzc2lvbi5cbiAqIGByZXBlYXRgIHRoZW4gcGVyZm9ybXMgaXQncyBjdXN0b20gbG9naWMgdG8gcmVuZGVyIG11bHRpcGxlIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSBmIFRoZSBkaXJlY3RpdmUgZmFjdG9yeSBmdW5jdGlvbi4gTXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhXG4gKiBmdW5jdGlvbiBvZiB0aGUgc2lnbmF0dXJlIGAocGFydDogUGFydCkgPT4gdm9pZGAuIFRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsXG4gKiBiZSBjYWxsZWQgd2l0aCB0aGUgcGFydCBvYmplY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQge2RpcmVjdGl2ZSwgaHRtbH0gZnJvbSAnbGl0LWh0bWwnO1xuICpcbiAqIGNvbnN0IGltbXV0YWJsZSA9IGRpcmVjdGl2ZSgodikgPT4gKHBhcnQpID0+IHtcbiAqICAgaWYgKHBhcnQudmFsdWUgIT09IHYpIHtcbiAqICAgICBwYXJ0LnNldFZhbHVlKHYpXG4gKiAgIH1cbiAqIH0pO1xuICovXG5leHBvcnQgY29uc3QgZGlyZWN0aXZlID0gKGYpID0+ICgoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGQgPSBmKC4uLmFyZ3MpO1xuICAgIGRpcmVjdGl2ZXMuc2V0KGQsIHRydWUpO1xuICAgIHJldHVybiBkO1xufSk7XG5leHBvcnQgY29uc3QgaXNEaXJlY3RpdmUgPSAobykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyAmJiBkaXJlY3RpdmVzLmhhcyhvKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBUcnVlIGlmIHRoZSBjdXN0b20gZWxlbWVudHMgcG9seWZpbGwgaXMgaW4gdXNlLlxuICovXG5leHBvcnQgY29uc3QgaXNDRVBvbHlmaWxsID0gd2luZG93LmN1c3RvbUVsZW1lbnRzICE9PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayAhPT1cbiAgICAgICAgdW5kZWZpbmVkO1xuLyoqXG4gKiBSZXBhcmVudHMgbm9kZXMsIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCAoaW5jbHVzaXZlKSB0byBgZW5kYCAoZXhjbHVzaXZlKSxcbiAqIGludG8gYW5vdGhlciBjb250YWluZXIgKGNvdWxkIGJlIHRoZSBzYW1lIGNvbnRhaW5lciksIGJlZm9yZSBgYmVmb3JlYC4gSWZcbiAqIGBiZWZvcmVgIGlzIG51bGwsIGl0IGFwcGVuZHMgdGhlIG5vZGVzIHRvIHRoZSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBjb25zdCByZXBhcmVudE5vZGVzID0gKGNvbnRhaW5lciwgc3RhcnQsIGVuZCA9IG51bGwsIGJlZm9yZSA9IG51bGwpID0+IHtcbiAgICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICBjb25zdCBuID0gc3RhcnQubmV4dFNpYmxpbmc7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoc3RhcnQsIGJlZm9yZSk7XG4gICAgICAgIHN0YXJ0ID0gbjtcbiAgICB9XG59O1xuLyoqXG4gKiBSZW1vdmVzIG5vZGVzLCBzdGFydGluZyBmcm9tIGBzdGFydGAgKGluY2x1c2l2ZSkgdG8gYGVuZGAgKGV4Y2x1c2l2ZSksIGZyb21cbiAqIGBjb250YWluZXJgLlxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlTm9kZXMgPSAoY29udGFpbmVyLCBzdGFydCwgZW5kID0gbnVsbCkgPT4ge1xuICAgIHdoaWxlIChzdGFydCAhPT0gZW5kKSB7XG4gICAgICAgIGNvbnN0IG4gPSBzdGFydC5uZXh0U2libGluZztcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgPSBuO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb20uanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBBIHNlbnRpbmVsIHZhbHVlIHRoYXQgc2lnbmFscyB0aGF0IGEgdmFsdWUgd2FzIGhhbmRsZWQgYnkgYSBkaXJlY3RpdmUgYW5kXG4gKiBzaG91bGQgbm90IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vQ2hhbmdlID0ge307XG4vKipcbiAqIEEgc2VudGluZWwgdmFsdWUgdGhhdCBzaWduYWxzIGEgTm9kZVBhcnQgdG8gZnVsbHkgY2xlYXIgaXRzIGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBub3RoaW5nID0ge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQW4gZXhwcmVzc2lvbiBtYXJrZXIgd2l0aCBlbWJlZGRlZCB1bmlxdWUga2V5IHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoXG4gKiBwb3NzaWJsZSB0ZXh0IGluIHRlbXBsYXRlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcmtlciA9IGB7e2xpdC0ke1N0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKX19fWA7XG4vKipcbiAqIEFuIGV4cHJlc3Npb24gbWFya2VyIHVzZWQgdGV4dC1wb3NpdGlvbnMsIG11bHRpLWJpbmRpbmcgYXR0cmlidXRlcywgYW5kXG4gKiBhdHRyaWJ1dGVzIHdpdGggbWFya3VwLWxpa2UgdGV4dCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBub2RlTWFya2VyID0gYDwhLS0ke21hcmtlcn0tLT5gO1xuZXhwb3J0IGNvbnN0IG1hcmtlclJlZ2V4ID0gbmV3IFJlZ0V4cChgJHttYXJrZXJ9fCR7bm9kZU1hcmtlcn1gKTtcbi8qKlxuICogU3VmZml4IGFwcGVuZGVkIHRvIGFsbCBib3VuZCBhdHRyaWJ1dGUgbmFtZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBib3VuZEF0dHJpYnV0ZVN1ZmZpeCA9ICckbGl0JCc7XG4vKipcbiAqIEFuIHVwZGF0ZWFibGUgVGVtcGxhdGUgdGhhdCB0cmFja3MgdGhlIGxvY2F0aW9uIG9mIGR5bmFtaWMgcGFydHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IocmVzdWx0LCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IFtdO1xuICAgICAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgICAgICAvLyBFZGdlIG5lZWRzIGFsbCA0IHBhcmFtZXRlcnMgcHJlc2VudDsgSUUxMSBuZWVkcyAzcmQgcGFyYW1ldGVyIHRvIGJlIG51bGxcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LmNvbnRlbnQsIDEzMyAvKiBOb2RlRmlsdGVyLlNIT1dfe0VMRU1FTlR8Q09NTUVOVHxURVhUfSAqLywgbnVsbCwgZmFsc2UpO1xuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgbGFzdCBpbmRleCBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0LiBXZSB0cnkgdG8gZGVsZXRlXG4gICAgICAgIC8vIHVubmVjZXNzYXJ5IG5vZGVzLCBidXQgd2UgbmV2ZXIgd2FudCB0byBhc3NvY2lhdGUgdHdvIGRpZmZlcmVudCBwYXJ0c1xuICAgICAgICAvLyB0byB0aGUgc2FtZSBpbmRleC4gVGhleSBtdXN0IGhhdmUgYSBjb25zdGFudCBub2RlIGJldHdlZW4uXG4gICAgICAgIGxldCBsYXN0UGFydEluZGV4ID0gMDtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MsIHZhbHVlczogeyBsZW5ndGggfSB9ID0gcmVzdWx0O1xuICAgICAgICB3aGlsZSAocGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aGF1c3RlZCB0aGUgY29udGVudCBpbnNpZGUgYSBuZXN0ZWQgdGVtcGxhdGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHdlIHN0aWxsIGhhdmUgcGFydHMgKHRoZSBvdXRlciBmb3ItbG9vcCksIHdlIGtub3c6XG4gICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIHRlbXBsYXRlIGluIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHdhbGtlciB3aWxsIGZpbmQgYSBuZXh0Tm9kZSBvdXRzaWRlIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAvLyBQZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hbWVkTm9kZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlcyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgcmV0dXJuZWQgaW4gZG9jdW1lbnQgb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhcnRpY3VsYXIsIEVkZ2UvSUUgY2FuIHJldHVybiB0aGVtIG91dCBvZiBvcmRlciwgc28gd2UgY2Fubm90XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBhIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcGFydCBpbmRleCBhbmQgYXR0cmlidXRlIGluZGV4LlxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kc1dpdGgoYXR0cmlidXRlc1tpXS5uYW1lLCBib3VuZEF0dHJpYnV0ZVN1ZmZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0ZW1wbGF0ZSBsaXRlcmFsIHNlY3Rpb24gbGVhZGluZyB1cCB0byB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gaW4gdGhpcyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ0ZvclBhcnQgPSBzdHJpbmdzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXguZXhlYyhzdHJpbmdGb3JQYXJ0KVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgYm91bmQgYXR0cmlidXRlcyBoYXZlIGhhZCBhIHN1ZmZpeCBhZGRlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVtcGxhdGVSZXN1bHQjZ2V0SFRNTCB0byBvcHQgb3V0IG9mIHNwZWNpYWwgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGluZy4gVG8gbG9vayB1cCB0aGUgYXR0cmlidXRlIHZhbHVlIHdlIGFsc28gbmVlZCB0byBhZGRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzdWZmaXguXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVMb29rdXBOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpICsgYm91bmRBdHRyaWJ1dGVTdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZUxvb2t1cE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTG9va3VwTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0aWNzID0gYXR0cmlidXRlVmFsdWUuc3BsaXQobWFya2VyUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHsgdHlwZTogJ2F0dHJpYnV0ZScsIGluZGV4LCBuYW1lLCBzdHJpbmdzOiBzdGF0aWNzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4ICs9IHN0YXRpY3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGUuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSAzIC8qIE5vZGUuVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5pbmRleE9mKG1hcmtlcikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ3MgPSBkYXRhLnNwbGl0KG1hcmtlclJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyB0ZXh0IG5vZGUgZm9yIGVhY2ggbGl0ZXJhbCBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIG5vZGVzIGFyZSBhbHNvIHVzZWQgYXMgdGhlIG1hcmtlcnMgZm9yIG5vZGUgcGFydHNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzID0gc3RyaW5nc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCA9IGNyZWF0ZU1hcmtlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4LmV4ZWMocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIGVuZHNXaXRoKG1hdGNoWzJdLCBib3VuZEF0dHJpYnV0ZVN1ZmZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgbWF0Y2hbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0uc2xpY2UoMCwgLWJvdW5kQXR0cmlidXRlU3VmZml4Lmxlbmd0aCkgKyBtYXRjaFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGluc2VydCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goeyB0eXBlOiAnbm9kZScsIGluZGV4OiArK2luZGV4IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gdGV4dCwgd2UgbXVzdCBpbnNlcnQgYSBjb21tZW50IHRvIG1hcmsgb3VyIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCB3ZSBjYW4gdHJ1c3QgaXQgd2lsbCBzdGljayBhcm91bmQgYWZ0ZXIgY2xvbmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3NbbGFzdEluZGV4XSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY3JlYXRlTWFya2VyKCksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gc3RyaW5nc1tsYXN0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBwYXJ0IGZvciBlYWNoIG1hdGNoIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCArPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBOb2RlLkNPTU1FTlRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09IG1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBtYXJrZXIgbm9kZSB0byBiZSB0aGUgc3RhcnROb2RlIG9mIHRoZSBQYXJ0IGlmIGFueSBvZlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgICAgICAvLyAgKiBXZSBkb24ndCBoYXZlIGEgcHJldmlvdXNTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vICAqIFRoZSBwcmV2aW91c1NpYmxpbmcgaXMgYWxyZWFkeSB0aGUgc3RhcnQgb2YgYSBwcmV2aW91cyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnByZXZpb3VzU2libGluZyA9PT0gbnVsbCB8fCBpbmRleCA9PT0gbGFzdFBhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY3JlYXRlTWFya2VyKCksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHsgdHlwZTogJ25vZGUnLCBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG5leHRTaWJsaW5nLCBrZWVwIHRoaXMgbm9kZSBzbyB3ZSBoYXZlIGFuIGVuZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgd2UgY2FuIHJlbW92ZSBpdCB0byBzYXZlIGZ1dHVyZSBjb3N0cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaSA9IG5vZGUuZGF0YS5pbmRleE9mKG1hcmtlciwgaSArIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbW1lbnQgbm9kZSBoYXMgYSBiaW5kaW5nIG1hcmtlciBpbnNpZGUsIG1ha2UgYW4gaW5hY3RpdmUgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJpbmRpbmcgd29uJ3Qgd29yaywgYnV0IHN1YnNlcXVlbnQgYmluZGluZ3Mgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAoanVzdGluZmFnbmFuaSk6IGNvbnNpZGVyIHdoZXRoZXIgaXQncyBldmVuIHdvcnRoIGl0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGJpbmRpbmdzIGluIGNvbW1lbnRzIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCh7IHR5cGU6ICdub2RlJywgaW5kZXg6IC0xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRleHQgYmluZGluZyBub2RlcyBhZnRlciB0aGUgd2FsayB0byBub3QgZGlzdHVyYiB0aGUgVHJlZVdhbGtlclxuICAgICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXNUb1JlbW92ZSkge1xuICAgICAgICAgICAgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZW5kc1dpdGggPSAoc3RyLCBzdWZmaXgpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoO1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIHN0ci5zbGljZShpbmRleCkgPT09IHN1ZmZpeDtcbn07XG5leHBvcnQgY29uc3QgaXNUZW1wbGF0ZVBhcnRBY3RpdmUgPSAocGFydCkgPT4gcGFydC5pbmRleCAhPT0gLTE7XG4vLyBBbGxvd3MgYGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpYCB0byBiZSByZW5hbWVkIGZvciBhXG4vLyBzbWFsbCBtYW51YWwgc2l6ZS1zYXZpbmdzLlxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hcmtlciA9ICgpID0+IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpO1xuLyoqXG4gKiBUaGlzIHJlZ2V4IGV4dHJhY3RzIHRoZSBhdHRyaWJ1dGUgbmFtZSBwcmVjZWRpbmcgYW4gYXR0cmlidXRlLXBvc2l0aW9uXG4gKiBleHByZXNzaW9uLiBJdCBkb2VzIHRoaXMgYnkgbWF0Y2hpbmcgdGhlIHN5bnRheCBhbGxvd2VkIGZvciBhdHRyaWJ1dGVzXG4gKiBhZ2FpbnN0IHRoZSBzdHJpbmcgbGl0ZXJhbCBkaXJlY3RseSBwcmVjZWRpbmcgdGhlIGV4cHJlc3Npb24sIGFzc3VtaW5nIHRoYXRcbiAqIHRoZSBleHByZXNzaW9uIGlzIGluIGFuIGF0dHJpYnV0ZS12YWx1ZSBwb3NpdGlvbi5cbiAqXG4gKiBTZWUgYXR0cmlidXRlcyBpbiB0aGUgSFRNTCBzcGVjOlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnRzLWF0dHJpYnV0ZXNcbiAqXG4gKiBcIiBcXHgwOVxceDBhXFx4MGNcXHgwZFwiIGFyZSBIVE1MIHNwYWNlIGNoYXJhY3RlcnM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNzcGFjZS1jaGFyYWN0ZXJzXG4gKlxuICogXCJcXDAtXFx4MUZcXHg3Ri1cXHg5RlwiIGFyZSBVbmljb2RlIGNvbnRyb2wgY2hhcmFjdGVycywgd2hpY2ggaW5jbHVkZXMgZXZlcnlcbiAqIHNwYWNlIGNoYXJhY3RlciBleGNlcHQgXCIgXCIuXG4gKlxuICogU28gYW4gYXR0cmlidXRlIGlzOlxuICogICogVGhlIG5hbWU6IGFueSBjaGFyYWN0ZXIgZXhjZXB0IGEgY29udHJvbCBjaGFyYWN0ZXIsIHNwYWNlIGNoYXJhY3RlciwgKCcpLFxuICogICAgKFwiKSwgXCI+XCIsIFwiPVwiLCBvciBcIi9cIlxuICogICogRm9sbG93ZWQgYnkgemVybyBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnNcbiAqICAqIEZvbGxvd2VkIGJ5IFwiPVwiXG4gKiAgKiBGb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVyc1xuICogICogRm9sbG93ZWQgYnk6XG4gKiAgICAqIEFueSBjaGFyYWN0ZXIgZXhjZXB0IHNwYWNlLCAoJyksIChcIiksIFwiPFwiLCBcIj5cIiwgXCI9XCIsIChgKSwgb3JcbiAqICAgICogKFwiKSB0aGVuIGFueSBub24tKFwiKSwgb3JcbiAqICAgICogKCcpIHRoZW4gYW55IG5vbi0oJylcbiAqL1xuZXhwb3J0IGNvbnN0IGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXggPSAvKFsgXFx4MDlcXHgwYVxceDBjXFx4MGRdKShbXlxcMC1cXHgxRlxceDdGLVxceDlGIFwiJz49L10rKShbIFxceDA5XFx4MGFcXHgwY1xceDBkXSo9WyBcXHgwOVxceDBhXFx4MGNcXHgwZF0qKD86W14gXFx4MDlcXHgwYVxceDBjXFx4MGRcIidgPD49XSp8XCJbXlwiXSp8J1teJ10qKSkkLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyBpc0NFUG9seWZpbGwgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBpc1RlbXBsYXRlUGFydEFjdGl2ZSB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBhIGBUZW1wbGF0ZWAgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSBhbmQgdXBkYXRlZFxuICogd2l0aCBuZXcgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGUsIHByb2Nlc3Nvciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9fcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9fcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnNldFZhbHVlKHZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX19wYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnQuY29tbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Nsb25lKCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgYSBudW1iZXIgb2Ygc3RlcHMgaW4gdGhlIGxpZmVjeWNsZSBvZiBhIHRlbXBsYXRlIGluc3RhbmNlJ3NcbiAgICAgICAgLy8gRE9NIGZyYWdtZW50OlxuICAgICAgICAvLyAgMS4gQ2xvbmUgLSBjcmVhdGUgdGhlIGluc3RhbmNlIGZyYWdtZW50XG4gICAgICAgIC8vICAyLiBBZG9wdCAtIGFkb3B0IGludG8gdGhlIG1haW4gZG9jdW1lbnRcbiAgICAgICAgLy8gIDMuIFByb2Nlc3MgLSBmaW5kIHBhcnQgbWFya2VycyBhbmQgY3JlYXRlIHBhcnRzXG4gICAgICAgIC8vICA0LiBVcGdyYWRlIC0gdXBncmFkZSBjdXN0b20gZWxlbWVudHNcbiAgICAgICAgLy8gIDUuIFVwZGF0ZSAtIHNldCBub2RlLCBhdHRyaWJ1dGUsIHByb3BlcnR5LCBldGMuLCB2YWx1ZXNcbiAgICAgICAgLy8gIDYuIENvbm5lY3QgLSBjb25uZWN0IHRvIHRoZSBkb2N1bWVudC4gT3B0aW9uYWwgYW5kIG91dHNpZGUgb2YgdGhpc1xuICAgICAgICAvLyAgICAgbWV0aG9kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBoYXZlIGEgZmV3IGNvbnN0cmFpbnRzIG9uIHRoZSBvcmRlcmluZyBvZiB0aGVzZSBzdGVwczpcbiAgICAgICAgLy8gICogV2UgbmVlZCB0byB1cGdyYWRlIGJlZm9yZSB1cGRhdGluZywgc28gdGhhdCBwcm9wZXJ0eSB2YWx1ZXMgd2lsbCBwYXNzXG4gICAgICAgIC8vICAgIHRocm91Z2ggYW55IHByb3BlcnR5IHNldHRlcnMuXG4gICAgICAgIC8vICAqIFdlIHdvdWxkIGxpa2UgdG8gcHJvY2VzcyBiZWZvcmUgdXBncmFkaW5nIHNvIHRoYXQgd2UncmUgc3VyZSB0aGF0IHRoZVxuICAgICAgICAvLyAgICBjbG9uZWQgZnJhZ21lbnQgaXMgaW5lcnQgYW5kIG5vdCBkaXN0dXJiZWQgYnkgc2VsZi1tb2RpZnlpbmcgRE9NLlxuICAgICAgICAvLyAgKiBXZSB3YW50IGN1c3RvbSBlbGVtZW50cyB0byB1cGdyYWRlIGV2ZW4gaW4gZGlzY29ubmVjdGVkIGZyYWdtZW50cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gdGhlc2UgY29uc3RyYWludHMsIHdpdGggZnVsbCBjdXN0b20gZWxlbWVudHMgc3VwcG9ydCB3ZSB3b3VsZFxuICAgICAgICAvLyBwcmVmZXIgdGhlIG9yZGVyOiBDbG9uZSwgUHJvY2VzcywgQWRvcHQsIFVwZ3JhZGUsIFVwZGF0ZSwgQ29ubmVjdFxuICAgICAgICAvL1xuICAgICAgICAvLyBCdXQgU2FmYXJpIGRvb2VzIG5vdCBpbXBsZW1lbnQgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5I3VwZ3JhZGUsIHNvIHdlXG4gICAgICAgIC8vIGNhbiBub3QgaW1wbGVtZW50IHRoYXQgb3JkZXIgYW5kIHN0aWxsIGhhdmUgdXBncmFkZS1iZWZvcmUtdXBkYXRlIGFuZFxuICAgICAgICAvLyB1cGdyYWRlIGRpc2Nvbm5lY3RlZCBmcmFnbWVudHMuIFNvIHdlIGluc3RlYWQgc2FjcmlmaWNlIHRoZVxuICAgICAgICAvLyBwcm9jZXNzLWJlZm9yZS11cGdyYWRlIGNvbnN0cmFpbnQsIHNpbmNlIGluIEN1c3RvbSBFbGVtZW50cyB2MSBlbGVtZW50c1xuICAgICAgICAvLyBtdXN0IG5vdCBtb2RpZnkgdGhlaXIgbGlnaHQgRE9NIGluIHRoZSBjb25zdHJ1Y3Rvci4gV2Ugc3RpbGwgaGF2ZSBpc3N1ZXNcbiAgICAgICAgLy8gd2hlbiBjby1leGlzdGluZyB3aXRoIENFdjAgZWxlbWVudHMgbGlrZSBQb2x5bWVyIDEsIGFuZCB3aXRoIHBvbHlmaWxsc1xuICAgICAgICAvLyB0aGF0IGRvbid0IHN0cmljdGx5IGFkaGVyZSB0byB0aGUgbm8tbW9kaWZpY2F0aW9uIHJ1bGUgYmVjYXVzZSBzaGFkb3dcbiAgICAgICAgLy8gRE9NLCB3aGljaCBtYXkgYmUgY3JlYXRlZCBpbiB0aGUgY29uc3RydWN0b3IsIGlzIGVtdWxhdGVkIGJ5IGJlaW5nIHBsYWNlZFxuICAgICAgICAvLyBpbiB0aGUgbGlnaHQgRE9NLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcmVzdWx0aW5nIG9yZGVyIGlzIG9uIG5hdGl2ZSBpczogQ2xvbmUsIEFkb3B0LCBVcGdyYWRlLCBQcm9jZXNzLFxuICAgICAgICAvLyBVcGRhdGUsIENvbm5lY3QuIGRvY3VtZW50LmltcG9ydE5vZGUoKSBwZXJmb3JtcyBDbG9uZSwgQWRvcHQsIGFuZCBVcGdyYWRlXG4gICAgICAgIC8vIGluIG9uZSBzdGVwLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgQ3VzdG9tIEVsZW1lbnRzIHYxIHBvbHlmaWxsIHN1cHBvcnRzIHVwZ3JhZGUoKSwgc28gdGhlIG9yZGVyIHdoZW5cbiAgICAgICAgLy8gcG9seWZpbGxlZCBpcyB0aGUgbW9yZSBpZGVhbDogQ2xvbmUsIFByb2Nlc3MsIEFkb3B0LCBVcGdyYWRlLCBVcGRhdGUsXG4gICAgICAgIC8vIENvbm5lY3QuXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gaXNDRVBvbHlmaWxsID9cbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuZWxlbWVudC5jb250ZW50LmNsb25lTm9kZSh0cnVlKSA6XG4gICAgICAgICAgICBkb2N1bWVudC5pbXBvcnROb2RlKHRoaXMudGVtcGxhdGUuZWxlbWVudC5jb250ZW50LCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnRlbXBsYXRlLnBhcnRzO1xuICAgICAgICAvLyBFZGdlIG5lZWRzIGFsbCA0IHBhcmFtZXRlcnMgcHJlc2VudDsgSUUxMSBuZWVkcyAzcmQgcGFyYW1ldGVyIHRvIGJlIG51bGxcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihmcmFnbWVudCwgMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV197RUxFTUVOVHxDT01NRU5UfFRFWFR9ICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IHBhcnQ7XG4gICAgICAgIGxldCBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIG5vZGVzIGFuZCBwYXJ0cyBvZiBhIHRlbXBsYXRlXG4gICAgICAgIHdoaWxlIChwYXJ0SW5kZXggPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpc1RlbXBsYXRlUGFydEFjdGl2ZShwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19wYXJ0cy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9ncmVzcyB0aGUgdHJlZSB3YWxrZXIgdW50aWwgd2UgZmluZCBvdXIgbmV4dCBwYXJ0J3Mgbm9kZS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBtdWx0aXBsZSBwYXJ0cyBtYXkgc2hhcmUgdGhlIHNhbWUgbm9kZSAoYXR0cmlidXRlIHBhcnRzXG4gICAgICAgICAgICAvLyBvbiBhIHNpbmdsZSBlbGVtZW50KSwgc28gdGhpcyBsb29wIG1heSBub3QgcnVuIGF0IGFsbC5cbiAgICAgICAgICAgIHdoaWxlIChub2RlSW5kZXggPCBwYXJ0LmluZGV4KSB7XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdURU1QTEFURScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZXhoYXVzdGVkIHRoZSBjb250ZW50IGluc2lkZSBhIG5lc3RlZCB0ZW1wbGF0ZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHdlIHN0aWxsIGhhdmUgcGFydHMgKHRoZSBvdXRlciBmb3ItbG9vcCksIHdlIGtub3c6XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gVGhlcmUgaXMgYSB0ZW1wbGF0ZSBpbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGUgd2Fsa2VyIHdpbGwgZmluZCBhIG5leHROb2RlIG91dHNpZGUgdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UndmUgYXJyaXZlZCBhdCBvdXIgcGFydCdzIG5vZGUuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gdGhpcy5wcm9jZXNzb3IuaGFuZGxlVGV4dEV4cHJlc3Npb24odGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBwYXJ0Lmluc2VydEFmdGVyTm9kZShub2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3BhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcGFydHMucHVzaCguLi50aGlzLnByb2Nlc3Nvci5oYW5kbGVBdHRyaWJ1dGVFeHByZXNzaW9ucyhub2RlLCBwYXJ0Lm5hbWUsIHBhcnQuc3RyaW5ncywgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDRVBvbHlmaWxsKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZG9wdE5vZGUoZnJhZ21lbnQpO1xuICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMudXBncmFkZShmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLWluc3RhbmNlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyByZXBhcmVudE5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgYm91bmRBdHRyaWJ1dGVTdWZmaXgsIGxhc3RBdHRyaWJ1dGVOYW1lUmVnZXgsIG1hcmtlciwgbm9kZU1hcmtlciB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuY29uc3QgY29tbWVudE1hcmtlciA9IGAgJHttYXJrZXJ9IGA7XG4vKipcbiAqIFRoZSByZXR1cm4gdHlwZSBvZiBgaHRtbGAsIHdoaWNoIGhvbGRzIGEgVGVtcGxhdGUgYW5kIHRoZSB2YWx1ZXMgZnJvbVxuICogaW50ZXJwb2xhdGVkIGV4cHJlc3Npb25zLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcywgdHlwZSwgcHJvY2Vzc29yKSB7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBvZiBIVE1MIHVzZWQgdG8gY3JlYXRlIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0SFRNTCgpIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgaHRtbCA9ICcnO1xuICAgICAgICBsZXQgaXNDb21tZW50QmluZGluZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMuc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGJpbmRpbmcgd2Ugd2FudCB0byBkZXRlcm1pbmUgdGhlIGtpbmQgb2YgbWFya2VyIHRvIGluc2VydFxuICAgICAgICAgICAgLy8gaW50byB0aGUgdGVtcGxhdGUgc291cmNlIGJlZm9yZSBpdCdzIHBhcnNlZCBieSB0aGUgYnJvd3NlcidzIEhUTUxcbiAgICAgICAgICAgIC8vIHBhcnNlci4gVGhlIG1hcmtlciB0eXBlIGlzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGV4cHJlc3Npb24gaXMgaW4gYW5cbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSwgdGV4dCwgb3IgY29tbWVudCBwb2lzaXRpb24uXG4gICAgICAgICAgICAvLyAgICogRm9yIG5vZGUtcG9zaXRpb24gYmluZGluZ3Mgd2UgaW5zZXJ0IGEgY29tbWVudCB3aXRoIHRoZSBtYXJrZXJcbiAgICAgICAgICAgIC8vICAgICBzZW50aW5lbCBhcyBpdHMgdGV4dCBjb250ZW50LCBsaWtlIDwhLS17e2xpdC1ndWlkfX0tLT4uXG4gICAgICAgICAgICAvLyAgICogRm9yIGF0dHJpYnV0ZSBiaW5kaW5ncyB3ZSBpbnNlcnQganVzdCB0aGUgbWFya2VyIHNlbnRpbmVsIGZvciB0aGVcbiAgICAgICAgICAgIC8vICAgICBmaXJzdCBiaW5kaW5nLCBzbyB0aGF0IHdlIHN1cHBvcnQgdW5xdW90ZWQgYXR0cmlidXRlIGJpbmRpbmdzLlxuICAgICAgICAgICAgLy8gICAgIFN1YnNlcXVlbnQgYmluZGluZ3MgY2FuIHVzZSBhIGNvbW1lbnQgbWFya2VyIGJlY2F1c2UgbXVsdGktYmluZGluZ1xuICAgICAgICAgICAgLy8gICAgIGF0dHJpYnV0ZXMgbXVzdCBiZSBxdW90ZWQuXG4gICAgICAgICAgICAvLyAgICogRm9yIGNvbW1lbnQgYmluZGluZ3Mgd2UgaW5zZXJ0IGp1c3QgdGhlIG1hcmtlciBzZW50aW5lbCBzbyB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gICAgIGNsb3NlIHRoZSBjb21tZW50LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBzY2FucyB0aGUgdGVtcGxhdGUgc291cmNlLCBidXQgaXMgKm5vdCogYW4gSFRNTFxuICAgICAgICAgICAgLy8gcGFyc2VyLiBXZSBkb24ndCBuZWVkIHRvIHRyYWNrIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgSFRNTCwgb25seVxuICAgICAgICAgICAgLy8gd2hldGhlciBhIGJpbmRpbmcgaXMgaW5zaWRlIGEgY29tbWVudCwgYW5kIGlmIG5vdCwgaWYgaXQgYXBwZWFycyB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGJpbmRpbmcgaW4gYW4gYXR0cmlidXRlLlxuICAgICAgICAgICAgY29uc3QgY29tbWVudE9wZW4gPSBzLmxhc3RJbmRleE9mKCc8IS0tJyk7XG4gICAgICAgICAgICAvLyBXZSdyZSBpbiBjb21tZW50IHBvc2l0aW9uIGlmIHdlIGhhdmUgYSBjb21tZW50IG9wZW4gd2l0aCBubyBmb2xsb3dpbmdcbiAgICAgICAgICAgIC8vIGNvbW1lbnQgY2xvc2UuIEJlY2F1c2UgPC0tIGNhbiBhcHBlYXIgaW4gYW4gYXR0cmlidXRlIHZhbHVlIHRoZXJlIGNhblxuICAgICAgICAgICAgLy8gYmUgZmFsc2UgcG9zaXRpdmVzLlxuICAgICAgICAgICAgaXNDb21tZW50QmluZGluZyA9IChjb21tZW50T3BlbiA+IC0xIHx8IGlzQ29tbWVudEJpbmRpbmcpICYmXG4gICAgICAgICAgICAgICAgcy5pbmRleE9mKCctLT4nLCBjb21tZW50T3BlbiArIDEpID09PSAtMTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFuIGF0dHJpYnV0ZS1saWtlIHNlcXVlbmNlIHByZWNlZWRpbmcgdGhlXG4gICAgICAgICAgICAvLyBleHByZXNzaW9uLiBUaGlzIGNhbiBtYXRjaCBcIm5hbWU9dmFsdWVcIiBsaWtlIHN0cnVjdHVyZXMgaW4gdGV4dCxcbiAgICAgICAgICAgIC8vIGNvbW1lbnRzLCBhbmQgYXR0cmlidXRlIHZhbHVlcywgc28gdGhlcmUgY2FuIGJlIGZhbHNlLXBvc2l0aXZlcy5cbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZU1hdGNoID0gbGFzdEF0dHJpYnV0ZU5hbWVSZWdleC5leGVjKHMpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgb25seSBpbiB0aGlzIGJyYW5jaCBpZiB3ZSBkb24ndCBoYXZlIGEgYXR0cmlidXRlLWxpa2VcbiAgICAgICAgICAgICAgICAvLyBwcmVjZWVkaW5nIHNlcXVlbmNlLiBGb3IgY29tbWVudHMsIHRoaXMgZ3VhcmRzIGFnYWluc3QgdW51c3VhbFxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSB2YWx1ZXMgbGlrZSA8ZGl2IGZvbz1cIjwhLS0keydiYXInfVwiPi4gQ2FzZXMgbGlrZVxuICAgICAgICAgICAgICAgIC8vIDwhLS0gZm9vPSR7J2Jhcid9LS0+IGFyZSBoYW5kbGVkIGNvcnJlY3RseSBpbiB0aGUgYXR0cmlidXRlIGJyYW5jaFxuICAgICAgICAgICAgICAgIC8vIGJlbG93LlxuICAgICAgICAgICAgICAgIGh0bWwgKz0gcyArIChpc0NvbW1lbnRCaW5kaW5nID8gY29tbWVudE1hcmtlciA6IG5vZGVNYXJrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGF0dHJpYnV0ZXMgd2UgdXNlIGp1c3QgYSBtYXJrZXIgc2VudGluZWwsIGFuZCBhbHNvIGFwcGVuZCBhXG4gICAgICAgICAgICAgICAgLy8gJGxpdCQgc3VmZml4IHRvIHRoZSBuYW1lIHRvIG9wdC1vdXQgb2YgYXR0cmlidXRlLXNwZWNpZmljIHBhcnNpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IElFIGFuZCBFZGdlIGRvIGZvciBzdHlsZSBhbmQgY2VydGFpbiBTVkcgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICBodG1sICs9IHMuc3Vic3RyKDAsIGF0dHJpYnV0ZU1hdGNoLmluZGV4KSArIGF0dHJpYnV0ZU1hdGNoWzFdICtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTWF0Y2hbMl0gKyBib3VuZEF0dHJpYnV0ZVN1ZmZpeCArIGF0dHJpYnV0ZU1hdGNoWzNdICtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gdGhpcy5zdHJpbmdzW2xdO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGVFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRoaXMuZ2V0SFRNTCgpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxufVxuLyoqXG4gKiBBIFRlbXBsYXRlUmVzdWx0IGZvciBTVkcgZnJhZ21lbnRzLlxuICpcbiAqIFRoaXMgY2xhc3Mgd3JhcHMgSFRNTCBpbiBhbiBgPHN2Zz5gIHRhZyBpbiBvcmRlciB0byBwYXJzZSBpdHMgY29udGVudHMgaW4gdGhlXG4gKiBTVkcgbmFtZXNwYWNlLCB0aGVuIG1vZGlmaWVzIHRoZSB0ZW1wbGF0ZSB0byByZW1vdmUgdGhlIGA8c3ZnPmAgdGFnIHNvIHRoYXRcbiAqIGNsb25lcyBvbmx5IGNvbnRhaW5lciB0aGUgb3JpZ2luYWwgZnJhZ21lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTVkdUZW1wbGF0ZVJlc3VsdCBleHRlbmRzIFRlbXBsYXRlUmVzdWx0IHtcbiAgICBnZXRIVE1MKCkge1xuICAgICAgICByZXR1cm4gYDxzdmc+JHtzdXBlci5nZXRIVE1MKCl9PC9zdmc+YDtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGVFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHN1cGVyLmdldFRlbXBsYXRlRWxlbWVudCgpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGVtcGxhdGUuY29udGVudDtcbiAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgY29udGVudC5yZW1vdmVDaGlsZChzdmdFbGVtZW50KTtcbiAgICAgICAgcmVwYXJlbnROb2Rlcyhjb250ZW50LCBzdmdFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUtcmVzdWx0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyBpc0RpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IHJlbW92ZU5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgbm9DaGFuZ2UsIG5vdGhpbmcgfSBmcm9tICcuL3BhcnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZSB9IGZyb20gJy4vdGVtcGxhdGUtaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICcuL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVNYXJrZXIgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbmV4cG9ydCBjb25zdCBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgISh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykpO1xufTtcbmV4cG9ydCBjb25zdCBpc0l0ZXJhYmxlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgISEodmFsdWUgJiYgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSk7XG59O1xuLyoqXG4gKiBXcml0ZXMgYXR0cmlidXRlIHZhbHVlcyB0byB0aGUgRE9NIGZvciBhIGdyb3VwIG9mIEF0dHJpYnV0ZVBhcnRzIGJvdW5kIHRvIGFcbiAqIHNpbmdsZSBhdHRpYnV0ZS4gVGhlIHZhbHVlIGlzIG9ubHkgc2V0IG9uY2UgZXZlbiBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGFydHNcbiAqIGZvciBhbiBhdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVDb21taXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5wYXJ0c1tpXSA9IHRoaXMuX2NyZWF0ZVBhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlIHBhcnQuIE92ZXJyaWRlIHRoaXMgdG8gY3JlYXRlIGEgZGlmZmVybnQgdHlwZSBvZiBwYXJ0LlxuICAgICAqL1xuICAgIF9jcmVhdGVQYXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZVBhcnQodGhpcyk7XG4gICAgfVxuICAgIF9nZXRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IHRoaXMuc3RyaW5ncztcbiAgICAgICAgY29uc3QgbCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRleHQgKz0gc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBwYXJ0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2KSB8fCAhaXNJdGVyYWJsZSh2KSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHYgOiBTdHJpbmcodik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2Ygdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0eXBlb2YgdCA9PT0gJ3N0cmluZycgPyB0IDogU3RyaW5nKHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRleHQgKz0gc3RyaW5nc1tsXTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLCB0aGlzLl9nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBQYXJ0IHRoYXQgY29udHJvbHMgYWxsIG9yIHBhcnQgb2YgYW4gYXR0cmlidXRlIHZhbHVlLlxuICovXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlUGFydCB7XG4gICAgY29uc3RydWN0b3IoY29tbWl0dGVyKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29tbWl0dGVyID0gY29tbWl0dGVyO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IG5vQ2hhbmdlICYmICghaXNQcmltaXRpdmUodmFsdWUpIHx8IHZhbHVlICE9PSB0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgbm90IGEgZGlyZWN0aXZlLCBkaXJ0eSB0aGUgY29tbWl0dGVyIHNvIHRoYXQgaXQnbGxcbiAgICAgICAgICAgIC8vIGNhbGwgc2V0QXR0cmlidXRlLiBJZiB0aGUgdmFsdWUgaXMgYSBkaXJlY3RpdmUsIGl0J2xsIGRpcnR5IHRoZVxuICAgICAgICAgICAgLy8gY29tbWl0dGVyIGlmIGl0IGNhbGxzIHNldFZhbHVlKCkuXG4gICAgICAgICAgICBpZiAoIWlzRGlyZWN0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0dGVyLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1pdHRlci5jb21taXQoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgUGFydCB0aGF0IGNvbnRyb2xzIGEgbG9jYXRpb24gd2l0aGluIGEgTm9kZSB0cmVlLiBMaWtlIGEgUmFuZ2UsIE5vZGVQYXJ0XG4gKiBoYXMgc3RhcnQgYW5kIGVuZCBsb2NhdGlvbnMgYW5kIGNhbiBzZXQgYW5kIHVwZGF0ZSB0aGUgTm9kZXMgYmV0d2VlbiB0aG9zZVxuICogbG9jYXRpb25zLlxuICpcbiAqIE5vZGVQYXJ0cyBzdXBwb3J0IHNldmVyYWwgdmFsdWUgdHlwZXM6IHByaW1pdGl2ZXMsIE5vZGVzLCBUZW1wbGF0ZVJlc3VsdHMsXG4gKiBhcyB3ZWxsIGFzIGFycmF5cyBhbmQgaXRlcmFibGVzIG9mIHRob3NlIHR5cGVzLlxuICovXG5leHBvcnQgY2xhc3MgTm9kZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGlzIHBhcnQgaW50byBhIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIFRoaXMgcGFydCBtdXN0IGJlIGVtcHR5LCBhcyBpdHMgY29udGVudHMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IG1vdmVkLlxuICAgICAqL1xuICAgIGFwcGVuZEludG8oY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhcnROb2RlID0gY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZU1hcmtlcigpKTtcbiAgICAgICAgdGhpcy5lbmROb2RlID0gY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZU1hcmtlcigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGlzIHBhcnQgYWZ0ZXIgdGhlIGByZWZgIG5vZGUgKGJldHdlZW4gYHJlZmAgYW5kIGByZWZgJ3MgbmV4dFxuICAgICAqIHNpYmxpbmcpLiBCb3RoIGByZWZgIGFuZCBpdHMgbmV4dCBzaWJsaW5nIG11c3QgYmUgc3RhdGljLCB1bmNoYW5naW5nIG5vZGVzXG4gICAgICogc3VjaCBhcyB0aG9zZSB0aGF0IGFwcGVhciBpbiBhIGxpdGVyYWwgc2VjdGlvbiBvZiBhIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXJ0IG11c3QgYmUgZW1wdHksIGFzIGl0cyBjb250ZW50cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbW92ZWQuXG4gICAgICovXG4gICAgaW5zZXJ0QWZ0ZXJOb2RlKHJlZikge1xuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IHJlZjtcbiAgICAgICAgdGhpcy5lbmROb2RlID0gcmVmLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoaXMgcGFydCBpbnRvIGEgcGFyZW50IHBhcnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhcnQgbXVzdCBiZSBlbXB0eSwgYXMgaXRzIGNvbnRlbnRzIGFyZSBub3QgYXV0b21hdGljYWxseSBtb3ZlZC5cbiAgICAgKi9cbiAgICBhcHBlbmRJbnRvUGFydChwYXJ0KSB7XG4gICAgICAgIHBhcnQuX19pbnNlcnQodGhpcy5zdGFydE5vZGUgPSBjcmVhdGVNYXJrZXIoKSk7XG4gICAgICAgIHBhcnQuX19pbnNlcnQodGhpcy5lbmROb2RlID0gY3JlYXRlTWFya2VyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoaXMgcGFydCBhZnRlciB0aGUgYHJlZmAgcGFydC5cbiAgICAgKlxuICAgICAqIFRoaXMgcGFydCBtdXN0IGJlIGVtcHR5LCBhcyBpdHMgY29udGVudHMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IG1vdmVkLlxuICAgICAqL1xuICAgIGluc2VydEFmdGVyUGFydChyZWYpIHtcbiAgICAgICAgcmVmLl9faW5zZXJ0KHRoaXMuc3RhcnROb2RlID0gY3JlYXRlTWFya2VyKCkpO1xuICAgICAgICB0aGlzLmVuZE5vZGUgPSByZWYuZW5kTm9kZTtcbiAgICAgICAgcmVmLmVuZE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLl9fcGVuZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29tbWl0VGV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdFRlbXBsYXRlUmVzdWx0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXROb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbm90aGluZykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5vdGhpbmc7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjaywgd2lsbCByZW5kZXIgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdFRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9faW5zZXJ0KG5vZGUpIHtcbiAgICAgICAgdGhpcy5lbmROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRoaXMuZW5kTm9kZSk7XG4gICAgfVxuICAgIF9fY29tbWl0Tm9kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX19pbnNlcnQodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIF9fY29tbWl0VGV4dCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIC8vIElmIGB2YWx1ZWAgaXNuJ3QgYWxyZWFkeSBhIHN0cmluZywgd2UgZXhwbGljaXRseSBjb252ZXJ0IGl0IGhlcmUgaW4gY2FzZVxuICAgICAgICAvLyBpdCBjYW4ndCBiZSBpbXBsaWNpdGx5IGNvbnZlcnRlZCAtIGkuZS4gaXQncyBhIHN5bWJvbC5cbiAgICAgICAgY29uc3QgdmFsdWVBc1N0cmluZyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmVuZE5vZGUucHJldmlvdXNTaWJsaW5nICYmXG4gICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzIC8qIE5vZGUuVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBvbmx5IGhhdmUgYSBzaW5nbGUgdGV4dCBub2RlIGJldHdlZW4gdGhlIG1hcmtlcnMsIHdlIGNhbiBqdXN0XG4gICAgICAgICAgICAvLyBzZXQgaXRzIHZhbHVlLCByYXRoZXIgdGhhbiByZXBsYWNpbmcgaXQuXG4gICAgICAgICAgICAvLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiBDYW4gd2UganVzdCBjaGVjayBpZiB0aGlzLnZhbHVlIGlzIHByaW1pdGl2ZT9cbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZUFzU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBfX2NvbW1pdFRlbXBsYXRlUmVzdWx0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlRmFjdG9yeSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVJbnN0YW5jZSAmJlxuICAgICAgICAgICAgdGhpcy52YWx1ZS50ZW1wbGF0ZSA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHZhbHVlLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJvcGFnYXRlIHRoZSB0ZW1wbGF0ZSBwcm9jZXNzb3IgZnJvbSB0aGUgVGVtcGxhdGVSZXN1bHRcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgdXNlIGl0cyBzeW50YXggZXh0ZW5zaW9uLCBldGMuIFRoZSB0ZW1wbGF0ZSBmYWN0b3J5IGNvbWVzXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSByZW5kZXIgZnVuY3Rpb24gb3B0aW9ucyBzbyB0aGF0IGl0IGNhbiBjb250cm9sIHRlbXBsYXRlXG4gICAgICAgICAgICAvLyBjYWNoaW5nIGFuZCBwcmVwcm9jZXNzaW5nLlxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGVJbnN0YW5jZSh0ZW1wbGF0ZSwgdmFsdWUucHJvY2Vzc29yLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBpbnN0YW5jZS5fY2xvbmUoKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSh2YWx1ZS52YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdE5vZGUoZnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9fY29tbWl0SXRlcmFibGUodmFsdWUpIHtcbiAgICAgICAgLy8gRm9yIGFuIEl0ZXJhYmxlLCB3ZSBjcmVhdGUgYSBuZXcgSW5zdGFuY2VQYXJ0IHBlciBpdGVtLCB0aGVuIHNldCBpdHNcbiAgICAgICAgLy8gdmFsdWUgdG8gdGhlIGl0ZW0uIFRoaXMgaXMgYSBsaXR0bGUgYml0IG9mIG92ZXJoZWFkIGZvciBldmVyeSBpdGVtIGluXG4gICAgICAgIC8vIGFuIEl0ZXJhYmxlLCBidXQgaXQgbGV0cyB1cyByZWN1cnNlIGVhc2lseSBhbmQgZWZmaWNpZW50bHkgdXBkYXRlIEFycmF5c1xuICAgICAgICAvLyBvZiBUZW1wbGF0ZVJlc3VsdHMgdGhhdCB3aWxsIGJlIGNvbW1vbmx5IHJldHVybmVkIGZyb20gZXhwcmVzc2lvbnMgbGlrZTpcbiAgICAgICAgLy8gYXJyYXkubWFwKChpKSA9PiBodG1sYCR7aX1gKSwgYnkgcmV1c2luZyBleGlzdGluZyBUZW1wbGF0ZUluc3RhbmNlcy5cbiAgICAgICAgLy8gSWYgX3ZhbHVlIGlzIGFuIGFycmF5LCB0aGVuIHRoZSBwcmV2aW91cyByZW5kZXIgd2FzIG9mIGFuXG4gICAgICAgIC8vIGl0ZXJhYmxlIGFuZCBfdmFsdWUgd2lsbCBjb250YWluIHRoZSBOb2RlUGFydHMgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gcmVuZGVyLiBJZiBfdmFsdWUgaXMgbm90IGFuIGFycmF5LCBjbGVhciB0aGlzIHBhcnQgYW5kIG1ha2UgYSBuZXdcbiAgICAgICAgLy8gYXJyYXkgZm9yIE5vZGVQYXJ0cy5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV0cyB1cyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGl0ZW1zIHdlIHN0YW1wZWQgc28gd2UgY2FuIGNsZWFyIGxlZnRvdmVyXG4gICAgICAgIC8vIGl0ZW1zIGZyb20gYSBwcmV2aW91cyByZW5kZXJcbiAgICAgICAgY29uc3QgaXRlbVBhcnRzID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBpdGVtUGFydDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmV1c2UgYW4gZXhpc3RpbmcgcGFydFxuICAgICAgICAgICAgaXRlbVBhcnQgPSBpdGVtUGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgICAgIC8vIElmIG5vIGV4aXN0aW5nIHBhcnQsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICAgIGlmIChpdGVtUGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbVBhcnQgPSBuZXcgTm9kZVBhcnQodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpdGVtUGFydHMucHVzaChpdGVtUGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtUGFydC5hcHBlbmRJbnRvUGFydCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1QYXJ0Lmluc2VydEFmdGVyUGFydChpdGVtUGFydHNbcGFydEluZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1QYXJ0LnNldFZhbHVlKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbVBhcnQuY29tbWl0KCk7XG4gICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEluZGV4IDwgaXRlbVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdGhlIHBhcnRzIGFycmF5IHNvIF92YWx1ZSByZWZsZWN0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgaXRlbVBhcnRzLmxlbmd0aCA9IHBhcnRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoaXRlbVBhcnQgJiYgaXRlbVBhcnQuZW5kTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoc3RhcnROb2RlID0gdGhpcy5zdGFydE5vZGUpIHtcbiAgICAgICAgcmVtb3ZlTm9kZXModGhpcy5zdGFydE5vZGUucGFyZW50Tm9kZSwgc3RhcnROb2RlLm5leHRTaWJsaW5nLCB0aGlzLmVuZE5vZGUpO1xuICAgIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIGJvb2xlYW4gYXR0cmlidXRlLCByb3VnaGx5IGFzIGRlZmluZWQgaW4gdGhlIEhUTUxcbiAqIHNwZWNpZmljYXRpb24uXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIHRydXRoeSwgdGhlbiB0aGUgYXR0cmlidXRlIGlzIHByZXNlbnQgd2l0aCBhIHZhbHVlIG9mXG4gKiAnJy4gSWYgdGhlIHZhbHVlIGlzIGZhbHNleSwgdGhlIGF0dHJpYnV0ZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkF0dHJpYnV0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN0cmluZ3MubGVuZ3RoICE9PSAyIHx8IHN0cmluZ3NbMF0gIT09ICcnIHx8IHN0cmluZ3NbMV0gIT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb2xlYW4gYXR0cmlidXRlcyBjYW4gb25seSBjb250YWluIGEgc2luZ2xlIGV4cHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgd2hpbGUgKGlzRGlyZWN0aXZlKHRoaXMuX19wZW5kaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgICAgICAgICAgZGlyZWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fcGVuZGluZ1ZhbHVlID09PSBub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gISF0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgIH1cbn1cbi8qKlxuICogU2V0cyBhdHRyaWJ1dGUgdmFsdWVzIGZvciBQcm9wZXJ0eVBhcnRzLCBzbyB0aGF0IHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBvbmNlXG4gKiBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJ0cyBmb3IgYSBwcm9wZXJ0eS5cbiAqXG4gKiBJZiBhbiBleHByZXNzaW9uIGNvbnRyb2xzIHRoZSB3aG9sZSBwcm9wZXJ0eSB2YWx1ZSwgdGhlbiB0aGUgdmFsdWUgaXMgc2ltcGx5XG4gKiBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgdW5kZXIgY29udHJvbC4gSWYgdGhlcmUgYXJlIHN0cmluZyBsaXRlcmFscyBvclxuICogbXVsdGlwbGUgZXhwcmVzc2lvbnMsIHRoZW4gdGhlIHN0cmluZ3MgYXJlIGV4cHJlc3Npb25zIGFyZSBpbnRlcnBvbGF0ZWQgaW50b1xuICogYSBzdHJpbmcgZmlyc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUNvbW1pdHRlciBleHRlbmRzIEF0dHJpYnV0ZUNvbW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmFtZSwgc3RyaW5ncykge1xuICAgICAgICBzdXBlcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdGhpcy5zaW5nbGUgPVxuICAgICAgICAgICAgKHN0cmluZ3MubGVuZ3RoID09PSAyICYmIHN0cmluZ3NbMF0gPT09ICcnICYmIHN0cmluZ3NbMV0gPT09ICcnKTtcbiAgICB9XG4gICAgX2NyZWF0ZVBhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlQYXJ0KHRoaXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydHNbMF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRbdGhpcy5uYW1lXSA9IHRoaXMuX2dldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUHJvcGVydHlQYXJ0IGV4dGVuZHMgQXR0cmlidXRlUGFydCB7XG59XG4vLyBEZXRlY3QgZXZlbnQgbGlzdGVuZXIgb3B0aW9ucyBzdXBwb3J0LiBJZiB0aGUgYGNhcHR1cmVgIHByb3BlcnR5IGlzIHJlYWRcbi8vIGZyb20gdGhlIG9wdGlvbnMgb2JqZWN0LCB0aGVuIG9wdGlvbnMgYXJlIHN1cHBvcnRlZC4gSWYgbm90LCB0aGVuIHRoZSB0aHJpZFxuLy8gYXJndW1lbnQgdG8gYWRkL3JlbW92ZUV2ZW50TGlzdGVuZXIgaXMgaW50ZXJwcmV0ZWQgYXMgdGhlIGJvb2xlYW4gY2FwdHVyZVxuLy8gdmFsdWUgc28gd2Ugc2hvdWxkIG9ubHkgcGFzcyB0aGUgYGNhcHR1cmVgIHByb3BlcnR5LlxubGV0IGV2ZW50T3B0aW9uc1N1cHBvcnRlZCA9IGZhbHNlO1xudHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBnZXQgY2FwdHVyZSgpIHtcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xufVxuY2F0Y2ggKF9lKSB7XG59XG5leHBvcnQgY2xhc3MgRXZlbnRQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBldmVudE5hbWUsIGV2ZW50Q29udGV4dCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgdGhpcy5ldmVudENvbnRleHQgPSBldmVudENvbnRleHQ7XG4gICAgICAgIHRoaXMuX19ib3VuZEhhbmRsZUV2ZW50ID0gKGUpID0+IHRoaXMuaGFuZGxlRXZlbnQoZSk7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICB3aGlsZSAoaXNEaXJlY3RpdmUodGhpcy5fX3BlbmRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gbm9DaGFuZ2U7XG4gICAgICAgICAgICBkaXJlY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX19wZW5kaW5nVmFsdWUgPT09IG5vQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3TGlzdGVuZXIgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICBjb25zdCBvbGRMaXN0ZW5lciA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlbW92ZUxpc3RlbmVyID0gbmV3TGlzdGVuZXIgPT0gbnVsbCB8fFxuICAgICAgICAgICAgb2xkTGlzdGVuZXIgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIChuZXdMaXN0ZW5lci5jYXB0dXJlICE9PSBvbGRMaXN0ZW5lci5jYXB0dXJlIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ld0xpc3RlbmVyLm9uY2UgIT09IG9sZExpc3RlbmVyLm9uY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3TGlzdGVuZXIucGFzc2l2ZSAhPT0gb2xkTGlzdGVuZXIucGFzc2l2ZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZEFkZExpc3RlbmVyID0gbmV3TGlzdGVuZXIgIT0gbnVsbCAmJiAob2xkTGlzdGVuZXIgPT0gbnVsbCB8fCBzaG91bGRSZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMuX19ib3VuZEhhbmRsZUV2ZW50LCB0aGlzLl9fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZEFkZExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9fb3B0aW9ucyA9IGdldE9wdGlvbnMobmV3TGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMuX19ib3VuZEhhbmRsZUV2ZW50LCB0aGlzLl9fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ld0xpc3RlbmVyO1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gbm9DaGFuZ2U7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5jYWxsKHRoaXMuZXZlbnRDb250ZXh0IHx8IHRoaXMuZWxlbWVudCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBXZSBjb3B5IG9wdGlvbnMgYmVjYXVzZSBvZiB0aGUgaW5jb25zaXN0ZW50IGJlaGF2aW9yIG9mIGJyb3dzZXJzIHdoZW4gcmVhZGluZ1xuLy8gdGhlIHRoaXJkIGFyZ3VtZW50IG9mIGFkZC9yZW1vdmVFdmVudExpc3RlbmVyLiBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBvcHRpb25zXG4vLyBhdCBhbGwuIENocm9tZSA0MSBvbmx5IHJlYWRzIGBjYXB0dXJlYCBpZiB0aGUgYXJndW1lbnQgaXMgYW4gb2JqZWN0LlxuY29uc3QgZ2V0T3B0aW9ucyA9IChvKSA9PiBvICYmXG4gICAgKGV2ZW50T3B0aW9uc1N1cHBvcnRlZCA/XG4gICAgICAgIHsgY2FwdHVyZTogby5jYXB0dXJlLCBwYXNzaXZlOiBvLnBhc3NpdmUsIG9uY2U6IG8ub25jZSB9IDpcbiAgICAgICAgby5jYXB0dXJlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRzLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IEF0dHJpYnV0ZUNvbW1pdHRlciwgQm9vbGVhbkF0dHJpYnV0ZVBhcnQsIEV2ZW50UGFydCwgTm9kZVBhcnQsIFByb3BlcnR5Q29tbWl0dGVyIH0gZnJvbSAnLi9wYXJ0cy5qcyc7XG4vKipcbiAqIENyZWF0ZXMgUGFydHMgd2hlbiBhIHRlbXBsYXRlIGlzIGluc3RhbnRpYXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhcnRzIGZvciBhbiBhdHRyaWJ1dGUtcG9zaXRpb24gYmluZGluZywgZ2l2ZW4gdGhlIGV2ZW50LCBhdHRyaWJ1dGVcbiAgICAgKiBuYW1lLCBhbmQgc3RyaW5nIGxpdGVyYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgYmluZGluZ1xuICAgICAqIEBwYXJhbSBuYW1lICBUaGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0gc3RyaW5ncyBUaGUgc3RyaW5nIGxpdGVyYWxzLiBUaGVyZSBhcmUgYWx3YXlzIGF0IGxlYXN0IHR3byBzdHJpbmdzLFxuICAgICAqICAgZXZlbnQgZm9yIGZ1bGx5LWNvbnRyb2xsZWQgYmluZGluZ3Mgd2l0aCBhIHNpbmdsZSBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIGhhbmRsZUF0dHJpYnV0ZUV4cHJlc3Npb25zKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmFtZVswXTtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBjb21taXR0ZXIgPSBuZXcgUHJvcGVydHlDb21taXR0ZXIoZWxlbWVudCwgbmFtZS5zbGljZSgxKSwgc3RyaW5ncyk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWl0dGVyLnBhcnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXggPT09ICdAJykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgRXZlbnRQYXJ0KGVsZW1lbnQsIG5hbWUuc2xpY2UoMSksIG9wdGlvbnMuZXZlbnRDb250ZXh0KV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJz8nKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBCb29sZWFuQXR0cmlidXRlUGFydChlbGVtZW50LCBuYW1lLnNsaWNlKDEpLCBzdHJpbmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tbWl0dGVyID0gbmV3IEF0dHJpYnV0ZUNvbW1pdHRlcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgcmV0dXJuIGNvbW1pdHRlci5wYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhcnRzIGZvciBhIHRleHQtcG9zaXRpb24gYmluZGluZy5cbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVGYWN0b3J5XG4gICAgICovXG4gICAgaGFuZGxlVGV4dEV4cHJlc3Npb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVQYXJ0KG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IgPSBuZXcgRGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgeyBtYXJrZXIsIFRlbXBsYXRlIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRlbXBsYXRlRmFjdG9yeSB3aGljaCBjYWNoZXMgVGVtcGxhdGVzIGtleWVkIG9uXG4gKiByZXN1bHQudHlwZSBhbmQgcmVzdWx0LnN0cmluZ3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUZhY3RvcnkocmVzdWx0KSB7XG4gICAgbGV0IHRlbXBsYXRlQ2FjaGUgPSB0ZW1wbGF0ZUNhY2hlcy5nZXQocmVzdWx0LnR5cGUpO1xuICAgIGlmICh0ZW1wbGF0ZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGVtcGxhdGVDYWNoZSA9IHtcbiAgICAgICAgICAgIHN0cmluZ3NBcnJheTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICAgIGtleVN0cmluZzogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHRlbXBsYXRlQ2FjaGVzLnNldChyZXN1bHQudHlwZSwgdGVtcGxhdGVDYWNoZSk7XG4gICAgfVxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ2FjaGUuc3RyaW5nc0FycmF5LmdldChyZXN1bHQuc3RyaW5ncyk7XG4gICAgaWYgKHRlbXBsYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgVGVtcGxhdGVTdHJpbmdzQXJyYXkgaXMgbmV3LCBnZW5lcmF0ZSBhIGtleSBmcm9tIHRoZSBzdHJpbmdzXG4gICAgLy8gVGhpcyBrZXkgaXMgc2hhcmVkIGJldHdlZW4gYWxsIHRlbXBsYXRlcyB3aXRoIGlkZW50aWNhbCBjb250ZW50XG4gICAgY29uc3Qga2V5ID0gcmVzdWx0LnN0cmluZ3Muam9pbihtYXJrZXIpO1xuICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIFRlbXBsYXRlIGZvciB0aGlzIGtleVxuICAgIHRlbXBsYXRlID0gdGVtcGxhdGVDYWNoZS5rZXlTdHJpbmcuZ2V0KGtleSk7XG4gICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBub3Qgc2VlbiB0aGlzIGtleSBiZWZvcmUsIGNyZWF0ZSBhIG5ldyBUZW1wbGF0ZVxuICAgICAgICB0ZW1wbGF0ZSA9IG5ldyBUZW1wbGF0ZShyZXN1bHQsIHJlc3VsdC5nZXRUZW1wbGF0ZUVsZW1lbnQoKSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBUZW1wbGF0ZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgdGVtcGxhdGVDYWNoZS5rZXlTdHJpbmcuc2V0KGtleSwgdGVtcGxhdGUpO1xuICAgIH1cbiAgICAvLyBDYWNoZSBhbGwgZnV0dXJlIHF1ZXJpZXMgZm9yIHRoaXMgVGVtcGxhdGVTdHJpbmdzQXJyYXlcbiAgICB0ZW1wbGF0ZUNhY2hlLnN0cmluZ3NBcnJheS5zZXQocmVzdWx0LnN0cmluZ3MsIHRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG59XG5leHBvcnQgY29uc3QgdGVtcGxhdGVDYWNoZXMgPSBuZXcgTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1mYWN0b3J5LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyByZW1vdmVOb2RlcyB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IE5vZGVQYXJ0IH0gZnJvbSAnLi9wYXJ0cy5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0ZUZhY3RvcnkgfSBmcm9tICcuL3RlbXBsYXRlLWZhY3RvcnkuanMnO1xuZXhwb3J0IGNvbnN0IHBhcnRzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogUmVuZGVycyBhIHRlbXBsYXRlIHJlc3VsdCBvciBvdGhlciB2YWx1ZSB0byBhIGNvbnRhaW5lci5cbiAqXG4gKiBUbyB1cGRhdGUgYSBjb250YWluZXIgd2l0aCBuZXcgdmFsdWVzLCByZWV2YWx1YXRlIHRoZSB0ZW1wbGF0ZSBsaXRlcmFsIGFuZFxuICogY2FsbCBgcmVuZGVyYCB3aXRoIHRoZSBuZXcgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSByZXN1bHQgQW55IHZhbHVlIHJlbmRlcmFibGUgYnkgTm9kZVBhcnQgLSB0eXBpY2FsbHkgYSBUZW1wbGF0ZVJlc3VsdFxuICogICAgIGNyZWF0ZWQgYnkgZXZhbHVhdGluZyBhIHRlbXBsYXRlIHRhZyBsaWtlIGBodG1sYCBvciBgc3ZnYC5cbiAqIEBwYXJhbSBjb250YWluZXIgQSBET00gcGFyZW50IHRvIHJlbmRlciB0by4gVGhlIGVudGlyZSBjb250ZW50cyBhcmUgZWl0aGVyXG4gKiAgICAgcmVwbGFjZWQsIG9yIGVmZmljaWVudGx5IHVwZGF0ZWQgaWYgdGhlIHNhbWUgcmVzdWx0IHR5cGUgd2FzIHByZXZpb3VzXG4gKiAgICAgcmVuZGVyZWQgdGhlcmUuXG4gKiBAcGFyYW0gb3B0aW9ucyBSZW5kZXJPcHRpb25zIGZvciB0aGUgZW50aXJlIHJlbmRlciB0cmVlIHJlbmRlcmVkIHRvIHRoaXNcbiAqICAgICBjb250YWluZXIuIFJlbmRlciBvcHRpb25zIG11c3QgKm5vdCogY2hhbmdlIGJldHdlZW4gcmVuZGVycyB0byB0aGUgc2FtZVxuICogICAgIGNvbnRhaW5lciwgYXMgdGhvc2UgY2hhbmdlcyB3aWxsIG5vdCBlZmZlY3QgcHJldmlvdXNseSByZW5kZXJlZCBET00uXG4gKi9cbmV4cG9ydCBjb25zdCByZW5kZXIgPSAocmVzdWx0LCBjb250YWluZXIsIG9wdGlvbnMpID0+IHtcbiAgICBsZXQgcGFydCA9IHBhcnRzLmdldChjb250YWluZXIpO1xuICAgIGlmIChwYXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVtb3ZlTm9kZXMoY29udGFpbmVyLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIHBhcnRzLnNldChjb250YWluZXIsIHBhcnQgPSBuZXcgTm9kZVBhcnQoT2JqZWN0LmFzc2lnbih7IHRlbXBsYXRlRmFjdG9yeSB9LCBvcHRpb25zKSkpO1xuICAgICAgICBwYXJ0LmFwcGVuZEludG8oY29udGFpbmVyKTtcbiAgICB9XG4gICAgcGFydC5zZXRWYWx1ZShyZXN1bHQpO1xuICAgIHBhcnQuY29tbWl0KCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICpcbiAqIE1haW4gbGl0LWh0bWwgbW9kdWxlLlxuICpcbiAqIE1haW4gZXhwb3J0czpcbiAqXG4gKiAtICBbW2h0bWxdXVxuICogLSAgW1tzdmddXVxuICogLSAgW1tyZW5kZXJdXVxuICpcbiAqIEBtb2R1bGUgbGl0LWh0bWxcbiAqIEBwcmVmZXJyZWRcbiAqL1xuLyoqXG4gKiBEbyBub3QgcmVtb3ZlIHRoaXMgY29tbWVudDsgaXQga2VlcHMgdHlwZWRvYyBmcm9tIG1pc3BsYWNpbmcgdGhlIG1vZHVsZVxuICogZG9jcy5cbiAqL1xuaW1wb3J0IHsgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yIH0gZnJvbSAnLi9saWIvZGVmYXVsdC10ZW1wbGF0ZS1wcm9jZXNzb3IuanMnO1xuaW1wb3J0IHsgU1ZHVGVtcGxhdGVSZXN1bHQsIFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnLi9saWIvdGVtcGxhdGUtcmVzdWx0LmpzJztcbmV4cG9ydCB7IERlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciwgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yIH0gZnJvbSAnLi9saWIvZGVmYXVsdC10ZW1wbGF0ZS1wcm9jZXNzb3IuanMnO1xuZXhwb3J0IHsgZGlyZWN0aXZlLCBpc0RpcmVjdGl2ZSB9IGZyb20gJy4vbGliL2RpcmVjdGl2ZS5qcyc7XG4vLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiByZW1vdmUgbGluZSB3aGVuIHdlIGdldCBOb2RlUGFydCBtb3ZpbmcgbWV0aG9kc1xuZXhwb3J0IHsgcmVtb3ZlTm9kZXMsIHJlcGFyZW50Tm9kZXMgfSBmcm9tICcuL2xpYi9kb20uanMnO1xuZXhwb3J0IHsgbm9DaGFuZ2UsIG5vdGhpbmcgfSBmcm9tICcuL2xpYi9wYXJ0LmpzJztcbmV4cG9ydCB7IEF0dHJpYnV0ZUNvbW1pdHRlciwgQXR0cmlidXRlUGFydCwgQm9vbGVhbkF0dHJpYnV0ZVBhcnQsIEV2ZW50UGFydCwgaXNJdGVyYWJsZSwgaXNQcmltaXRpdmUsIE5vZGVQYXJ0LCBQcm9wZXJ0eUNvbW1pdHRlciwgUHJvcGVydHlQYXJ0IH0gZnJvbSAnLi9saWIvcGFydHMuanMnO1xuZXhwb3J0IHsgcGFydHMsIHJlbmRlciB9IGZyb20gJy4vbGliL3JlbmRlci5qcyc7XG5leHBvcnQgeyB0ZW1wbGF0ZUNhY2hlcywgdGVtcGxhdGVGYWN0b3J5IH0gZnJvbSAnLi9saWIvdGVtcGxhdGUtZmFjdG9yeS5qcyc7XG5leHBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlIH0gZnJvbSAnLi9saWIvdGVtcGxhdGUtaW5zdGFuY2UuanMnO1xuZXhwb3J0IHsgU1ZHVGVtcGxhdGVSZXN1bHQsIFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnLi9saWIvdGVtcGxhdGUtcmVzdWx0LmpzJztcbmV4cG9ydCB7IGNyZWF0ZU1hcmtlciwgaXNUZW1wbGF0ZVBhcnRBY3RpdmUsIFRlbXBsYXRlIH0gZnJvbSAnLi9saWIvdGVtcGxhdGUuanMnO1xuLy8gSU1QT1JUQU5UOiBkbyBub3QgY2hhbmdlIHRoZSBwcm9wZXJ0eSBuYW1lIG9yIHRoZSBhc3NpZ25tZW50IGV4cHJlc3Npb24uXG4vLyBUaGlzIGxpbmUgd2lsbCBiZSB1c2VkIGluIHJlZ2V4ZXMgdG8gc2VhcmNoIGZvciBsaXQtaHRtbCB1c2FnZS5cbi8vIFRPRE8oanVzdGluZmFnbmFuaSk6IGluamVjdCB2ZXJzaW9uIG51bWJlciBhdCBidWlsZCB0aW1lXG4od2luZG93WydsaXRIdG1sVmVyc2lvbnMnXSB8fCAod2luZG93WydsaXRIdG1sVmVyc2lvbnMnXSA9IFtdKSkucHVzaCgnMS4xLjInKTtcbi8qKlxuICogSW50ZXJwcmV0cyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYW4gSFRNTCB0ZW1wbGF0ZSB0aGF0IGNhbiBlZmZpY2llbnRseVxuICogcmVuZGVyIHRvIGFuZCB1cGRhdGUgYSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBodG1sID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4gbmV3IFRlbXBsYXRlUmVzdWx0KHN0cmluZ3MsIHZhbHVlcywgJ2h0bWwnLCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IpO1xuLyoqXG4gKiBJbnRlcnByZXRzIGEgdGVtcGxhdGUgbGl0ZXJhbCBhcyBhbiBTVkcgdGVtcGxhdGUgdGhhdCBjYW4gZWZmaWNpZW50bHlcbiAqIHJlbmRlciB0byBhbmQgdXBkYXRlIGEgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3Qgc3ZnID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4gbmV3IFNWR1RlbXBsYXRlUmVzdWx0KHN0cmluZ3MsIHZhbHVlcywgJ3N2ZycsIGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3Nvcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXQtaHRtbC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIEBtb2R1bGUgc2hhZHktcmVuZGVyXG4gKi9cbmltcG9ydCB7IGlzVGVtcGxhdGVQYXJ0QWN0aXZlIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG5jb25zdCB3YWxrZXJOb2RlRmlsdGVyID0gMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV197RUxFTUVOVHxDT01NRU5UfFRFWFR9ICovO1xuLyoqXG4gKiBSZW1vdmVzIHRoZSBsaXN0IG9mIG5vZGVzIGZyb20gYSBUZW1wbGF0ZSBzYWZlbHkuIEluIGFkZGl0aW9uIHRvIHJlbW92aW5nXG4gKiBub2RlcyBmcm9tIHRoZSBUZW1wbGF0ZSwgdGhlIFRlbXBsYXRlIHBhcnQgaW5kaWNlcyBhcmUgdXBkYXRlZCB0byBtYXRjaFxuICogdGhlIG11dGF0ZWQgVGVtcGxhdGUgRE9NLlxuICpcbiAqIEFzIHRoZSB0ZW1wbGF0ZSBpcyB3YWxrZWQgdGhlIHJlbW92YWwgc3RhdGUgaXMgdHJhY2tlZCBhbmRcbiAqIHBhcnQgaW5kaWNlcyBhcmUgYWRqdXN0ZWQgYXMgbmVlZGVkLlxuICpcbiAqIGRpdlxuICogICBkaXYjMSAocmVtb3ZlKSA8LS0gc3RhcnQgcmVtb3ZpbmcgKHJlbW92aW5nIG5vZGUgaXMgZGl2IzEpXG4gKiAgICAgZGl2XG4gKiAgICAgICBkaXYjMiAocmVtb3ZlKSAgPC0tIGNvbnRpbnVlIHJlbW92aW5nIChyZW1vdmluZyBub2RlIGlzIHN0aWxsIGRpdiMxKVxuICogICAgICAgICBkaXZcbiAqIGRpdiA8LS0gc3RvcCByZW1vdmluZyBzaW5jZSBwcmV2aW91cyBzaWJsaW5nIGlzIHRoZSByZW1vdmluZyBub2RlIChkaXYjMSxcbiAqIHJlbW92ZWQgNCBub2RlcylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGVzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBub2Rlc1RvUmVtb3ZlKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiB7IGNvbnRlbnQgfSwgcGFydHMgfSA9IHRlbXBsYXRlO1xuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoY29udGVudCwgd2Fsa2VyTm9kZUZpbHRlciwgbnVsbCwgZmFsc2UpO1xuICAgIGxldCBwYXJ0SW5kZXggPSBuZXh0QWN0aXZlSW5kZXhJblRlbXBsYXRlUGFydHMocGFydHMpO1xuICAgIGxldCBwYXJ0ID0gcGFydHNbcGFydEluZGV4XTtcbiAgICBsZXQgbm9kZUluZGV4ID0gLTE7XG4gICAgbGV0IHJlbW92ZUNvdW50ID0gMDtcbiAgICBjb25zdCBub2Rlc1RvUmVtb3ZlSW5UZW1wbGF0ZSA9IFtdO1xuICAgIGxldCBjdXJyZW50UmVtb3ZpbmdOb2RlID0gbnVsbDtcbiAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgbm9kZUluZGV4Kys7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB3YWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgIC8vIEVuZCByZW1vdmFsIGlmIHN0ZXBwZWQgcGFzdCB0aGUgcmVtb3Zpbmcgbm9kZVxuICAgICAgICBpZiAobm9kZS5wcmV2aW91c1NpYmxpbmcgPT09IGN1cnJlbnRSZW1vdmluZ05vZGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZW1vdmluZ05vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgbm9kZSB0byByZW1vdmUgd2FzIGZvdW5kIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICBpZiAobm9kZXNUb1JlbW92ZS5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgIG5vZGVzVG9SZW1vdmVJblRlbXBsYXRlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAvLyBUcmFjayBub2RlIHdlJ3JlIHJlbW92aW5nXG4gICAgICAgICAgICBpZiAoY3VycmVudFJlbW92aW5nTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZW1vdmluZ05vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gcmVtb3ZpbmcsIGluY3JlbWVudCBjb3VudCBieSB3aGljaCB0byBhZGp1c3Qgc3Vic2VxdWVudCBwYXJ0IGluZGljZXNcbiAgICAgICAgaWYgKGN1cnJlbnRSZW1vdmluZ05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBhcnQgIT09IHVuZGVmaW5lZCAmJiBwYXJ0LmluZGV4ID09PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIElmIHBhcnQgaXMgaW4gYSByZW1vdmVkIG5vZGUgZGVhY3RpdmF0ZSBpdCBieSBzZXR0aW5nIGluZGV4IHRvIC0xIG9yXG4gICAgICAgICAgICAvLyBhZGp1c3QgdGhlIGluZGV4IGFzIG5lZWRlZC5cbiAgICAgICAgICAgIHBhcnQuaW5kZXggPSBjdXJyZW50UmVtb3ZpbmdOb2RlICE9PSBudWxsID8gLTEgOiBwYXJ0LmluZGV4IC0gcmVtb3ZlQ291bnQ7XG4gICAgICAgICAgICAvLyBnbyB0byB0aGUgbmV4dCBhY3RpdmUgcGFydC5cbiAgICAgICAgICAgIHBhcnRJbmRleCA9IG5leHRBY3RpdmVJbmRleEluVGVtcGxhdGVQYXJ0cyhwYXJ0cywgcGFydEluZGV4KTtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGVzVG9SZW1vdmVJblRlbXBsYXRlLmZvckVhY2goKG4pID0+IG4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKSk7XG59XG5jb25zdCBjb3VudE5vZGVzID0gKG5vZGUpID0+IHtcbiAgICBsZXQgY291bnQgPSAobm9kZS5ub2RlVHlwZSA9PT0gMTEgLyogTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICovKSA/IDAgOiAxO1xuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIobm9kZSwgd2Fsa2VyTm9kZUZpbHRlciwgbnVsbCwgZmFsc2UpO1xuICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59O1xuY29uc3QgbmV4dEFjdGl2ZUluZGV4SW5UZW1wbGF0ZVBhcnRzID0gKHBhcnRzLCBzdGFydEluZGV4ID0gLTEpID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChpc1RlbXBsYXRlUGFydEFjdGl2ZShwYXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogSW5zZXJ0cyB0aGUgZ2l2ZW4gbm9kZSBpbnRvIHRoZSBUZW1wbGF0ZSwgb3B0aW9uYWxseSBiZWZvcmUgdGhlIGdpdmVuXG4gKiByZWZOb2RlLiBJbiBhZGRpdGlvbiB0byBpbnNlcnRpbmcgdGhlIG5vZGUgaW50byB0aGUgVGVtcGxhdGUsIHRoZSBUZW1wbGF0ZVxuICogcGFydCBpbmRpY2VzIGFyZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBtdXRhdGVkIFRlbXBsYXRlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydE5vZGVJbnRvVGVtcGxhdGUodGVtcGxhdGUsIG5vZGUsIHJlZk5vZGUgPSBudWxsKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiB7IGNvbnRlbnQgfSwgcGFydHMgfSA9IHRlbXBsYXRlO1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVmTm9kZSwgdGhlbiBwdXQgbm9kZSBhdCBlbmQgb2YgdGVtcGxhdGUuXG4gICAgLy8gTm8gcGFydCBpbmRpY2VzIG5lZWQgdG8gYmUgc2hpZnRlZCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHJlZk5vZGUgPT09IG51bGwgfHwgcmVmTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihjb250ZW50LCB3YWxrZXJOb2RlRmlsdGVyLCBudWxsLCBmYWxzZSk7XG4gICAgbGV0IHBhcnRJbmRleCA9IG5leHRBY3RpdmVJbmRleEluVGVtcGxhdGVQYXJ0cyhwYXJ0cyk7XG4gICAgbGV0IGluc2VydENvdW50ID0gMDtcbiAgICBsZXQgd2Fsa2VySW5kZXggPSAtMTtcbiAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgd2Fsa2VySW5kZXgrKztcbiAgICAgICAgY29uc3Qgd2Fsa2VyTm9kZSA9IHdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKHdhbGtlck5vZGUgPT09IHJlZk5vZGUpIHtcbiAgICAgICAgICAgIGluc2VydENvdW50ID0gY291bnROb2Rlcyhub2RlKTtcbiAgICAgICAgICAgIHJlZk5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBhcnRJbmRleCAhPT0gLTEgJiYgcGFydHNbcGFydEluZGV4XS5pbmRleCA9PT0gd2Fsa2VySW5kZXgpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGluc2VydGVkIHRoZSBub2RlLCBzaW1wbHkgYWRqdXN0IGFsbCBzdWJzZXF1ZW50IHBhcnRzXG4gICAgICAgICAgICBpZiAoaW5zZXJ0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHNbcGFydEluZGV4XS5pbmRleCArPSBpbnNlcnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4ID0gbmV4dEFjdGl2ZUluZGV4SW5UZW1wbGF0ZVBhcnRzKHBhcnRzLCBwYXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0SW5kZXggPSBuZXh0QWN0aXZlSW5kZXhJblRlbXBsYXRlUGFydHMocGFydHMsIHBhcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RpZnktdGVtcGxhdGUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBNb2R1bGUgdG8gYWRkIHNoYWR5IERPTS9zaGFkeSBDU1MgcG9seWZpbGwgc3VwcG9ydCB0byBsaXQtaHRtbCB0ZW1wbGF0ZVxuICogcmVuZGVyaW5nLiBTZWUgdGhlIFtbcmVuZGVyXV0gbWV0aG9kIGZvciBkZXRhaWxzLlxuICpcbiAqIEBtb2R1bGUgc2hhZHktcmVuZGVyXG4gKiBAcHJlZmVycmVkXG4gKi9cbi8qKlxuICogRG8gbm90IHJlbW92ZSB0aGlzIGNvbW1lbnQ7IGl0IGtlZXBzIHR5cGVkb2MgZnJvbSBtaXNwbGFjaW5nIHRoZSBtb2R1bGVcbiAqIGRvY3MuXG4gKi9cbmltcG9ydCB7IHJlbW92ZU5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgaW5zZXJ0Tm9kZUludG9UZW1wbGF0ZSwgcmVtb3ZlTm9kZXNGcm9tVGVtcGxhdGUgfSBmcm9tICcuL21vZGlmeS10ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgeyBwYXJ0cywgcmVuZGVyIGFzIGxpdFJlbmRlciB9IGZyb20gJy4vcmVuZGVyLmpzJztcbmltcG9ydCB7IHRlbXBsYXRlQ2FjaGVzIH0gZnJvbSAnLi90ZW1wbGF0ZS1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbXBsYXRlSW5zdGFuY2UgfSBmcm9tICcuL3RlbXBsYXRlLWluc3RhbmNlLmpzJztcbmltcG9ydCB7IG1hcmtlciwgVGVtcGxhdGUgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbmV4cG9ydCB7IGh0bWwsIHN2ZywgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICcuLi9saXQtaHRtbC5qcyc7XG4vLyBHZXQgYSBrZXkgdG8gbG9va3VwIGluIGB0ZW1wbGF0ZUNhY2hlc2AuXG5jb25zdCBnZXRUZW1wbGF0ZUNhY2hlS2V5ID0gKHR5cGUsIHNjb3BlTmFtZSkgPT4gYCR7dHlwZX0tLSR7c2NvcGVOYW1lfWA7XG5sZXQgY29tcGF0aWJsZVNoYWR5Q1NTVmVyc2lvbiA9IHRydWU7XG5pZiAodHlwZW9mIHdpbmRvdy5TaGFkeUNTUyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb21wYXRpYmxlU2hhZHlDU1NWZXJzaW9uID0gZmFsc2U7XG59XG5lbHNlIGlmICh0eXBlb2Ygd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZURvbSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oYEluY29tcGF0aWJsZSBTaGFkeUNTUyB2ZXJzaW9uIGRldGVjdGVkLiBgICtcbiAgICAgICAgYFBsZWFzZSB1cGRhdGUgdG8gYXQgbGVhc3QgQHdlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzQDIuMC4yIGFuZCBgICtcbiAgICAgICAgYEB3ZWJjb21wb25lbnRzL3NoYWR5Y3NzQDEuMy4xLmApO1xuICAgIGNvbXBhdGlibGVTaGFkeUNTU1ZlcnNpb24gPSBmYWxzZTtcbn1cbi8qKlxuICogVGVtcGxhdGUgZmFjdG9yeSB3aGljaCBzY29wZXMgdGVtcGxhdGUgRE9NIHVzaW5nIFNoYWR5Q1NTLlxuICogQHBhcmFtIHNjb3BlTmFtZSB7c3RyaW5nfVxuICovXG5jb25zdCBzaGFkeVRlbXBsYXRlRmFjdG9yeSA9IChzY29wZU5hbWUpID0+IChyZXN1bHQpID0+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldFRlbXBsYXRlQ2FjaGVLZXkocmVzdWx0LnR5cGUsIHNjb3BlTmFtZSk7XG4gICAgbGV0IHRlbXBsYXRlQ2FjaGUgPSB0ZW1wbGF0ZUNhY2hlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICh0ZW1wbGF0ZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGVtcGxhdGVDYWNoZSA9IHtcbiAgICAgICAgICAgIHN0cmluZ3NBcnJheTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICAgIGtleVN0cmluZzogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHRlbXBsYXRlQ2FjaGVzLnNldChjYWNoZUtleSwgdGVtcGxhdGVDYWNoZSk7XG4gICAgfVxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ2FjaGUuc3RyaW5nc0FycmF5LmdldChyZXN1bHQuc3RyaW5ncyk7XG4gICAgaWYgKHRlbXBsYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSByZXN1bHQuc3RyaW5ncy5qb2luKG1hcmtlcik7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNhY2hlLmtleVN0cmluZy5nZXQoa2V5KTtcbiAgICBpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVzdWx0LmdldFRlbXBsYXRlRWxlbWVudCgpO1xuICAgICAgICBpZiAoY29tcGF0aWJsZVNoYWR5Q1NTVmVyc2lvbikge1xuICAgICAgICAgICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZURvbShlbGVtZW50LCBzY29wZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlID0gbmV3IFRlbXBsYXRlKHJlc3VsdCwgZWxlbWVudCk7XG4gICAgICAgIHRlbXBsYXRlQ2FjaGUua2V5U3RyaW5nLnNldChrZXksIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgdGVtcGxhdGVDYWNoZS5zdHJpbmdzQXJyYXkuc2V0KHJlc3VsdC5zdHJpbmdzLCB0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufTtcbmNvbnN0IFRFTVBMQVRFX1RZUEVTID0gWydodG1sJywgJ3N2ZyddO1xuLyoqXG4gKiBSZW1vdmVzIGFsbCBzdHlsZSBlbGVtZW50cyBmcm9tIFRlbXBsYXRlcyBmb3IgdGhlIGdpdmVuIHNjb3BlTmFtZS5cbiAqL1xuY29uc3QgcmVtb3ZlU3R5bGVzRnJvbUxpdFRlbXBsYXRlcyA9IChzY29wZU5hbWUpID0+IHtcbiAgICBURU1QTEFURV9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IHRlbXBsYXRlQ2FjaGVzLmdldChnZXRUZW1wbGF0ZUNhY2hlS2V5KHR5cGUsIHNjb3BlTmFtZSkpO1xuICAgICAgICBpZiAodGVtcGxhdGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlcy5rZXlTdHJpbmcuZm9yRWFjaCgodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IHsgY29udGVudCB9IH0gPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAvLyBJRSAxMSBkb2Vzbid0IHN1cHBvcnQgdGhlIGl0ZXJhYmxlIHBhcmFtIFNldCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMuYWRkKHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBzdHlsZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCBzaGFkeVJlbmRlclNldCA9IG5ldyBTZXQoKTtcbi8qKlxuICogRm9yIHRoZSBnaXZlbiBzY29wZSBuYW1lLCBlbnN1cmVzIHRoYXQgU2hhZHlDU1Mgc3R5bGUgc2NvcGluZyBpcyBwZXJmb3JtZWQuXG4gKiBUaGlzIGlzIGRvbmUganVzdCBvbmNlIHBlciBzY29wZSBuYW1lIHNvIHRoZSBmcmFnbWVudCBhbmQgdGVtcGxhdGUgY2Fubm90XG4gKiBiZSBtb2RpZmllZC5cbiAqICgxKSBleHRyYWN0cyBzdHlsZXMgZnJvbSB0aGUgcmVuZGVyZWQgZnJhZ21lbnQgYW5kIGhhbmRzIHRoZW0gdG8gU2hhZHlDU1NcbiAqIHRvIGJlIHNjb3BlZCBhbmQgYXBwZW5kZWQgdG8gdGhlIGRvY3VtZW50XG4gKiAoMikgcmVtb3ZlcyBzdHlsZSBlbGVtZW50cyBmcm9tIGFsbCBsaXQtaHRtbCBUZW1wbGF0ZXMgZm9yIHRoaXMgc2NvcGUgbmFtZS5cbiAqXG4gKiBOb3RlLCA8c3R5bGU+IGVsZW1lbnRzIGNhbiBvbmx5IGJlIHBsYWNlZCBpbnRvIHRlbXBsYXRlcyBmb3IgdGhlXG4gKiBpbml0aWFsIHJlbmRlcmluZyBvZiB0aGUgc2NvcGUuIElmIDxzdHlsZT4gZWxlbWVudHMgYXJlIGluY2x1ZGVkIGluIHRlbXBsYXRlc1xuICogZHluYW1pY2FsbHkgcmVuZGVyZWQgdG8gdGhlIHNjb3BlIChhZnRlciB0aGUgZmlyc3Qgc2NvcGUgcmVuZGVyKSwgdGhleSB3aWxsXG4gKiBub3QgYmUgc2NvcGVkIGFuZCB0aGUgPHN0eWxlPiB3aWxsIGJlIGxlZnQgaW4gdGhlIHRlbXBsYXRlIGFuZCByZW5kZXJlZFxuICogb3V0cHV0LlxuICovXG5jb25zdCBwcmVwYXJlVGVtcGxhdGVTdHlsZXMgPSAoc2NvcGVOYW1lLCByZW5kZXJlZERPTSwgdGVtcGxhdGUpID0+IHtcbiAgICBzaGFkeVJlbmRlclNldC5hZGQoc2NvcGVOYW1lKTtcbiAgICAvLyBJZiBgcmVuZGVyZWRET01gIGlzIHN0YW1wZWQgZnJvbSBhIFRlbXBsYXRlLCB0aGVuIHdlIG5lZWQgdG8gZWRpdCB0aGF0XG4gICAgLy8gVGVtcGxhdGUncyB1bmRlcmx5aW5nIHRlbXBsYXRlIGVsZW1lbnQuIE90aGVyd2lzZSwgd2UgY3JlYXRlIG9uZSBoZXJlXG4gICAgLy8gdG8gZ2l2ZSB0byBTaGFkeUNTUywgd2hpY2ggc3RpbGwgcmVxdWlyZXMgb25lIHdoaWxlIHNjb3BpbmcuXG4gICAgY29uc3QgdGVtcGxhdGVFbGVtZW50ID0gISF0ZW1wbGF0ZSA/IHRlbXBsYXRlLmVsZW1lbnQgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIC8vIE1vdmUgc3R5bGVzIG91dCBvZiByZW5kZXJlZCBET00gYW5kIHN0b3JlLlxuICAgIGNvbnN0IHN0eWxlcyA9IHJlbmRlcmVkRE9NLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHN0eWxlcztcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc3R5bGVzLCBza2lwIHVubmVjZXNzYXJ5IHdvcmtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEVuc3VyZSBwcmVwYXJlVGVtcGxhdGVTdHlsZXMgaXMgY2FsbGVkIHRvIHN1cHBvcnQgYWRkaW5nXG4gICAgICAgIC8vIHN0eWxlcyB2aWEgYHByZXBhcmVBZG9wdGVkQ3NzVGV4dGAgc2luY2UgdGhhdCByZXF1aXJlcyB0aGF0XG4gICAgICAgIC8vIGBwcmVwYXJlVGVtcGxhdGVTdHlsZXNgIGlzIGNhbGxlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2hhZHlDU1Mgd2lsbCBvbmx5IHVwZGF0ZSBzdHlsZXMgY29udGFpbmluZyBAYXBwbHkgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgIC8vIGdpdmVuIHRvIGBwcmVwYXJlVGVtcGxhdGVTdHlsZXNgLiBJZiBubyBsaXQgVGVtcGxhdGUgd2FzIGdpdmVuLFxuICAgICAgICAvLyBTaGFkeUNTUyB3aWxsIG5vdCBiZSBhYmxlIHRvIHVwZGF0ZSB1c2VzIG9mIEBhcHBseSBpbiBhbnkgcmVsZXZhbnRcbiAgICAgICAgLy8gdGVtcGxhdGUuIEhvd2V2ZXIsIHRoaXMgaXMgbm90IGEgcHJvYmxlbSBiZWNhdXNlIHdlIG9ubHkgY3JlYXRlIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZSBmb3IgdGhlIHB1cnBvc2Ugb2Ygc3VwcG9ydGluZyBgcHJlcGFyZUFkb3B0ZWRDc3NUZXh0YCxcbiAgICAgICAgLy8gd2hpY2ggZG9lc24ndCBzdXBwb3J0IEBhcHBseSBhdCBhbGwuXG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVTdHlsZXModGVtcGxhdGVFbGVtZW50LCBzY29wZU5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmRlbnNlZFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAvLyBDb2xsZWN0IHN0eWxlcyBpbnRvIGEgc2luZ2xlIHN0eWxlLiBUaGlzIGhlbHBzIHVzIG1ha2Ugc3VyZSBTaGFkeUNTU1xuICAgIC8vIG1hbmlwdWxhdGlvbnMgd2lsbCBub3QgcHJldmVudCB1cyBmcm9tIGJlaW5nIGFibGUgdG8gZml4IHVwIHRlbXBsYXRlXG4gICAgLy8gcGFydCBpbmRpY2VzLlxuICAgIC8vIE5PVEU6IGNvbGxlY3Rpbmcgc3R5bGVzIGlzIGluZWZmaWNpZW50IGZvciBicm93c2VycyBidXQgU2hhZHlDU1NcbiAgICAvLyBjdXJyZW50bHkgZG9lcyB0aGlzIGFueXdheS4gV2hlbiBpdCBkb2VzIG5vdCwgdGhpcyBzaG91bGQgYmUgY2hhbmdlZC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzW2ldO1xuICAgICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgICAgY29uZGVuc2VkU3R5bGUudGV4dENvbnRlbnQgKz0gc3R5bGUudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzdHlsZXMgZnJvbSBuZXN0ZWQgdGVtcGxhdGVzIGluIHRoaXMgc2NvcGUuXG4gICAgcmVtb3ZlU3R5bGVzRnJvbUxpdFRlbXBsYXRlcyhzY29wZU5hbWUpO1xuICAgIC8vIEFuZCB0aGVuIHB1dCB0aGUgY29uZGVuc2VkIHN0eWxlIGludG8gdGhlIFwicm9vdFwiIHRlbXBsYXRlIHBhc3NlZCBpbiBhc1xuICAgIC8vIGB0ZW1wbGF0ZWAuXG4gICAgY29uc3QgY29udGVudCA9IHRlbXBsYXRlRWxlbWVudC5jb250ZW50O1xuICAgIGlmICghIXRlbXBsYXRlKSB7XG4gICAgICAgIGluc2VydE5vZGVJbnRvVGVtcGxhdGUodGVtcGxhdGUsIGNvbmRlbnNlZFN0eWxlLCBjb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUoY29uZGVuc2VkU3R5bGUsIGNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIC8vIE5vdGUsIGl0J3MgaW1wb3J0YW50IHRoYXQgU2hhZHlDU1MgZ2V0cyB0aGUgdGVtcGxhdGUgdGhhdCBgbGl0LWh0bWxgXG4gICAgLy8gd2lsbCBhY3R1YWxseSByZW5kZXIgc28gdGhhdCBpdCBjYW4gdXBkYXRlIHRoZSBzdHlsZSBpbnNpZGUgd2hlblxuICAgIC8vIG5lZWRlZCAoZS5nLiBAYXBwbHkgbmF0aXZlIFNoYWRvdyBET00gY2FzZSkuXG4gICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZVN0eWxlcyh0ZW1wbGF0ZUVsZW1lbnQsIHNjb3BlTmFtZSk7XG4gICAgY29uc3Qgc3R5bGUgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJyk7XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVTaGFkb3cgJiYgc3R5bGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2hlbiBpbiBuYXRpdmUgU2hhZG93IERPTSwgZW5zdXJlIHRoZSBzdHlsZSBjcmVhdGVkIGJ5IFNoYWR5Q1NTIGlzXG4gICAgICAgIC8vIGluY2x1ZGVkIGluIGluaXRpYWxseSByZW5kZXJlZCBvdXRwdXQgKGByZW5kZXJlZERPTWApLlxuICAgICAgICByZW5kZXJlZERPTS5pbnNlcnRCZWZvcmUoc3R5bGUuY2xvbmVOb2RlKHRydWUpLCByZW5kZXJlZERPTS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoISF0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBXaGVuIG5vIHN0eWxlIGlzIGxlZnQgaW4gdGhlIHRlbXBsYXRlLCBwYXJ0cyB3aWxsIGJlIGJyb2tlbiBhcyBhXG4gICAgICAgIC8vIHJlc3VsdC4gVG8gZml4IHRoaXMsIHdlIHB1dCBiYWNrIHRoZSBzdHlsZSBub2RlIFNoYWR5Q1NTIHJlbW92ZWRcbiAgICAgICAgLy8gYW5kIHRoZW4gdGVsbCBsaXQgdG8gcmVtb3ZlIHRoYXQgbm9kZSBmcm9tIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIG5vIHN0eWxlIGluIHRoZSB0ZW1wbGF0ZSBpbiAyIGNhc2VzICgxKSB3aGVuIFNoYWR5IERPTVxuICAgICAgICAvLyBpcyBpbiB1c2UsIFNoYWR5Q1NTIHJlbW92ZXMgYWxsIHN0eWxlcywgKDIpIHdoZW4gbmF0aXZlIFNoYWRvdyBET01cbiAgICAgICAgLy8gaXMgaW4gdXNlIFNoYWR5Q1NTIHJlbW92ZXMgdGhlIHN0eWxlIGlmIGl0IGNvbnRhaW5zIG5vIGNvbnRlbnQuXG4gICAgICAgIC8vIE5PVEUsIFNoYWR5Q1NTIGNyZWF0ZXMgaXRzIG93biBzdHlsZSBzbyB3ZSBjYW4gc2FmZWx5IGFkZC9yZW1vdmVcbiAgICAgICAgLy8gYGNvbmRlbnNlZFN0eWxlYCBoZXJlLlxuICAgICAgICBjb250ZW50Lmluc2VydEJlZm9yZShjb25kZW5zZWRTdHlsZSwgY29udGVudC5maXJzdENoaWxkKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmVtb3Zlcy5hZGQoY29uZGVuc2VkU3R5bGUpO1xuICAgICAgICByZW1vdmVOb2Rlc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgcmVtb3Zlcyk7XG4gICAgfVxufTtcbi8qKlxuICogRXh0ZW5zaW9uIHRvIHRoZSBzdGFuZGFyZCBgcmVuZGVyYCBtZXRob2Qgd2hpY2ggc3VwcG9ydHMgcmVuZGVyaW5nXG4gKiB0byBTaGFkb3dSb290cyB3aGVuIHRoZSBTaGFkeURPTSAoaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvc2hhZHlkb20pXG4gKiBhbmQgU2hhZHlDU1MgKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5Y3NzKSBwb2x5ZmlsbHMgYXJlIHVzZWRcbiAqIG9yIHdoZW4gdGhlIHdlYmNvbXBvbmVudHNqc1xuICogKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcykgcG9seWZpbGwgaXMgdXNlZC5cbiAqXG4gKiBBZGRzIGEgYHNjb3BlTmFtZWAgb3B0aW9uIHdoaWNoIGlzIHVzZWQgdG8gc2NvcGUgZWxlbWVudCBET00gYW5kIHN0eWxlc2hlZXRzXG4gKiB3aGVuIG5hdGl2ZSBTaGFkb3dET00gaXMgdW5hdmFpbGFibGUuIFRoZSBgc2NvcGVOYW1lYCB3aWxsIGJlIGFkZGVkIHRvXG4gKiB0aGUgY2xhc3MgYXR0cmlidXRlIG9mIGFsbCByZW5kZXJlZCBET00uIEluIGFkZGl0aW9uLCBhbnkgc3R5bGUgZWxlbWVudHMgd2lsbFxuICogYmUgYXV0b21hdGljYWxseSByZS13cml0dGVuIHdpdGggdGhpcyBgc2NvcGVOYW1lYCBzZWxlY3RvciBhbmQgbW92ZWQgb3V0XG4gKiBvZiB0aGUgcmVuZGVyZWQgRE9NIGFuZCBpbnRvIHRoZSBkb2N1bWVudCBgPGhlYWQ+YC5cbiAqXG4gKiBJdCBpcyBjb21tb24gdG8gdXNlIHRoaXMgcmVuZGVyIG1ldGhvZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgY3VzdG9tIGVsZW1lbnRcbiAqIHdoaWNoIHJlbmRlcnMgYSBzaGFkb3dSb290LiBXaGVuIHRoaXMgaXMgZG9uZSwgdHlwaWNhbGx5IHRoZSBlbGVtZW50J3NcbiAqIGBsb2NhbE5hbWVgIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBgc2NvcGVOYW1lYC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBET00gc2NvcGluZywgU2hhZHlDU1MgYWxzbyBzdXBwb3J0cyBhIGJhc2ljIHNoaW0gZm9yIGNzc1xuICogY3VzdG9tIHByb3BlcnRpZXMgKG5lZWRlZCBvbmx5IG9uIG9sZGVyIGJyb3dzZXJzIGxpa2UgSUUxMSkgYW5kIGEgc2hpbSBmb3JcbiAqIGEgZGVwcmVjYXRlZCBmZWF0dXJlIGNhbGxlZCBgQGFwcGx5YCB0aGF0IHN1cHBvcnRzIGFwcGx5aW5nIGEgc2V0IG9mIGNzc1xuICogY3VzdG9tIHByb3BlcnRpZXMgdG8gYSBnaXZlbiBsb2NhdGlvbi5cbiAqXG4gKiBVc2FnZSBjb25zaWRlcmF0aW9uczpcbiAqXG4gKiAqIFBhcnQgdmFsdWVzIGluIGA8c3R5bGU+YCBlbGVtZW50cyBhcmUgb25seSBhcHBsaWVkIHRoZSBmaXJzdCB0aW1lIGEgZ2l2ZW5cbiAqIGBzY29wZU5hbWVgIHJlbmRlcnMuIFN1YnNlcXVlbnQgY2hhbmdlcyB0byBwYXJ0cyBpbiBzdHlsZSBlbGVtZW50cyB3aWxsIGhhdmVcbiAqIG5vIGVmZmVjdC4gQmVjYXVzZSBvZiB0aGlzLCBwYXJ0cyBpbiBzdHlsZSBlbGVtZW50cyBzaG91bGQgb25seSBiZSB1c2VkIGZvclxuICogdmFsdWVzIHRoYXQgd2lsbCBuZXZlciBjaGFuZ2UsIGZvciBleGFtcGxlIHBhcnRzIHRoYXQgc2V0IHNjb3BlLXdpZGUgdGhlbWVcbiAqIHZhbHVlcyBvciBwYXJ0cyB3aGljaCByZW5kZXIgc2hhcmVkIHN0eWxlIGVsZW1lbnRzLlxuICpcbiAqICogTm90ZSwgZHVlIHRvIGEgbGltaXRhdGlvbiBvZiB0aGUgU2hhZHlET00gcG9seWZpbGwsIHJlbmRlcmluZyBpbiBhXG4gKiBjdXN0b20gZWxlbWVudCdzIGBjb25zdHJ1Y3RvcmAgaXMgbm90IHN1cHBvcnRlZC4gSW5zdGVhZCByZW5kZXJpbmcgc2hvdWxkXG4gKiBlaXRoZXIgZG9uZSBhc3luY2hyb25vdXNseSwgZm9yIGV4YW1wbGUgYXQgbWljcm90YXNrIHRpbWluZyAoZm9yIGV4YW1wbGVcbiAqIGBQcm9taXNlLnJlc29sdmUoKWApLCBvciBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZmlyc3QgdGltZSB0aGUgZWxlbWVudCdzXG4gKiBgY29ubmVjdGVkQ2FsbGJhY2tgIHJ1bnMuXG4gKlxuICogVXNhZ2UgY29uc2lkZXJhdGlvbnMgd2hlbiB1c2luZyBzaGltbWVkIGN1c3RvbSBwcm9wZXJ0aWVzIG9yIGBAYXBwbHlgOlxuICpcbiAqICogV2hlbmV2ZXIgYW55IGR5bmFtaWMgY2hhbmdlcyBhcmUgbWFkZSB3aGljaCBhZmZlY3RcbiAqIGNzcyBjdXN0b20gcHJvcGVydGllcywgYFNoYWR5Q1NTLnN0eWxlRWxlbWVudChlbGVtZW50KWAgbXVzdCBiZSBjYWxsZWRcbiAqIHRvIHVwZGF0ZSB0aGUgZWxlbWVudC4gVGhlcmUgYXJlIHR3byBjYXNlcyB3aGVuIHRoaXMgaXMgbmVlZGVkOlxuICogKDEpIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCB0byBhIG5ldyBwYXJlbnQsICgyKSBhIGNsYXNzIGlzIGFkZGVkIHRvIHRoZVxuICogZWxlbWVudCB0aGF0IGNhdXNlcyBpdCB0byBtYXRjaCBkaWZmZXJlbnQgY3VzdG9tIHByb3BlcnRpZXMuXG4gKiBUbyBhZGRyZXNzIHRoZSBmaXJzdCBjYXNlIHdoZW4gcmVuZGVyaW5nIGEgY3VzdG9tIGVsZW1lbnQsIGBzdHlsZUVsZW1lbnRgXG4gKiBzaG91bGQgYmUgY2FsbGVkIGluIHRoZSBlbGVtZW50J3MgYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAqXG4gKiAqIFNoaW1tZWQgY3VzdG9tIHByb3BlcnRpZXMgbWF5IG9ubHkgYmUgZGVmaW5lZCBlaXRoZXIgZm9yIGFuIGVudGlyZVxuICogc2hhZG93Um9vdCAoZm9yIGV4YW1wbGUsIGluIGEgYDpob3N0YCBydWxlKSBvciB2aWEgYSBydWxlIHRoYXQgZGlyZWN0bHlcbiAqIG1hdGNoZXMgYW4gZWxlbWVudCB3aXRoIGEgc2hhZG93Um9vdC4gSW4gb3RoZXIgd29yZHMsIGluc3RlYWQgb2YgZmxvd2luZyBmcm9tXG4gKiBwYXJlbnQgdG8gY2hpbGQgYXMgZG8gbmF0aXZlIGNzcyBjdXN0b20gcHJvcGVydGllcywgc2hpbW1lZCBjdXN0b20gcHJvcGVydGllc1xuICogZmxvdyBvbmx5IGZyb20gc2hhZG93Um9vdHMgdG8gbmVzdGVkIHNoYWRvd1Jvb3RzLlxuICpcbiAqICogV2hlbiB1c2luZyBgQGFwcGx5YCBtaXhpbmcgY3NzIHNob3J0aGFuZCBwcm9wZXJ0eSBuYW1lcyB3aXRoXG4gKiBub24tc2hvcnRoYW5kIG5hbWVzIChmb3IgZXhhbXBsZSBgYm9yZGVyYCBhbmQgYGJvcmRlci13aWR0aGApIGlzIG5vdFxuICogc3VwcG9ydGVkLlxuICovXG5leHBvcnQgY29uc3QgcmVuZGVyID0gKHJlc3VsdCwgY29udGFpbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCAhb3B0aW9ucy5zY29wZU5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHNjb3BlTmFtZWAgb3B0aW9uIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cbiAgICBjb25zdCBzY29wZU5hbWUgPSBvcHRpb25zLnNjb3BlTmFtZTtcbiAgICBjb25zdCBoYXNSZW5kZXJlZCA9IHBhcnRzLmhhcyhjb250YWluZXIpO1xuICAgIGNvbnN0IG5lZWRzU2NvcGluZyA9IGNvbXBhdGlibGVTaGFkeUNTU1ZlcnNpb24gJiZcbiAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSAxMSAvKiBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgKi8gJiZcbiAgICAgICAgISFjb250YWluZXIuaG9zdDtcbiAgICAvLyBIYW5kbGUgZmlyc3QgcmVuZGVyIHRvIGEgc2NvcGUgc3BlY2lhbGx5Li4uXG4gICAgY29uc3QgZmlyc3RTY29wZVJlbmRlciA9IG5lZWRzU2NvcGluZyAmJiAhc2hhZHlSZW5kZXJTZXQuaGFzKHNjb3BlTmFtZSk7XG4gICAgLy8gT24gZmlyc3Qgc2NvcGUgcmVuZGVyLCByZW5kZXIgaW50byBhIGZyYWdtZW50OyB0aGlzIGNhbm5vdCBiZSBhIHNpbmdsZVxuICAgIC8vIGZyYWdtZW50IHRoYXQgaXMgcmV1c2VkIHNpbmNlIG5lc3RlZCByZW5kZXJzIGNhbiBvY2N1ciBzeW5jaHJvbm91c2x5LlxuICAgIGNvbnN0IHJlbmRlckNvbnRhaW5lciA9IGZpcnN0U2NvcGVSZW5kZXIgPyBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkgOiBjb250YWluZXI7XG4gICAgbGl0UmVuZGVyKHJlc3VsdCwgcmVuZGVyQ29udGFpbmVyLCBPYmplY3QuYXNzaWduKHsgdGVtcGxhdGVGYWN0b3J5OiBzaGFkeVRlbXBsYXRlRmFjdG9yeShzY29wZU5hbWUpIH0sIG9wdGlvbnMpKTtcbiAgICAvLyBXaGVuIHBlcmZvcm1pbmcgZmlyc3Qgc2NvcGUgcmVuZGVyLFxuICAgIC8vICgxKSBXZSd2ZSByZW5kZXJlZCBpbnRvIGEgZnJhZ21lbnQgc28gdGhhdCB0aGVyZSdzIGEgY2hhbmNlIHRvXG4gICAgLy8gYHByZXBhcmVUZW1wbGF0ZVN0eWxlc2AgYmVmb3JlIHN1Yi1lbGVtZW50cyBoaXQgdGhlIERPTVxuICAgIC8vICh3aGljaCBtaWdodCBjYXVzZSB0aGVtIHRvIHJlbmRlciBiYXNlZCBvbiBhIGNvbW1vbiBwYXR0ZXJuIG9mXG4gICAgLy8gcmVuZGVyaW5nIGluIGEgY3VzdG9tIGVsZW1lbnQncyBgY29ubmVjdGVkQ2FsbGJhY2tgKTtcbiAgICAvLyAoMikgU2NvcGUgdGhlIHRlbXBsYXRlIHdpdGggU2hhZHlDU1Mgb25lIHRpbWUgb25seSBmb3IgdGhpcyBzY29wZS5cbiAgICAvLyAoMykgUmVuZGVyIHRoZSBmcmFnbWVudCBpbnRvIHRoZSBjb250YWluZXIgYW5kIG1ha2Ugc3VyZSB0aGVcbiAgICAvLyBjb250YWluZXIga25vd3MgaXRzIGBwYXJ0YCBpcyB0aGUgb25lIHdlIGp1c3QgcmVuZGVyZWQuIFRoaXMgZW5zdXJlc1xuICAgIC8vIERPTSB3aWxsIGJlIHJlLXVzZWQgb24gc3Vic2VxdWVudCByZW5kZXJzLlxuICAgIGlmIChmaXJzdFNjb3BlUmVuZGVyKSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0cy5nZXQocmVuZGVyQ29udGFpbmVyKTtcbiAgICAgICAgcGFydHMuZGVsZXRlKHJlbmRlckNvbnRhaW5lcik7XG4gICAgICAgIC8vIFNoYWR5Q1NTIG1pZ2h0IGhhdmUgc3R5bGUgc2hlZXRzIChlLmcuIGZyb20gYHByZXBhcmVBZG9wdGVkQ3NzVGV4dGApXG4gICAgICAgIC8vIHRoYXQgc2hvdWxkIGFwcGx5IHRvIGByZW5kZXJDb250YWluZXJgIGV2ZW4gaWYgdGhlIHJlbmRlcmVkIHZhbHVlIGlzXG4gICAgICAgIC8vIG5vdCBhIFRlbXBsYXRlSW5zdGFuY2UuIEhvd2V2ZXIsIGl0IHdpbGwgb25seSBpbnNlcnQgc2NvcGVkIHN0eWxlc1xuICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudCBpZiBgcHJlcGFyZVRlbXBsYXRlU3R5bGVzYCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgICAgICAvLyBmb3IgdGhlIGdpdmVuIHNjb3BlIG5hbWUuXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gcGFydC52YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlSW5zdGFuY2UgP1xuICAgICAgICAgICAgcGFydC52YWx1ZS50ZW1wbGF0ZSA6XG4gICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgIHByZXBhcmVUZW1wbGF0ZVN0eWxlcyhzY29wZU5hbWUsIHJlbmRlckNvbnRhaW5lciwgdGVtcGxhdGUpO1xuICAgICAgICByZW1vdmVOb2Rlcyhjb250YWluZXIsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJlbmRlckNvbnRhaW5lcik7XG4gICAgICAgIHBhcnRzLnNldChjb250YWluZXIsIHBhcnQpO1xuICAgIH1cbiAgICAvLyBBZnRlciBlbGVtZW50cyBoYXZlIGhpdCB0aGUgRE9NLCB1cGRhdGUgc3R5bGluZyBpZiB0aGlzIGlzIHRoZVxuICAgIC8vIGluaXRpYWwgcmVuZGVyIHRvIHRoaXMgY29udGFpbmVyLlxuICAgIC8vIFRoaXMgaXMgbmVlZGVkIHdoZW5ldmVyIGR5bmFtaWMgY2hhbmdlcyBhcmUgbWFkZSBzbyBpdCB3b3VsZCBiZVxuICAgIC8vIHNhZmVzdCB0byBkbyBldmVyeSByZW5kZXI7IGhvd2V2ZXIsIHRoaXMgd291bGQgcmVncmVzcyBwZXJmb3JtYW5jZVxuICAgIC8vIHNvIHdlIGxlYXZlIGl0IHVwIHRvIHRoZSB1c2VyIHRvIGNhbGwgYFNoYWR5Q1NTLnN0eWxlRWxlbWVudGBcbiAgICAvLyBmb3IgZHluYW1pYyBjaGFuZ2VzLlxuICAgIGlmICghaGFzUmVuZGVyZWQgJiYgbmVlZHNTY29waW5nKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZUVsZW1lbnQoY29udGFpbmVyLmhvc3QpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkeS1yZW5kZXIuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xudmFyIF9hO1xuLyoqXG4gKiBXaGVuIHVzaW5nIENsb3N1cmUgQ29tcGlsZXIsIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkocHJvcGVydHksIG9iamVjdCkgaXNcbiAqIHJlcGxhY2VkIGF0IGNvbXBpbGUgdGltZSBieSB0aGUgbXVuZ2VkIG5hbWUgZm9yIG9iamVjdFtwcm9wZXJ0eV0uIFdlIGNhbm5vdFxuICogYWxpYXMgdGhpcyBmdW5jdGlvbiwgc28gd2UgaGF2ZSB0byB1c2UgYSBzbWFsbCBzaGltIHRoYXQgaGFzIHRoZSBzYW1lXG4gKiBiZWhhdmlvciB3aGVuIG5vdCBjb21waWxpbmcuXG4gKi9cbndpbmRvdy5KU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5ID1cbiAgICAocHJvcCwgX29iaikgPT4gcHJvcDtcbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29udmVydGVyID0ge1xuICAgIHRvQXR0cmlidXRlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICcnIDogbnVsbDtcbiAgICAgICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgIHBhc3MgdGhpcyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gdG8gYWxsb3cgcmVtb3Zpbmcvbm8gY2hhbmdlIGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZnJvbUF0dHJpYnV0ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGw7XG4gICAgICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBudWxsIDogTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG4vKipcbiAqIENoYW5nZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGRpZmZlcmVudCBmcm9tIGBvbGRWYWx1ZWAuXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IGZvciBhIHByb3BlcnR5J3MgYGhhc0NoYW5nZWRgIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY29uc3Qgbm90RXF1YWwgPSAodmFsdWUsIG9sZCkgPT4ge1xuICAgIC8vIFRoaXMgZW5zdXJlcyAob2xkPT1OYU4sIHZhbHVlPT1OYU4pIGFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAgcmV0dXJuIG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSk7XG59O1xuY29uc3QgZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb24gPSB7XG4gICAgYXR0cmlidXRlOiB0cnVlLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjb252ZXJ0ZXI6IGRlZmF1bHRDb252ZXJ0ZXIsXG4gICAgcmVmbGVjdDogZmFsc2UsXG4gICAgaGFzQ2hhbmdlZDogbm90RXF1YWxcbn07XG5jb25zdCBtaWNyb3Rhc2tQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuY29uc3QgU1RBVEVfSEFTX1VQREFURUQgPSAxO1xuY29uc3QgU1RBVEVfVVBEQVRFX1JFUVVFU1RFRCA9IDEgPDwgMjtcbmNvbnN0IFNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fQVRUUklCVVRFID0gMSA8PCAzO1xuY29uc3QgU1RBVEVfSVNfUkVGTEVDVElOR19UT19QUk9QRVJUWSA9IDEgPDwgNDtcbmNvbnN0IFNUQVRFX0hBU19DT05ORUNURUQgPSAxIDw8IDU7XG4vKipcbiAqIFRoZSBDbG9zdXJlIEpTIENvbXBpbGVyIGRvZXNuJ3QgY3VycmVudGx5IGhhdmUgZ29vZCBzdXBwb3J0IGZvciBzdGF0aWNcbiAqIHByb3BlcnR5IHNlbWFudGljcyB3aGVyZSBcInRoaXNcIiBpcyBkeW5hbWljIChlLmcuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMxNzcgYW5kIG90aGVycykgc28gd2UgdXNlXG4gKiB0aGlzIGhhY2sgdG8gYnlwYXNzIGFueSByZXdyaXRpbmcgYnkgdGhlIGNvbXBpbGVyLlxuICovXG5jb25zdCBmaW5hbGl6ZWQgPSAnZmluYWxpemVkJztcbi8qKlxuICogQmFzZSBlbGVtZW50IGNsYXNzIHdoaWNoIG1hbmFnZXMgZWxlbWVudCBwcm9wZXJ0aWVzIGFuZCBhdHRyaWJ1dGVzLiBXaGVuXG4gKiBwcm9wZXJ0aWVzIGNoYW5nZSwgdGhlIGB1cGRhdGVgIG1ldGhvZCBpcyBhc3luY2hyb25vdXNseSBjYWxsZWQuIFRoaXMgbWV0aG9kXG4gKiBzaG91bGQgYmUgc3VwcGxpZWQgYnkgc3ViY2xhc3NlcnMgdG8gcmVuZGVyIHVwZGF0ZXMgYXMgZGVzaXJlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFVwZGF0aW5nRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUgPSAwO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb21pc2UgPSBtaWNyb3Rhc2tQcm9taXNlO1xuICAgICAgICB0aGlzLl9oYXNDb25uZWN0ZWRSZXNvbHZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCB3aXRoIGtleXMgZm9yIGFueSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0XG4gICAgICAgICAqIHVwZGF0ZSBjeWNsZSB3aXRoIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIHdpdGgga2V5cyBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHJlZmxlY3RlZCB3aGVuIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGF0dHJpYnV0ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIC8vIG5vdGU6IHBpZ2d5IGJhY2tpbmcgb24gdGhpcyB0byBlbnN1cmUgd2UncmUgZmluYWxpemVkLlxuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yIGxvb3BzXG4gICAgICAgIC8vIGV4cGVjdGluZyBhcnJheXNcbiAgICAgICAgdGhpcy5fY2xhc3NQcm9wZXJ0aWVzLmZvckVhY2goKHYsIHApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkocCwgdik7XG4gICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcC5zZXQoYXR0ciwgcCk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIHByaXZhdGUgYF9jbGFzc1Byb3BlcnRpZXNgIHByb3BlcnR5IG1ldGFkYXRhIGlzIGNyZWF0ZWQuXG4gICAgICogSW4gYWRkaXRpb24gdG8gYGZpbmFsaXplYCB0aGlzIGlzIGFsc28gY2FsbGVkIGluIGBjcmVhdGVQcm9wZXJ0eWAgdG9cbiAgICAgKiBlbnN1cmUgdGhlIGBAcHJvcGVydHlgIGRlY29yYXRvciBjYW4gYWRkIHByb3BlcnR5IG1ldGFkYXRhLlxuICAgICAqL1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIHN0YXRpYyBfZW5zdXJlQ2xhc3NQcm9wZXJ0aWVzKCkge1xuICAgICAgICAvLyBlbnN1cmUgcHJpdmF0ZSBzdG9yYWdlIGZvciBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfY2xhc3NQcm9wZXJ0aWVzJywgdGhpcykpKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc1Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBOT1RFOiBXb3JrYXJvdW5kIElFMTEgbm90IHN1cHBvcnRpbmcgTWFwIGNvbnN0cnVjdG9yIGFyZ3VtZW50LlxuICAgICAgICAgICAgY29uc3Qgc3VwZXJQcm9wZXJ0aWVzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9jbGFzc1Byb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAoc3VwZXJQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdXBlclByb3BlcnRpZXMuZm9yRWFjaCgodiwgaykgPT4gdGhpcy5fY2xhc3NQcm9wZXJ0aWVzLnNldChrLCB2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByb3BlcnR5IGFjY2Vzc29yIG9uIHRoZSBlbGVtZW50IHByb3RvdHlwZSBpZiBvbmUgZG9lcyBub3QgZXhpc3QuXG4gICAgICogVGhlIHByb3BlcnR5IHNldHRlciBjYWxscyB0aGUgcHJvcGVydHkncyBgaGFzQ2hhbmdlZGAgcHJvcGVydHkgb3B0aW9uXG4gICAgICogb3IgdXNlcyBhIHN0cmljdCBpZGVudGl0eSBjaGVjayB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gcmVxdWVzdFxuICAgICAqIGFuIHVwZGF0ZS5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eShuYW1lLCBvcHRpb25zID0gZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb24pIHtcbiAgICAgICAgLy8gTm90ZSwgc2luY2UgdGhpcyBjYW4gYmUgY2FsbGVkIGJ5IHRoZSBgQHByb3BlcnR5YCBkZWNvcmF0b3Igd2hpY2hcbiAgICAgICAgLy8gaXMgY2FsbGVkIGJlZm9yZSBgZmluYWxpemVgLCB3ZSBlbnN1cmUgc3RvcmFnZSBleGlzdHMgZm9yIHByb3BlcnR5XG4gICAgICAgIC8vIG1ldGFkYXRhLlxuICAgICAgICB0aGlzLl9lbnN1cmVDbGFzc1Byb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5fY2xhc3NQcm9wZXJ0aWVzLnNldChuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgLy8gRG8gbm90IGdlbmVyYXRlIGFuIGFjY2Vzc29yIGlmIHRoZSBwcm90b3R5cGUgYWxyZWFkeSBoYXMgb25lLCBzaW5jZVxuICAgICAgICAvLyBpdCB3b3VsZCBiZSBsb3N0IG90aGVyd2lzZSBhbmQgdGhhdCB3b3VsZCBuZXZlciBiZSB0aGUgdXNlcidzIGludGVudGlvbjtcbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgZXhwZWN0IHVzZXJzIHRvIGNhbGwgYHJlcXVlc3RVcGRhdGVgIHRoZW1zZWx2ZXMgZnJvbVxuICAgICAgICAvLyB1c2VyLWRlZmluZWQgYWNjZXNzb3JzLiBOb3RlIHRoYXQgaWYgdGhlIHN1cGVyIGhhcyBhbiBhY2Nlc3NvciB3ZSB3aWxsXG4gICAgICAgIC8vIHN0aWxsIG92ZXJ3cml0ZSBpdFxuICAgICAgICBpZiAob3B0aW9ucy5ub0FjY2Vzc29yIHx8IHRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG5hbWUgPT09ICdzeW1ib2wnID8gU3ltYm9sKCkgOiBgX18ke25hbWV9YDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IG5vIHN5bWJvbCBpbiBpbmRleFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUobmFtZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgcHJvcGVydHkgYWNjZXNzb3JzIGZvciByZWdpc3RlcmVkIHByb3BlcnRpZXMgYW5kIGVuc3VyZXNcbiAgICAgKiBhbnkgc3VwZXJjbGFzc2VzIGFyZSBhbHNvIGZpbmFsaXplZC5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5hbGl6ZSgpIHtcbiAgICAgICAgLy8gZmluYWxpemUgYW55IHN1cGVyY2xhc3Nlc1xuICAgICAgICBjb25zdCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgIGlmICghc3VwZXJDdG9yLmhhc093blByb3BlcnR5KGZpbmFsaXplZCkpIHtcbiAgICAgICAgICAgIHN1cGVyQ3Rvci5maW5hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbZmluYWxpemVkXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUNsYXNzUHJvcGVydGllcygpO1xuICAgICAgICAvLyBpbml0aWFsaXplIE1hcCBwb3B1bGF0ZWQgaW4gb2JzZXJ2ZWRBdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIG1ha2UgYW55IHByb3BlcnRpZXNcbiAgICAgICAgLy8gTm90ZSwgb25seSBwcm9jZXNzIFwib3duXCIgcHJvcGVydGllcyBzaW5jZSB0aGlzIGVsZW1lbnQgd2lsbCBpbmhlcml0XG4gICAgICAgIC8vIGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhlIHN1cGVyQ2xhc3MsIGFuZCBmaW5hbGl6YXRpb24gZW5zdXJlc1xuICAgICAgICAvLyB0aGUgZW50aXJlIHByb3RvdHlwZSBjaGFpbiBpcyBmaW5hbGl6ZWQuXG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnLCB0aGlzKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgLy8gc3VwcG9ydCBzeW1ib2xzIGluIHByb3BlcnRpZXMgKElFMTEgZG9lcyBub3Qgc3VwcG9ydCB0aGlzKVxuICAgICAgICAgICAgY29uc3QgcHJvcEtleXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcHMpLFxuICAgICAgICAgICAgICAgIC4uLih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BzKSA6XG4gICAgICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gVGhpcyBmb3Ivb2YgaXMgb2sgYmVjYXVzZSBwcm9wS2V5cyBpcyBhbiBhcnJheVxuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHByb3BLZXlzKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90ZSwgdXNlIG9mIGBhbnlgIGlzIGR1ZSB0byBUeXBlU3JpcHQgbGFjayBvZiBzdXBwb3J0IGZvciBzeW1ib2wgaW5cbiAgICAgICAgICAgICAgICAvLyBpbmRleCB0eXBlc1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgbm8gc3ltYm9sIGluIGluZGV4XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQcm9wZXJ0eShwLCBwcm9wc1twXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvcGVydHkgbmFtZSBmb3IgdGhlIGdpdmVuIGF0dHJpYnV0ZSBgbmFtZWAuXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG9wdGlvbnMuYXR0cmlidXRlO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlID09PSBmYWxzZSA/XG4gICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgKHR5cGVvZiBhdHRyaWJ1dGUgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgOlxuICAgICAgICAgICAgICAgICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgcHJvcGVydHkgc2hvdWxkIHJlcXVlc3QgYW4gdXBkYXRlLlxuICAgICAqIENhbGxlZCB3aGVuIGEgcHJvcGVydHkgdmFsdWUgaXMgc2V0IGFuZCB1c2VzIHRoZSBgaGFzQ2hhbmdlZGBcbiAgICAgKiBvcHRpb24gZm9yIHRoZSBwcm9wZXJ0eSBpZiBwcmVzZW50IG9yIGEgc3RyaWN0IGlkZW50aXR5IGNoZWNrLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF92YWx1ZUhhc0NoYW5nZWQodmFsdWUsIG9sZCwgaGFzQ2hhbmdlZCA9IG5vdEVxdWFsKSB7XG4gICAgICAgIHJldHVybiBoYXNDaGFuZ2VkKHZhbHVlLCBvbGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBDYWxsZWQgdmlhIHRoZSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCBhbmQgdXNlcyB0aGUgcHJvcGVydHknc1xuICAgICAqIGBjb252ZXJ0ZXJgIG9yIGBjb252ZXJ0ZXIuZnJvbUF0dHJpYnV0ZWAgcHJvcGVydHkgb3B0aW9uLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wcm9wZXJ0eVZhbHVlRnJvbUF0dHJpYnV0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBvcHRpb25zLmNvbnZlcnRlciB8fCBkZWZhdWx0Q29udmVydGVyO1xuICAgICAgICBjb25zdCBmcm9tQXR0cmlidXRlID0gKHR5cGVvZiBjb252ZXJ0ZXIgPT09ICdmdW5jdGlvbicgPyBjb252ZXJ0ZXIgOiBjb252ZXJ0ZXIuZnJvbUF0dHJpYnV0ZSk7XG4gICAgICAgIHJldHVybiBmcm9tQXR0cmlidXRlID8gZnJvbUF0dHJpYnV0ZSh2YWx1ZSwgdHlwZSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXR0cmlidXRlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuIElmIHRoaXNcbiAgICAgKiByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIHByb3BlcnR5IHdpbGwgKm5vdCogYmUgcmVmbGVjdGVkIHRvIGFuIGF0dHJpYnV0ZS5cbiAgICAgKiBJZiB0aGlzIHJldHVybnMgbnVsbCwgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQsIG90aGVyd2lzZSB0aGVcbiAgICAgKiBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQgdG8gdGhlIHZhbHVlLlxuICAgICAqIFRoaXMgdXNlcyB0aGUgcHJvcGVydHkncyBgcmVmbGVjdGAgYW5kIGB0eXBlLnRvQXR0cmlidXRlYCBwcm9wZXJ0eSBvcHRpb25zLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wcm9wZXJ0eVZhbHVlVG9BdHRyaWJ1dGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmbGVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gb3B0aW9ucy5jb252ZXJ0ZXI7XG4gICAgICAgIGNvbnN0IHRvQXR0cmlidXRlID0gY29udmVydGVyICYmIGNvbnZlcnRlci50b0F0dHJpYnV0ZSB8fFxuICAgICAgICAgICAgZGVmYXVsdENvbnZlcnRlci50b0F0dHJpYnV0ZTtcbiAgICAgICAgcmV0dXJuIHRvQXR0cmlidXRlKHZhbHVlLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgZWxlbWVudCBpbml0aWFsaXphdGlvbi4gQnkgZGVmYXVsdCBjYXB0dXJlcyBhbnkgcHJlLXNldCB2YWx1ZXMgZm9yXG4gICAgICogcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuX3NhdmVJbnN0YW5jZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gZW5zdXJlcyBmaXJzdCB1cGRhdGUgd2lsbCBiZSBjYXVnaHQgYnkgYW4gZWFybHkgYWNjZXNzIG9mXG4gICAgICAgIC8vIGB1cGRhdGVDb21wbGV0ZWBcbiAgICAgICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaXhlcyBhbnkgcHJvcGVydGllcyBzZXQgb24gdGhlIGluc3RhbmNlIGJlZm9yZSB1cGdyYWRlIHRpbWUuXG4gICAgICogT3RoZXJ3aXNlIHRoZXNlIHdvdWxkIHNoYWRvdyB0aGUgYWNjZXNzb3IgYW5kIGJyZWFrIHRoZXNlIHByb3BlcnRpZXMuXG4gICAgICogVGhlIHByb3BlcnRpZXMgYXJlIHN0b3JlZCBpbiBhIE1hcCB3aGljaCBpcyBwbGF5ZWQgYmFjayBhZnRlciB0aGVcbiAgICAgKiBjb25zdHJ1Y3RvciBydW5zLiBOb3RlLCBvbiB2ZXJ5IG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkgKDw9OSkgb3IgQ2hyb21lXG4gICAgICogKDw9NDEpLCBwcm9wZXJ0aWVzIGNyZWF0ZWQgZm9yIG5hdGl2ZSBwbGF0Zm9ybSBwcm9wZXJ0aWVzIGxpa2UgKGBpZGAgb3JcbiAgICAgKiBgbmFtZWApIG1heSBub3QgaGF2ZSBkZWZhdWx0IHZhbHVlcyBzZXQgaW4gdGhlIGVsZW1lbnQgY29uc3RydWN0b3IuIE9uXG4gICAgICogdGhlc2UgYnJvd3NlcnMgbmF0aXZlIHByb3BlcnRpZXMgYXBwZWFyIG9uIGluc3RhbmNlcyBhbmQgdGhlcmVmb3JlIHRoZWlyXG4gICAgICogZGVmYXVsdCB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBhbnkgZWxlbWVudCBkZWZhdWx0IChlLmcuIGlmIHRoZSBlbGVtZW50IHNldHNcbiAgICAgKiB0aGlzLmlkID0gJ2lkJyBpbiB0aGUgY29uc3RydWN0b3IsIHRoZSAnaWQnIHdpbGwgYmVjb21lICcnIHNpbmNlIHRoaXMgaXNcbiAgICAgKiB0aGUgbmF0aXZlIHBsYXRmb3JtIGRlZmF1bHQpLlxuICAgICAqL1xuICAgIF9zYXZlSW5zdGFuY2VQcm9wZXJ0aWVzKCkge1xuICAgICAgICAvLyBVc2UgZm9yRWFjaCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgZm9yL29mIGxvb3BzIGFyZSBjb21waWxlZCB0byBmb3IgbG9vcHNcbiAgICAgICAgLy8gZXhwZWN0aW5nIGFycmF5c1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAuX2NsYXNzUHJvcGVydGllcy5mb3JFYWNoKChfdiwgcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNbcF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbcF07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXMuc2V0KHAsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgcHJldmlvdXNseSBzYXZlZCBpbnN0YW5jZSBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIF9hcHBseUluc3RhbmNlUHJvcGVydGllcygpIHtcbiAgICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yIGxvb3BzXG4gICAgICAgIC8vIGV4cGVjdGluZyBhcnJheXNcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICB0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXMuZm9yRWFjaCgodiwgcCkgPT4gdGhpc1twXSA9IHYpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IHRoaXMuX3VwZGF0ZVN0YXRlIHwgU1RBVEVfSEFTX0NPTk5FQ1RFRDtcbiAgICAgICAgLy8gRW5zdXJlIGZpcnN0IGNvbm5lY3Rpb24gY29tcGxldGVzIGFuIHVwZGF0ZS4gVXBkYXRlcyBjYW5ub3QgY29tcGxldGVcbiAgICAgICAgLy8gYmVmb3JlIGNvbm5lY3Rpb24gYW5kIGlmIG9uZSBpcyBwZW5kaW5nIGNvbm5lY3Rpb24gdGhlXG4gICAgICAgIC8vIGBfaGFzQ29ubmVjdGlvblJlc29sdmVyYCB3aWxsIGV4aXN0LiBJZiBzbywgcmVzb2x2ZSBpdCB0byBjb21wbGV0ZSB0aGVcbiAgICAgICAgLy8gdXBkYXRlLCBvdGhlcndpc2UgcmVxdWVzdFVwZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMuX2hhc0Nvbm5lY3RlZFJlc29sdmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNDb25uZWN0ZWRSZXNvbHZlcigpO1xuICAgICAgICAgICAgdGhpcy5faGFzQ29ubmVjdGVkUmVzb2x2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGZvciBgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKWAgaW4gZXh0ZW5zaW9ucyB3aGlsZVxuICAgICAqIHJlc2VydmluZyB0aGUgcG9zc2liaWxpdHkgb2YgbWFraW5nIG5vbi1icmVha2luZyBmZWF0dXJlIGFkZGl0aW9uc1xuICAgICAqIHdoZW4gZGlzY29ubmVjdGluZyBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9uaXplcyBwcm9wZXJ0eSB2YWx1ZXMgd2hlbiBhdHRyaWJ1dGVzIGNoYW5nZS5cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSBkZWZhdWx0UHJvcGVydHlEZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgYXR0ciA9IGN0b3IuX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgYXR0clZhbHVlID0gY3Rvci5fcHJvcGVydHlWYWx1ZVRvQXR0cmlidXRlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGFuIHVuZGVmaW5lZCB2YWx1ZSBkb2VzIG5vdCBjaGFuZ2UgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIGlmIChhdHRyVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyYWNrIGlmIHRoZSBwcm9wZXJ0eSBpcyBiZWluZyByZWZsZWN0ZWQgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHByb3BlcnR5IGFnYWluIHZpYSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYC4gTm90ZTpcbiAgICAgICAgICAgIC8vIDEuIHRoaXMgdGFrZXMgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgdGhlIGNhbGxiYWNrIGlzIHN5bmNocm9ub3VzLlxuICAgICAgICAgICAgLy8gMi4gd2lsbCBiZWhhdmUgaW5jb3JyZWN0bHkgaWYgbXVsdGlwbGUgYXR0cmlidXRlcyBhcmUgaW4gdGhlIHJlYWN0aW9uXG4gICAgICAgICAgICAvLyBzdGFjayBhdCB0aW1lIG9mIGNhbGxpbmcuIEhvd2V2ZXIsIHNpbmNlIHdlIHByb2Nlc3MgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gaW4gYHVwZGF0ZWAgdGhpcyBzaG91bGQgbm90IGJlIHBvc3NpYmxlIChvciBhbiBleHRyZW1lIGNvcm5lciBjYXNlXG4gICAgICAgICAgICAvLyB0aGF0IHdlJ2QgbGlrZSB0byBkaXNjb3ZlcikuXG4gICAgICAgICAgICAvLyBtYXJrIHN0YXRlIHJlZmxlY3RpbmdcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlID0gdGhpcy5fdXBkYXRlU3RhdGUgfCBTVEFURV9JU19SRUZMRUNUSU5HX1RPX0FUVFJJQlVURTtcbiAgICAgICAgICAgIGlmIChhdHRyVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcmsgc3RhdGUgbm90IHJlZmxlY3RpbmdcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlID0gdGhpcy5fdXBkYXRlU3RhdGUgJiB+U1RBVEVfSVNfUkVGTEVDVElOR19UT19BVFRSSUJVVEU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gVXNlIHRyYWNraW5nIGluZm8gdG8gYXZvaWQgZGVzZXJpYWxpemluZyBhdHRyaWJ1dGUgdmFsdWUgaWYgaXQgd2FzXG4gICAgICAgIC8vIGp1c3Qgc2V0IGZyb20gYSBwcm9wZXJ0eSBzZXR0ZXIuXG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVTdGF0ZSAmIFNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fQVRUUklCVVRFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IHByb3BOYW1lID0gY3Rvci5fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY3Rvci5fY2xhc3NQcm9wZXJ0aWVzLmdldChwcm9wTmFtZSkgfHwgZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb247XG4gICAgICAgICAgICAvLyBtYXJrIHN0YXRlIHJlZmxlY3RpbmdcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlID0gdGhpcy5fdXBkYXRlU3RhdGUgfCBTVEFURV9JU19SRUZMRUNUSU5HX1RPX1BST1BFUlRZO1xuICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPVxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAgICAgICBjdG9yLl9wcm9wZXJ0eVZhbHVlRnJvbUF0dHJpYnV0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBtYXJrIHN0YXRlIG5vdCByZWZsZWN0aW5nXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IHRoaXMuX3VwZGF0ZVN0YXRlICYgflNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fUFJPUEVSVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBwcml2YXRlIHZlcnNpb24gb2YgYHJlcXVlc3RVcGRhdGVgIGRvZXMgbm90IGFjY2VzcyBvciByZXR1cm4gdGhlXG4gICAgICogYHVwZGF0ZUNvbXBsZXRlYCBwcm9taXNlLiBUaGlzIHByb21pc2UgY2FuIGJlIG92ZXJyaWRkZW4gYW5kIGlzIHRoZXJlZm9yZVxuICAgICAqIG5vdCBmcmVlIHRvIGFjY2Vzcy5cbiAgICAgKi9cbiAgICBfcmVxdWVzdFVwZGF0ZShuYW1lLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgc2hvdWxkUmVxdWVzdFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwcm9wZXJ0eSBrZXksIHBlcmZvcm0gcHJvcGVydHkgdXBkYXRlIHN0ZXBzLlxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjdG9yLl9jbGFzc1Byb3BlcnRpZXMuZ2V0KG5hbWUpIHx8IGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgaWYgKGN0b3IuX3ZhbHVlSGFzQ2hhbmdlZCh0aGlzW25hbWVdLCBvbGRWYWx1ZSwgb3B0aW9ucy5oYXNDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2hhbmdlZFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzLnNldChuYW1lLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byByZWZsZWN0aW5nIHByb3BlcnRpZXMgc2V0LlxuICAgICAgICAgICAgICAgIC8vIE5vdGUsIGl0J3MgaW1wb3J0YW50IHRoYXQgZXZlcnkgY2hhbmdlIGhhcyBhIGNoYW5jZSB0byBhZGQgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgdG8gYF9yZWZsZWN0aW5nUHJvcGVydGllc2AuIFRoaXMgZW5zdXJlcyBzZXR0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlICsgcHJvcGVydHkgcmVmbGVjdHMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlZmxlY3QgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAgICAgISh0aGlzLl91cGRhdGVTdGF0ZSAmIFNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fUFJPUEVSVFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcy5zZXQobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgdGhlIHJlcXVlc3QgaWYgdGhlIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIHNob3VsZFJlcXVlc3RVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hhc1JlcXVlc3RlZFVwZGF0ZSAmJiBzaG91bGRSZXF1ZXN0VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9lbnF1ZXVlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYW4gdXBkYXRlIHdoaWNoIGlzIHByb2Nlc3NlZCBhc3luY2hyb25vdXNseS4gVGhpcyBzaG91bGRcbiAgICAgKiBiZSBjYWxsZWQgd2hlbiBhbiBlbGVtZW50IHNob3VsZCB1cGRhdGUgYmFzZWQgb24gc29tZSBzdGF0ZSBub3QgdHJpZ2dlcmVkXG4gICAgICogYnkgc2V0dGluZyBhIHByb3BlcnR5LiBJbiB0aGlzIGNhc2UsIHBhc3Mgbm8gYXJndW1lbnRzLiBJdCBzaG91bGQgYWxzbyBiZVxuICAgICAqIGNhbGxlZCB3aGVuIG1hbnVhbGx5IGltcGxlbWVudGluZyBhIHByb3BlcnR5IHNldHRlci4gSW4gdGhpcyBjYXNlLCBwYXNzIHRoZVxuICAgICAqIHByb3BlcnR5IGBuYW1lYCBhbmQgYG9sZFZhbHVlYCB0byBlbnN1cmUgdGhhdCBhbnkgY29uZmlndXJlZCBwcm9wZXJ0eVxuICAgICAqIG9wdGlvbnMgYXJlIGhvbm9yZWQuIFJldHVybnMgdGhlIGB1cGRhdGVDb21wbGV0ZWAgUHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZFxuICAgICAqIHdoZW4gdGhlIHVwZGF0ZSBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSB7UHJvcGVydHlLZXl9IChvcHRpb25hbCkgbmFtZSBvZiByZXF1ZXN0aW5nIHByb3BlcnR5XG4gICAgICogQHBhcmFtIG9sZFZhbHVlIHthbnl9IChvcHRpb25hbCkgb2xkIHZhbHVlIG9mIHJlcXVlc3RpbmcgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgdXBkYXRlIGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICByZXF1ZXN0VXBkYXRlKG5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUobmFtZSwgb2xkVmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDb21wbGV0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgZWxlbWVudCB0byBhc3luY2hyb25vdXNseSB1cGRhdGUuXG4gICAgICovXG4gICAgYXN5bmMgX2VucXVldWVVcGRhdGUoKSB7XG4gICAgICAgIC8vIE1hcmsgc3RhdGUgdXBkYXRpbmcuLi5cbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZSB8IFNUQVRFX1VQREFURV9SRVFVRVNURUQ7XG4gICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICBsZXQgcmVqZWN0O1xuICAgICAgICBjb25zdCBwcmV2aW91c1VwZGF0ZVByb21pc2UgPSB0aGlzLl91cGRhdGVQcm9taXNlO1xuICAgICAgICB0aGlzLl91cGRhdGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbnkgcHJldmlvdXMgdXBkYXRlIGhhcyByZXNvbHZlZCBiZWZvcmUgdXBkYXRpbmcuXG4gICAgICAgICAgICAvLyBUaGlzIGBhd2FpdGAgYWxzbyBlbnN1cmVzIHRoYXQgcHJvcGVydHkgY2hhbmdlcyBhcmUgYmF0Y2hlZC5cbiAgICAgICAgICAgIGF3YWl0IHByZXZpb3VzVXBkYXRlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGFueSBwcmV2aW91cyBlcnJvcnMuIFdlIG9ubHkgY2FyZSB0aGF0IHRoZSBwcmV2aW91cyBjeWNsZSBpc1xuICAgICAgICAgICAgLy8gZG9uZS4gQW55IGVycm9yIHNob3VsZCBoYXZlIGJlZW4gaGFuZGxlZCBpbiB0aGUgcHJldmlvdXMgdXBkYXRlLlxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBoYXMgY29ubmVjdGVkIGJlZm9yZSB1cGRhdGluZy5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHRoaXMuX2hhc0Nvbm5lY3RlZFJlc29sdmVyID0gcmVzKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wZXJmb3JtVXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBJZiBgcGVyZm9ybVVwZGF0ZWAgcmV0dXJucyBhIFByb21pc2UsIHdlIGF3YWl0IGl0LiBUaGlzIGlzIGRvbmUgdG9cbiAgICAgICAgICAgIC8vIGVuYWJsZSBjb29yZGluYXRpbmcgdXBkYXRlcyB3aXRoIGEgc2NoZWR1bGVyLiBOb3RlLCB0aGUgcmVzdWx0IGlzXG4gICAgICAgICAgICAvLyBjaGVja2VkIHRvIGF2b2lkIGRlbGF5aW5nIGFuIGFkZGl0aW9uYWwgbWljcm90YXNrIHVubGVzcyB3ZSBuZWVkIHRvLlxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSghdGhpcy5faGFzUmVxdWVzdGVkVXBkYXRlKTtcbiAgICB9XG4gICAgZ2V0IF9oYXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdXBkYXRlU3RhdGUgJiBTVEFURV9IQVNfQ09OTkVDVEVEKTtcbiAgICB9XG4gICAgZ2V0IF9oYXNSZXF1ZXN0ZWRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdXBkYXRlU3RhdGUgJiBTVEFURV9VUERBVEVfUkVRVUVTVEVEKTtcbiAgICB9XG4gICAgZ2V0IGhhc1VwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdXBkYXRlU3RhdGUgJiBTVEFURV9IQVNfVVBEQVRFRCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFuIGVsZW1lbnQgdXBkYXRlLiBOb3RlLCBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGR1cmluZyB0aGVcbiAgICAgKiB1cGRhdGUsIGBmaXJzdFVwZGF0ZWRgIGFuZCBgdXBkYXRlZGAgd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIHRpbWluZyBvZiB1cGRhdGVzLiBJZiB0aGlzXG4gICAgICogbWV0aG9kIGlzIG92ZXJyaWRkZW4sIGBzdXBlci5wZXJmb3JtVXBkYXRlKClgIG11c3QgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogRm9yIGluc3RhbmNlLCB0byBzY2hlZHVsZSB1cGRhdGVzIHRvIG9jY3VyIGp1c3QgYmVmb3JlIHRoZSBuZXh0IGZyYW1lOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogcHJvdGVjdGVkIGFzeW5jIHBlcmZvcm1VcGRhdGUoKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgICogICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHJlc29sdmUoKSkpO1xuICAgICAqICAgc3VwZXIucGVyZm9ybVVwZGF0ZSgpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwZXJmb3JtVXBkYXRlKCkge1xuICAgICAgICAvLyBNaXhpbiBpbnN0YW5jZSBwcm9wZXJ0aWVzIG9uY2UsIGlmIHRoZXkgZXhpc3QuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5SW5zdGFuY2VQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGFuZ2VkUHJvcGVydGllcyA9IHRoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdGhpcy5zaG91bGRVcGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBgZmlyc3RVcGRhdGVkYCBhbmQgYHVwZGF0ZWRgIGZyb20gcnVubmluZyB3aGVuIHRoZXJlJ3MgYW5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBleGNlcHRpb24uXG4gICAgICAgICAgICBzaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgZWxlbWVudCBjYW4gYWNjZXB0IGFkZGl0aW9uYWwgdXBkYXRlcyBhZnRlciBhbiBleGNlcHRpb24uXG4gICAgICAgICAgICB0aGlzLl9tYXJrVXBkYXRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3VwZGF0ZVN0YXRlICYgU1RBVEVfSEFTX1VQREFURUQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZSB8IFNUQVRFX0hBU19VUERBVEVEO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RVcGRhdGVkKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21hcmtVcGRhdGVkKCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VkUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZSAmIH5TVEFURV9VUERBVEVfUkVRVUVTVEVEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGNvbXBsZXRlZCB1cGRhdGluZy5cbiAgICAgKiBUaGUgUHJvbWlzZSB2YWx1ZSBpcyBhIGJvb2xlYW4gdGhhdCBpcyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgY29tcGxldGVkIHRoZVxuICAgICAqIHVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW5vdGhlciB1cGRhdGUuIFRoZSBQcm9taXNlIHJlc3VsdCBpcyBgZmFsc2VgIGlmXG4gICAgICogYSBwcm9wZXJ0eSB3YXMgc2V0IGluc2lkZSBgdXBkYXRlZCgpYC4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuXG4gICAgICogZXhjZXB0aW9uIHdhcyB0aHJvd24gZHVyaW5nIHRoZSB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBUbyBhd2FpdCBhZGRpdGlvbmFsIGFzeW5jaHJvbm91cyB3b3JrLCBvdmVycmlkZSB0aGUgYF9nZXRVcGRhdGVDb21wbGV0ZWBcbiAgICAgKiBtZXRob2QuIEZvciBleGFtcGxlLCBpdCBpcyBzb21ldGltZXMgdXNlZnVsIHRvIGF3YWl0IGEgcmVuZGVyZWQgZWxlbWVudFxuICAgICAqIGJlZm9yZSBmdWxmaWxsaW5nIHRoaXMgUHJvbWlzZS4gVG8gZG8gdGhpcywgZmlyc3QgYXdhaXRcbiAgICAgKiBgc3VwZXIuX2dldFVwZGF0ZUNvbXBsZXRlKClgLCB0aGVuIGFueSBzdWJzZXF1ZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHJldHVybnMgYSBib29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHRoZVxuICAgICAqIHVwZGF0ZSByZXNvbHZlZCB3aXRob3V0IHRyaWdnZXJpbmcgYW5vdGhlciB1cGRhdGUuXG4gICAgICovXG4gICAgZ2V0IHVwZGF0ZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIHRoZSBgdXBkYXRlQ29tcGxldGVgIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBJdCBpcyBub3Qgc2FmZSB0byBvdmVycmlkZSB0aGUgYHVwZGF0ZUNvbXBsZXRlYCBnZXR0ZXIgZGlyZWN0bHkgZHVlIHRvIGFcbiAgICAgKiBsaW1pdGF0aW9uIGluIFR5cGVTY3JpcHQgd2hpY2ggbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGNhbGwgYVxuICAgICAqIHN1cGVyY2xhc3MgZ2V0dGVyIChlLmcuIGBzdXBlci51cGRhdGVDb21wbGV0ZS50aGVuKC4uLilgKSB3aGVuIHRoZSB0YXJnZXRcbiAgICAgKiBsYW5ndWFnZSBpcyBFUzUgKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzM4KS5cbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbnN0ZWFkLiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgICogICAgIGFzeW5jIF9nZXRVcGRhdGVDb21wbGV0ZSgpIHtcbiAgICAgKiAgICAgICBhd2FpdCBzdXBlci5fZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICAgKiAgICAgICBhd2FpdCB0aGlzLl9teUNoaWxkLnVwZGF0ZUNvbXBsZXRlO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICovXG4gICAgX2dldFVwZGF0ZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hldGhlciBvciBub3QgYHVwZGF0ZWAgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBlbGVtZW50IHJlcXVlc3RzXG4gICAgICogYW4gdXBkYXRlLiBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAsIGJ1dCB0aGlzIGNhbiBiZVxuICAgICAqIGN1c3RvbWl6ZWQgdG8gY29udHJvbCB3aGVuIHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqL1xuICAgIHNob3VsZFVwZGF0ZShfY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGVsZW1lbnQuIFRoaXMgbWV0aG9kIHJlZmxlY3RzIHByb3BlcnR5IHZhbHVlcyB0byBhdHRyaWJ1dGVzLlxuICAgICAqIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIHJlbmRlciBhbmQga2VlcCB1cGRhdGVkIGVsZW1lbnQgRE9NLlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCAqbm90KiB0cmlnZ2VyXG4gICAgICogYW5vdGhlciB1cGRhdGUuXG4gICAgICpcbiAgICAgKiAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKi9cbiAgICB1cGRhdGUoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcy5zaXplID4gMCkge1xuICAgICAgICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yXG4gICAgICAgICAgICAvLyBsb29wcyBleHBlY3RpbmcgYXJyYXlzXG4gICAgICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcy5mb3JFYWNoKCh2LCBrKSA9PiB0aGlzLl9wcm9wZXJ0eVRvQXR0cmlidXRlKGssIHRoaXNba10sIHYpKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbmV2ZXIgdGhlIGVsZW1lbnQgaXMgdXBkYXRlZC4gSW1wbGVtZW50IHRvIHBlcmZvcm1cbiAgICAgKiBwb3N0LXVwZGF0aW5nIHRhc2tzIHZpYSBET00gQVBJcywgZm9yIGV4YW1wbGUsIGZvY3VzaW5nIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHByb3BlcnRpZXMgaW5zaWRlIHRoaXMgbWV0aG9kIHdpbGwgdHJpZ2dlciB0aGUgZWxlbWVudCB0byB1cGRhdGVcbiAgICAgKiBhZ2FpbiBhZnRlciB0aGlzIHVwZGF0ZSBjeWNsZSBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVkKF9jaGFuZ2VkUHJvcGVydGllcykge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGVsZW1lbnQgaXMgZmlyc3QgdXBkYXRlZC4gSW1wbGVtZW50IHRvIHBlcmZvcm0gb25lIHRpbWVcbiAgICAgKiB3b3JrIG9uIHRoZSBlbGVtZW50IGFmdGVyIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCB0cmlnZ2VyIHRoZSBlbGVtZW50IHRvIHVwZGF0ZVxuICAgICAqIGFnYWluIGFmdGVyIHRoaXMgdXBkYXRlIGN5Y2xlIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqL1xuICAgIGZpcnN0VXBkYXRlZChfY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICB9XG59XG5fYSA9IGZpbmFsaXplZDtcbi8qKlxuICogTWFya3MgY2xhc3MgYXMgaGF2aW5nIGZpbmlzaGVkIGNyZWF0aW5nIHByb3BlcnRpZXMuXG4gKi9cblVwZGF0aW5nRWxlbWVudFtfYV0gPSB0cnVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRpbmctZWxlbWVudC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5jb25zdCBsZWdhY3lDdXN0b21FbGVtZW50ID0gKHRhZ05hbWUsIGNsYXp6KSA9PiB7XG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBjbGF6eik7XG4gICAgLy8gQ2FzdCBhcyBhbnkgYmVjYXVzZSBUUyBkb2Vzbid0IHJlY29nbml6ZSB0aGUgcmV0dXJuIHR5cGUgYXMgYmVpbmcgYVxuICAgIC8vIHN1YnR5cGUgb2YgdGhlIGRlY29yYXRlZCBjbGFzcyB3aGVuIGNsYXp6IGlzIHR5cGVkIGFzXG4gICAgLy8gYENvbnN0cnVjdG9yPEhUTUxFbGVtZW50PmAgZm9yIHNvbWUgcmVhc29uLlxuICAgIC8vIGBDb25zdHJ1Y3RvcjxIVE1MRWxlbWVudD5gIGlzIGhlbHBmdWwgdG8gbWFrZSBzdXJlIHRoZSBkZWNvcmF0b3IgaXNcbiAgICAvLyBhcHBsaWVkIHRvIGVsZW1lbnRzIGhvd2V2ZXIuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHJldHVybiBjbGF6ejtcbn07XG5jb25zdCBzdGFuZGFyZEN1c3RvbUVsZW1lbnQgPSAodGFnTmFtZSwgZGVzY3JpcHRvcikgPT4ge1xuICAgIGNvbnN0IHsga2luZCwgZWxlbWVudHMgfSA9IGRlc2NyaXB0b3I7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIG9uY2UgdGhlIGNsYXNzIGlzIG90aGVyd2lzZSBmdWxseSBkZWZpbmVkXG4gICAgICAgIGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIGNsYXp6KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBDbGFzcyBkZWNvcmF0b3IgZmFjdG9yeSB0aGF0IGRlZmluZXMgdGhlIGRlY29yYXRlZCBjbGFzcyBhcyBhIGN1c3RvbSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB0YWdOYW1lIHRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZWxlbWVudCB0byBkZWZpbmVcbiAqL1xuZXhwb3J0IGNvbnN0IGN1c3RvbUVsZW1lbnQgPSAodGFnTmFtZSkgPT4gKGNsYXNzT3JEZXNjcmlwdG9yKSA9PiAodHlwZW9mIGNsYXNzT3JEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSA/XG4gICAgbGVnYWN5Q3VzdG9tRWxlbWVudCh0YWdOYW1lLCBjbGFzc09yRGVzY3JpcHRvcikgOlxuICAgIHN0YW5kYXJkQ3VzdG9tRWxlbWVudCh0YWdOYW1lLCBjbGFzc09yRGVzY3JpcHRvcik7XG5jb25zdCBzdGFuZGFyZFByb3BlcnR5ID0gKG9wdGlvbnMsIGVsZW1lbnQpID0+IHtcbiAgICAvLyBXaGVuIGRlY29yYXRpbmcgYW4gYWNjZXNzb3IsIHBhc3MgaXQgdGhyb3VnaCBhbmQgYWRkIHByb3BlcnR5IG1ldGFkYXRhLlxuICAgIC8vIE5vdGUsIHRoZSBgaGFzT3duUHJvcGVydHlgIGNoZWNrIGluIGBjcmVhdGVQcm9wZXJ0eWAgZW5zdXJlcyB3ZSBkb24ndFxuICAgIC8vIHN0b21wIG92ZXIgdGhlIHVzZXIncyBhY2Nlc3Nvci5cbiAgICBpZiAoZWxlbWVudC5raW5kID09PSAnbWV0aG9kJyAmJiBlbGVtZW50LmRlc2NyaXB0b3IgJiZcbiAgICAgICAgISgndmFsdWUnIGluIGVsZW1lbnQuZGVzY3JpcHRvcikpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnQsIHsgZmluaXNoZXIoY2xhenopIHtcbiAgICAgICAgICAgICAgICBjbGF6ei5jcmVhdGVQcm9wZXJ0eShlbGVtZW50LmtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlUHJvcGVydHkoKSB0YWtlcyBjYXJlIG9mIGRlZmluaW5nIHRoZSBwcm9wZXJ0eSwgYnV0IHdlIHN0aWxsXG4gICAgICAgIC8vIG11c3QgcmV0dXJuIHNvbWUga2luZCBvZiBkZXNjcmlwdG9yLCBzbyByZXR1cm4gYSBkZXNjcmlwdG9yIGZvciBhblxuICAgICAgICAvLyB1bnVzZWQgcHJvdG90eXBlIGZpZWxkLiBUaGUgZmluaXNoZXIgY2FsbHMgY3JlYXRlUHJvcGVydHkoKS5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdmaWVsZCcsXG4gICAgICAgICAgICBrZXk6IFN5bWJvbCgpLFxuICAgICAgICAgICAgcGxhY2VtZW50OiAnb3duJyxcbiAgICAgICAgICAgIGRlc2NyaXB0b3I6IHt9LFxuICAgICAgICAgICAgLy8gV2hlbiBAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLWRlY29yYXRvcnMgaW1wbGVtZW50cyBpbml0aWFsaXplcnMsXG4gICAgICAgICAgICAvLyBkbyB0aGlzIGluc3RlYWQgb2YgdGhlIGluaXRpYWxpemVyIGJlbG93LiBTZWU6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzkyNjAgZXh0cmFzOiBbXG4gICAgICAgICAgICAvLyAgIHtcbiAgICAgICAgICAgIC8vICAgICBraW5kOiAnaW5pdGlhbGl6ZXInLFxuICAgICAgICAgICAgLy8gICAgIHBsYWNlbWVudDogJ293bicsXG4gICAgICAgICAgICAvLyAgICAgaW5pdGlhbGl6ZXI6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIsXG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIF0sXG4gICAgICAgICAgICBpbml0aWFsaXplcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tlbGVtZW50LmtleV0gPSBlbGVtZW50LmluaXRpYWxpemVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICAgICAgY2xhenouY3JlYXRlUHJvcGVydHkoZWxlbWVudC5rZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBsZWdhY3lQcm9wZXJ0eSA9IChvcHRpb25zLCBwcm90bywgbmFtZSkgPT4ge1xuICAgIHByb3RvLmNvbnN0cnVjdG9yXG4gICAgICAgIC5jcmVhdGVQcm9wZXJ0eShuYW1lLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIEEgcHJvcGVydHkgZGVjb3JhdG9yIHdoaWNoIGNyZWF0ZXMgYSBMaXRFbGVtZW50IHByb3BlcnR5IHdoaWNoIHJlZmxlY3RzIGFcbiAqIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIHZhbHVlLiBBIGBQcm9wZXJ0eURlY2xhcmF0aW9uYCBtYXkgb3B0aW9uYWxseSBiZVxuICogc3VwcGxpZWQgdG8gY29uZmlndXJlIHByb3BlcnR5IGZlYXR1cmVzLlxuICpcbiAqIEBFeHBvcnREZWNvcmF0ZWRJdGVtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHkob3B0aW9ucykge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgZGVjb3JhdG9yXG4gICAgcmV0dXJuIChwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgPT4gKG5hbWUgIT09IHVuZGVmaW5lZCkgP1xuICAgICAgICBsZWdhY3lQcm9wZXJ0eShvcHRpb25zLCBwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgOlxuICAgICAgICBzdGFuZGFyZFByb3BlcnR5KG9wdGlvbnMsIHByb3RvT3JEZXNjcmlwdG9yKTtcbn1cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXIgdGhhdFxuICogZXhlY3V0ZXMgYSBxdWVyeVNlbGVjdG9yIG9uIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdC5cbiAqXG4gKiBARXhwb3J0RGVjb3JhdGVkSXRlbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChwcm90b09yRGVzY3JpcHRvciwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBkZWNvcmF0b3JcbiAgICBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKG5hbWUgIT09IHVuZGVmaW5lZCkgP1xuICAgICAgICAgICAgbGVnYWN5UXVlcnkoZGVzY3JpcHRvciwgcHJvdG9PckRlc2NyaXB0b3IsIG5hbWUpIDpcbiAgICAgICAgICAgIHN0YW5kYXJkUXVlcnkoZGVzY3JpcHRvciwgcHJvdG9PckRlc2NyaXB0b3IpO1xuICAgIH07XG59XG4vKipcbiAqIEEgcHJvcGVydHkgZGVjb3JhdG9yIHRoYXQgY29udmVydHMgYSBjbGFzcyBwcm9wZXJ0eSBpbnRvIGEgZ2V0dGVyXG4gKiB0aGF0IGV4ZWN1dGVzIGEgcXVlcnlTZWxlY3RvckFsbCBvbiB0aGUgZWxlbWVudCdzIHJlbmRlclJvb3QuXG4gKlxuICogQEV4cG9ydERlY29yYXRlZEl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiAocHJvdG9PckRlc2NyaXB0b3IsIFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgZGVjb3JhdG9yXG4gICAgbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChuYW1lICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgIGxlZ2FjeVF1ZXJ5KGRlc2NyaXB0b3IsIHByb3RvT3JEZXNjcmlwdG9yLCBuYW1lKSA6XG4gICAgICAgICAgICBzdGFuZGFyZFF1ZXJ5KGRlc2NyaXB0b3IsIHByb3RvT3JEZXNjcmlwdG9yKTtcbiAgICB9O1xufVxuY29uc3QgbGVnYWN5UXVlcnkgPSAoZGVzY3JpcHRvciwgcHJvdG8sIG5hbWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIGRlc2NyaXB0b3IpO1xufTtcbmNvbnN0IHN0YW5kYXJkUXVlcnkgPSAoZGVzY3JpcHRvciwgZWxlbWVudCkgPT4gKHtcbiAgICBraW5kOiAnbWV0aG9kJyxcbiAgICBwbGFjZW1lbnQ6ICdwcm90b3R5cGUnLFxuICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgZGVzY3JpcHRvcixcbn0pO1xuY29uc3Qgc3RhbmRhcmRFdmVudE9wdGlvbnMgPSAob3B0aW9ucywgZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBlbGVtZW50LCB7IGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNsYXp6LnByb3RvdHlwZVtlbGVtZW50LmtleV0sIG9wdGlvbnMpO1xuICAgICAgICB9IH0pO1xufTtcbmNvbnN0IGxlZ2FjeUV2ZW50T3B0aW9ucyA9IFxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBsZWdhY3kgZGVjb3JhdG9yXG4ob3B0aW9ucywgcHJvdG8sIG5hbWUpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKHByb3RvW25hbWVdLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgb3B0aW9ucyB0byBhIG1ldGhvZCB1c2VkIGFzIGFuIGV2ZW50IGxpc3RlbmVyIGluIGFcbiAqIGxpdC1odG1sIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCB0aGF0IHNwZWNpZmlzIGV2ZW50IGxpc3RlbmVyIG9wdGlvbnMgYXMgYWNjZXB0ZWQgYnlcbiAqIGBFdmVudFRhcmdldCNhZGRFdmVudExpc3RlbmVyYCBhbmQgYEV2ZW50VGFyZ2V0I3JlbW92ZUV2ZW50TGlzdGVuZXJgLlxuICpcbiAqIEN1cnJlbnQgYnJvd3NlcnMgc3VwcG9ydCB0aGUgYGNhcHR1cmVgLCBgcGFzc2l2ZWAsIGFuZCBgb25jZWAgb3B0aW9ucy4gU2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjUGFyYW1ldGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIGNsYXNzIE15RWxlbWVudCB7XG4gKlxuICogICAgICAgY2xpY2tlZCA9IGZhbHNlO1xuICpcbiAqICAgICAgIHJlbmRlcigpIHtcbiAqICAgICAgICAgcmV0dXJuIGh0bWxgPGRpdiBAY2xpY2s9JHt0aGlzLl9vbkNsaWNrfWA+PGJ1dHRvbj48L2J1dHRvbj48L2Rpdj5gO1xuICogICAgICAgfVxuICpcbiAqICAgICAgIEBldmVudE9wdGlvbnMoe2NhcHR1cmU6IHRydWV9KVxuICogICAgICAgX29uQ2xpY2soZSkge1xuICogICAgICAgICB0aGlzLmNsaWNrZWQgPSB0cnVlO1xuICogICAgICAgfVxuICogICAgIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGV2ZW50T3B0aW9ucyA9IChvcHRpb25zKSA9PiBcbi8vIFJldHVybiB2YWx1ZSB0eXBlZCBhcyBhbnkgdG8gcHJldmVudCBUeXBlU2NyaXB0IGZyb20gY29tcGxhaW5pbmcgdGhhdFxuLy8gc3RhbmRhcmQgZGVjb3JhdG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBUeXBlU2NyaXB0IGRlY29yYXRvclxuLy8gc2lnbmF0dXJlXG4vLyBUT0RPKGtzY2hhYWYpOiB1bmNsZWFyIHdoeSBpdCB3YXMgb25seSBmYWlsaW5nIG9uIHRoaXMgZGVjb3JhdG9yIGFuZCBub3Rcbi8vIHRoZSBvdGhlcnNcbigocHJvdG9PckRlc2NyaXB0b3IsIG5hbWUpID0+IChuYW1lICE9PSB1bmRlZmluZWQpID9cbiAgICBsZWdhY3lFdmVudE9wdGlvbnMob3B0aW9ucywgcHJvdG9PckRlc2NyaXB0b3IsIG5hbWUpIDpcbiAgICBzdGFuZGFyZEV2ZW50T3B0aW9ucyhvcHRpb25zLCBwcm90b09yRGVzY3JpcHRvcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb3JhdG9ycy5qcy5tYXAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTkgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZVxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQgQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXNcbnBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnRcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMgPSAoJ2Fkb3B0ZWRTdHlsZVNoZWV0cycgaW4gRG9jdW1lbnQucHJvdG90eXBlKSAmJlxuICAgICgncmVwbGFjZScgaW4gQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUpO1xuY29uc3QgY29uc3RydWN0aW9uVG9rZW4gPSBTeW1ib2woKTtcbmV4cG9ydCBjbGFzcyBDU1NSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKGNzc1RleHQsIHNhZmVUb2tlbikge1xuICAgICAgICBpZiAoc2FmZVRva2VuICE9PSBjb25zdHJ1Y3Rpb25Ub2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1NSZXN1bHQgaXMgbm90IGNvbnN0cnVjdGFibGUuIFVzZSBgdW5zYWZlQ1NTYCBvciBgY3NzYCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgfVxuICAgIC8vIE5vdGUsIHRoaXMgaXMgYSBnZXR0ZXIgc28gdGhhdCBpdCdzIGxhenkuIEluIHByYWN0aWNlLCB0aGlzIG1lYW5zXG4gICAgLy8gc3R5bGVzaGVldHMgYXJlIG5vdCBjcmVhdGVkIHVudGlsIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlIGlzIG1hZGUuXG4gICAgZ2V0IHN0eWxlU2hlZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZVNoZWV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5vdGUsIGlmIGBhZG9wdGVkU3R5bGVTaGVldHNgIGlzIHN1cHBvcnRlZCB0aGVuIHdlIGFzc3VtZSBDU1NTdHlsZVNoZWV0XG4gICAgICAgICAgICAvLyBpcyBjb25zdHJ1Y3RhYmxlLlxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlU2hlZXQgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlU2hlZXQucmVwbGFjZVN5bmModGhpcy5jc3NUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlU2hlZXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZVNoZWV0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzVGV4dDtcbiAgICB9XG59XG4vKipcbiAqIFdyYXAgYSB2YWx1ZSBmb3IgaW50ZXJwb2xhdGlvbiBpbiBhIGNzcyB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqXG4gKiBUaGlzIGlzIHVuc2FmZSBiZWNhdXNlIHVudHJ1c3RlZCBDU1MgdGV4dCBjYW4gYmUgdXNlZCB0byBwaG9uZSBob21lXG4gKiBvciBleGZpbHRyYXRlIGRhdGEgdG8gYW4gYXR0YWNrZXIgY29udHJvbGxlZCBzaXRlLiBUYWtlIGNhcmUgdG8gb25seSB1c2VcbiAqIHRoaXMgd2l0aCB0cnVzdGVkIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgdW5zYWZlQ1NTID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBDU1NSZXN1bHQoU3RyaW5nKHZhbHVlKSwgY29uc3RydWN0aW9uVG9rZW4pO1xufTtcbmNvbnN0IHRleHRGcm9tQ1NTUmVzdWx0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ1NTUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5jc3NUZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgcGFzc2VkIHRvICdjc3MnIGZ1bmN0aW9uIG11c3QgYmUgYSAnY3NzJyBmdW5jdGlvbiByZXN1bHQ6ICR7dmFsdWV9LiBVc2UgJ3Vuc2FmZUNTUycgdG8gcGFzcyBub24tbGl0ZXJhbCB2YWx1ZXMsIGJ1dFxuICAgICAgICAgICAgdGFrZSBjYXJlIHRvIGVuc3VyZSBwYWdlIHNlY3VyaXR5LmApO1xuICAgIH1cbn07XG4vKipcbiAqIFRlbXBsYXRlIHRhZyB3aGljaCB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIExpdEVsZW1lbnQncyBgc3R5bGVgIHByb3BlcnR5IHRvXG4gKiBzZXQgZWxlbWVudCBzdHlsZXMuIEZvciBzZWN1cml0eSByZWFzb25zLCBvbmx5IGxpdGVyYWwgc3RyaW5nIHZhbHVlcyBtYXkgYmVcbiAqIHVzZWQuIFRvIGluY29ycG9yYXRlIG5vbi1saXRlcmFsIHZhbHVlcyBgdW5zYWZlQ1NTYCBtYXkgYmUgdXNlZCBpbnNpZGUgYVxuICogdGVtcGxhdGUgc3RyaW5nIHBhcnQuXG4gKi9cbmV4cG9ydCBjb25zdCBjc3MgPSAoc3RyaW5ncywgLi4udmFsdWVzKSA9PiB7XG4gICAgY29uc3QgY3NzVGV4dCA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgdiwgaWR4KSA9PiBhY2MgKyB0ZXh0RnJvbUNTU1Jlc3VsdCh2KSArIHN0cmluZ3NbaWR4ICsgMV0sIHN0cmluZ3NbMF0pO1xuICAgIHJldHVybiBuZXcgQ1NTUmVzdWx0KGNzc1RleHQsIGNvbnN0cnVjdGlvblRva2VuKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtdGFnLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnbGl0LWh0bWwnO1xuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAnbGl0LWh0bWwvbGliL3NoYWR5LXJlbmRlci5qcyc7XG5pbXBvcnQgeyBVcGRhdGluZ0VsZW1lbnQgfSBmcm9tICcuL2xpYi91cGRhdGluZy1lbGVtZW50LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3VwZGF0aW5nLWVsZW1lbnQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZGVjb3JhdG9ycy5qcyc7XG5leHBvcnQgeyBodG1sLCBzdmcsIFRlbXBsYXRlUmVzdWx0LCBTVkdUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJ2xpdC1odG1sL2xpdC1odG1sLmpzJztcbmltcG9ydCB7IHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cyB9IGZyb20gJy4vbGliL2Nzcy10YWcuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvY3NzLXRhZy5qcyc7XG4vLyBJTVBPUlRBTlQ6IGRvIG5vdCBjaGFuZ2UgdGhlIHByb3BlcnR5IG5hbWUgb3IgdGhlIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbi8vIFRoaXMgbGluZSB3aWxsIGJlIHVzZWQgaW4gcmVnZXhlcyB0byBzZWFyY2ggZm9yIExpdEVsZW1lbnQgdXNhZ2UuXG4vLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiBpbmplY3QgdmVyc2lvbiBudW1iZXIgYXQgYnVpbGQgdGltZVxuKHdpbmRvd1snbGl0RWxlbWVudFZlcnNpb25zJ10gfHwgKHdpbmRvd1snbGl0RWxlbWVudFZlcnNpb25zJ10gPSBbXSkpXG4gICAgLnB1c2goJzIuMi4xJyk7XG4vKipcbiAqIE1pbmltYWwgaW1wbGVtZW50YXRpb24gb2YgQXJyYXkucHJvdG90eXBlLmZsYXRcbiAqIEBwYXJhbSBhcnIgdGhlIGFycmF5IHRvIGZsYXR0ZW5cbiAqIEBwYXJhbSByZXN1bHQgdGhlIGFjY3VtbGF0ZWQgcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFycmF5RmxhdChzdHlsZXMsIHJlc3VsdCA9IFtdKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHN0eWxlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1tpXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBhcnJheUZsYXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBEZWVwbHkgZmxhdHRlbnMgc3R5bGVzIGFycmF5LiBVc2VzIG5hdGl2ZSBmbGF0IGlmIGF2YWlsYWJsZS4gKi9cbmNvbnN0IGZsYXR0ZW5TdHlsZXMgPSAoc3R5bGVzKSA9PiBzdHlsZXMuZmxhdCA/IHN0eWxlcy5mbGF0KEluZmluaXR5KSA6IGFycmF5RmxhdChzdHlsZXMpO1xuZXhwb3J0IGNsYXNzIExpdEVsZW1lbnQgZXh0ZW5kcyBVcGRhdGluZ0VsZW1lbnQge1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIHN0YXRpYyBmaW5hbGl6ZSgpIHtcbiAgICAgICAgLy8gVGhlIENsb3N1cmUgSlMgQ29tcGlsZXIgZG9lcyBub3QgYWx3YXlzIHByZXNlcnZlIHRoZSBjb3JyZWN0IFwidGhpc1wiXG4gICAgICAgIC8vIHdoZW4gY2FsbGluZyBzdGF0aWMgc3VwZXIgbWV0aG9kcyAoYi8xMzc0NjAyNDMpLCBzbyBleHBsaWNpdGx5IGJpbmQuXG4gICAgICAgIHN1cGVyLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIFByZXBhcmUgc3R5bGluZyB0aGF0IGlzIHN0YW1wZWQgYXQgZmlyc3QgcmVuZGVyIHRpbWUuIFN0eWxpbmdcbiAgICAgICAgLy8gaXMgYnVpbHQgZnJvbSB1c2VyIHByb3ZpZGVkIGBzdHlsZXNgIG9yIGlzIGluaGVyaXRlZCBmcm9tIHRoZSBzdXBlcmNsYXNzLlxuICAgICAgICB0aGlzLl9zdHlsZXMgPVxuICAgICAgICAgICAgdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdzdHlsZXMnLCB0aGlzKSkgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldFVuaXF1ZVN0eWxlcygpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMgfHwgW107XG4gICAgfVxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIHN0YXRpYyBfZ2V0VW5pcXVlU3R5bGVzKCkge1xuICAgICAgICAvLyBUYWtlIGNhcmUgbm90IHRvIGNhbGwgYHRoaXMuc3R5bGVzYCBtdWx0aXBsZSB0aW1lcyBzaW5jZSB0aGlzIGdlbmVyYXRlc1xuICAgICAgICAvLyBuZXcgQ1NTUmVzdWx0cyBlYWNoIHRpbWUuXG4gICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IFNpbmNlIHdlIGRvIG5vdCBjYWNoZSBDU1NSZXN1bHRzIGJ5IGlucHV0LCBhbnlcbiAgICAgICAgLy8gc2hhcmVkIHN0eWxlcyB3aWxsIGdlbmVyYXRlIG5ldyBzdHlsZXNoZWV0IG9iamVjdHMsIHdoaWNoIGlzIHdhc3RlZnVsLlxuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhZGRyZXNzZWQgd2hlbiBhIGJyb3dzZXIgc2hpcHMgY29uc3RydWN0YWJsZVxuICAgICAgICAvLyBzdHlsZXNoZWV0cy5cbiAgICAgICAgY29uc3QgdXNlclN0eWxlcyA9IHRoaXMuc3R5bGVzO1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXNlclN0eWxlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYXRTdHlsZXMgPSBmbGF0dGVuU3R5bGVzKHVzZXJTdHlsZXMpO1xuICAgICAgICAgICAgLy8gQXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgZHVwbGljYXRlZCBzdHlsaW5nIHRoYXQgY2FuXG4gICAgICAgICAgICAvLyBvY2N1ciBlc3BlY2lhbGx5IHdoZW4gY29tcG9zaW5nIHZpYSBzdWJjbGFzc2luZywgZGUtZHVwbGljYXRlIHN0eWxlc1xuICAgICAgICAgICAgLy8gcHJlc2VydmluZyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0LiBUaGUgbGFzdCBpdGVtIGlzIGtlcHQgdG9cbiAgICAgICAgICAgIC8vIHRyeSB0byBwcmVzZXJ2ZSBjYXNjYWRlIG9yZGVyIHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCBpdCdzIG1vc3RcbiAgICAgICAgICAgIC8vIGltcG9ydGFudCB0aGF0IGxhc3QgYWRkZWQgc3R5bGVzIG92ZXJyaWRlIHByZXZpb3VzIHN0eWxlcy5cbiAgICAgICAgICAgIGNvbnN0IHN0eWxlU2V0ID0gZmxhdFN0eWxlcy5yZWR1Y2VSaWdodCgoc2V0LCBzKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0LmFkZChzKTtcbiAgICAgICAgICAgICAgICAvLyBvbiBJRSBzZXQuYWRkIGRvZXMgbm90IHJldHVybiB0aGUgc2V0LlxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9LCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgLy8gQXJyYXkuZnJvbSBkb2VzIG5vdCB3b3JrIG9uIFNldCBpbiBJRVxuICAgICAgICAgICAgc3R5bGVTZXQuZm9yRWFjaCgodikgPT4gc3R5bGVzLnVuc2hpZnQodikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVzZXJTdHlsZXMpIHtcbiAgICAgICAgICAgIHN0eWxlcy5wdXNoKHVzZXJTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGVsZW1lbnQgaW5pdGlhbGl6YXRpb24uIEJ5IGRlZmF1bHQgdGhpcyBjYWxscyBgY3JlYXRlUmVuZGVyUm9vdGBcbiAgICAgKiB0byBjcmVhdGUgdGhlIGVsZW1lbnQgYHJlbmRlclJvb3RgIG5vZGUgYW5kIGNhcHR1cmVzIGFueSBwcmUtc2V0IHZhbHVlcyBmb3JcbiAgICAgKiByZWdpc3RlcmVkIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLnJlbmRlclJvb3QgPVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVSZW5kZXJSb290KCk7XG4gICAgICAgIC8vIE5vdGUsIGlmIHJlbmRlclJvb3QgaXMgbm90IGEgc2hhZG93Um9vdCwgc3R5bGVzIHdvdWxkL2NvdWxkIGFwcGx5IHRvIHRoZVxuICAgICAgICAvLyBlbGVtZW50J3MgZ2V0Um9vdE5vZGUoKS4gV2hpbGUgdGhpcyBjb3VsZCBiZSBkb25lLCB3ZSdyZSBjaG9vc2luZyBub3QgdG9cbiAgICAgICAgLy8gc3VwcG9ydCB0aGlzIG5vdyBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIGRpZmZlcmVudCBsb2dpYyBhcm91bmQgZGUtZHVwaW5nLlxuICAgICAgICBpZiAod2luZG93LlNoYWRvd1Jvb3QgJiYgdGhpcy5yZW5kZXJSb290IGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuYWRvcHRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBub2RlIGludG8gd2hpY2ggdGhlIGVsZW1lbnQgc2hvdWxkIHJlbmRlciBhbmQgYnkgZGVmYXVsdFxuICAgICAqIGNyZWF0ZXMgYW5kIHJldHVybnMgYW4gb3BlbiBzaGFkb3dSb290LiBJbXBsZW1lbnQgdG8gY3VzdG9taXplIHdoZXJlIHRoZVxuICAgICAqIGVsZW1lbnQncyBET00gaXMgcmVuZGVyZWQuIEZvciBleGFtcGxlLCB0byByZW5kZXIgaW50byB0aGUgZWxlbWVudCdzXG4gICAgICogY2hpbGROb2RlcywgcmV0dXJuIGB0aGlzYC5cbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBSZXR1cm5zIGEgbm9kZSBpbnRvIHdoaWNoIHRvIHJlbmRlci5cbiAgICAgKi9cbiAgICBjcmVhdGVSZW5kZXJSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgc3R5bGluZyB0byB0aGUgZWxlbWVudCBzaGFkb3dSb290IHVzaW5nIHRoZSBgc3RhdGljIGdldCBzdHlsZXNgXG4gICAgICogcHJvcGVydHkuIFN0eWxpbmcgd2lsbCBhcHBseSB1c2luZyBgc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHNgIHdoZXJlXG4gICAgICogYXZhaWxhYmxlIGFuZCB3aWxsIGZhbGxiYWNrIG90aGVyd2lzZS4gV2hlbiBTaGFkb3cgRE9NIGlzIHBvbHlmaWxsZWQsXG4gICAgICogU2hhZHlDU1Mgc2NvcGVzIHN0eWxlcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBkb2N1bWVudC4gV2hlbiBTaGFkb3cgRE9NXG4gICAgICogaXMgYXZhaWxhYmxlIGJ1dCBgYWRvcHRlZFN0eWxlU2hlZXRzYCBpcyBub3QsIHN0eWxlcyBhcmUgYXBwZW5kZWQgdG8gdGhlXG4gICAgICogZW5kIG9mIHRoZSBgc2hhZG93Um9vdGAgdG8gW21pbWljIHNwZWNcbiAgICAgKiBiZWhhdmlvcl0oaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb25zdHJ1Y3Qtc3R5bGVzaGVldHMvI3VzaW5nLWNvbnN0cnVjdGVkLXN0eWxlc2hlZXRzKS5cbiAgICAgKi9cbiAgICBhZG9wdFN0eWxlcygpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5fc3R5bGVzO1xuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBzZXBhcmF0ZSBjYXNlcyBoZXJlIGJhc2VkIG9uIFNoYWRvdyBET00gc3VwcG9ydC5cbiAgICAgICAgLy8gKDEpIHNoYWRvd1Jvb3QgcG9seWZpbGxlZDogdXNlIFNoYWR5Q1NTXG4gICAgICAgIC8vICgyKSBzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyBhdmFpbGFibGU6IHVzZSBpdC5cbiAgICAgICAgLy8gKDMpIHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzIHBvbHlmaWxsZWQ6IGFwcGVuZCBzdHlsZXMgYWZ0ZXJcbiAgICAgICAgLy8gcmVuZGVyaW5nXG4gICAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgIT09IHVuZGVmaW5lZCAmJiAhd2luZG93LlNoYWR5Q1NTLm5hdGl2ZVNoYWRvdykge1xuICAgICAgICAgICAgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltLnByZXBhcmVBZG9wdGVkQ3NzVGV4dChzdHlsZXMubWFwKChzKSA9PiBzLmNzc1RleHQpLCB0aGlzLmxvY2FsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID1cbiAgICAgICAgICAgICAgICBzdHlsZXMubWFwKChzKSA9PiBzLnN0eWxlU2hlZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgcmVuZGVyaW5nIHNvIHRoZSBhY3R1YWwgc3R5bGUgaW5zZXJ0aW9uIGlzIGRvbmVcbiAgICAgICAgICAgIC8vIGluIGB1cGRhdGVgLlxuICAgICAgICAgICAgdGhpcy5fbmVlZHNTaGltQWRvcHRlZFN0eWxlU2hlZXRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgLy8gTm90ZSwgZmlyc3QgdXBkYXRlL3JlbmRlciBoYW5kbGVzIHN0eWxlRWxlbWVudCBzbyB3ZSBvbmx5IGNhbGwgdGhpcyBpZlxuICAgICAgICAvLyBjb25uZWN0ZWQgYWZ0ZXIgZmlyc3QgdXBkYXRlLlxuICAgICAgICBpZiAodGhpcy5oYXNVcGRhdGVkICYmIHdpbmRvdy5TaGFkeUNTUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGVsZW1lbnQuIFRoaXMgbWV0aG9kIHJlZmxlY3RzIHByb3BlcnR5IHZhbHVlcyB0byBhdHRyaWJ1dGVzXG4gICAgICogYW5kIGNhbGxzIGByZW5kZXJgIHRvIHJlbmRlciBET00gdmlhIGxpdC1odG1sLiBTZXR0aW5nIHByb3BlcnRpZXMgaW5zaWRlXG4gICAgICogdGhpcyBtZXRob2Qgd2lsbCAqbm90KiB0cmlnZ2VyIGFub3RoZXIgdXBkYXRlLlxuICAgICAqICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqL1xuICAgIHVwZGF0ZShjaGFuZ2VkUHJvcGVydGllcykge1xuICAgICAgICBzdXBlci51cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVJlc3VsdCA9IHRoaXMucmVuZGVyKCk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZVJlc3VsdCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgLnJlbmRlcih0ZW1wbGF0ZVJlc3VsdCwgdGhpcy5yZW5kZXJSb290LCB7IHNjb3BlTmFtZTogdGhpcy5sb2NhbE5hbWUsIGV2ZW50Q29udGV4dDogdGhpcyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIG5hdGl2ZSBTaGFkb3cgRE9NIGlzIHVzZWQgYnV0IGFkb3B0ZWRTdHlsZXMgYXJlIG5vdCBzdXBwb3J0ZWQsXG4gICAgICAgIC8vIGluc2VydCBzdHlsaW5nIGFmdGVyIHJlbmRlcmluZyB0byBlbnN1cmUgYWRvcHRlZFN0eWxlcyBoYXZlIGhpZ2hlc3RcbiAgICAgICAgLy8gcHJpb3JpdHkuXG4gICAgICAgIGlmICh0aGlzLl9uZWVkc1NoaW1BZG9wdGVkU3R5bGVTaGVldHMpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzU2hpbUFkb3B0ZWRTdHlsZVNoZWV0cyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fc3R5bGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzLmNzc1RleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSb290LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gZWFjaCB1cGRhdGUgdG8gcGVyZm9ybSByZW5kZXJpbmcgdGFza3MuIFRoaXMgbWV0aG9kIG11c3QgcmV0dXJuXG4gICAgICogYSBsaXQtaHRtbCBUZW1wbGF0ZVJlc3VsdC4gU2V0dGluZyBwcm9wZXJ0aWVzIGluc2lkZSB0aGlzIG1ldGhvZCB3aWxsICpub3QqXG4gICAgICogdHJpZ2dlciB0aGUgZWxlbWVudCB0byB1cGRhdGUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoaXMgY2xhc3MgaXMgbWFya2VkIGFzIGBmaW5hbGl6ZWRgIGFzIGFuIG9wdGltaXphdGlvbiBlbnN1cmluZ1xuICogaXQgd2lsbCBub3QgbmVlZGxlc3NseSB0cnkgdG8gYGZpbmFsaXplYC5cbiAqXG4gKiBOb3RlIHRoaXMgcHJvcGVydHkgbmFtZSBpcyBhIHN0cmluZyB0byBwcmV2ZW50IGJyZWFraW5nIENsb3N1cmUgSlMgQ29tcGlsZXJcbiAqIG9wdGltaXphdGlvbnMuIFNlZSB1cGRhdGluZy1lbGVtZW50LnRzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5MaXRFbGVtZW50WydmaW5hbGl6ZWQnXSA9IHRydWU7XG4vKipcbiAqIFJlbmRlciBtZXRob2QgdXNlZCB0byByZW5kZXIgdGhlIGxpdC1odG1sIFRlbXBsYXRlUmVzdWx0IHRvIHRoZSBlbGVtZW50J3NcbiAqIERPTS5cbiAqIEBwYXJhbSB7VGVtcGxhdGVSZXN1bHR9IFRlbXBsYXRlIHRvIHJlbmRlci5cbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBOb2RlIGludG8gd2hpY2ggdG8gcmVuZGVyLlxuICogQHBhcmFtIHtTdHJpbmd9IEVsZW1lbnQgbmFtZS5cbiAqIEBub2NvbGxhcHNlXG4gKi9cbkxpdEVsZW1lbnQucmVuZGVyID0gcmVuZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl0LWVsZW1lbnQuanMubWFwIiwiaW1wb3J0ICBldmUgZnJvbSAnZXZlanMvZGlzdC9ldmUuY3VzdG9tLmpzJztcblxuZnVuY3Rpb24gSGVsbG9BZ2VudChpZCl7XG4gIC8vIGV4ZWN1dGUgc3VwZXIgY29uc3RydWN0b3JcbiAgZXZlLkFnZW50LmNhbGwodGhpcywgaWQpO1xuXG4gIC8vIGNvbm5lY3QgdG8gYWxsIHRyYW5zcG9ydHMgY29uZmlndXJlZCBieSB0aGUgc3lzdGVtXG4gIHRoaXMuY29ubmVjdChldmUuc3lzdGVtLnRyYW5zcG9ydHMuZ2V0QWxsKCkpO1xuXG59XG5cbi8vIGV4dGVuZCB0aGUgZXZlLkFnZW50IHByb3RvdHlwZVxuSGVsbG9BZ2VudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGV2ZS5BZ2VudC5wcm90b3R5cGUpO1xuSGVsbG9BZ2VudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZWxsb0FnZW50O1xuXG5IZWxsb0FnZW50LnByb3RvdHlwZS5zYXlIZWxsbyA9IGZ1bmN0aW9uKHRvKSB7XG4gIHRoaXMuc2VuZCh0bywgJ0hlbGxvICcgKyB0byArICchJyk7XG59O1xuXG5IZWxsb0FnZW50LnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xuICAvL3Nsb2codGhpcy5pZCtcIiByZWNlaXZlZCBmcm9tIDpcIitmcm9tICsgJyB0aGlzIG1lc3NhZ2U6ICcgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG4gIGNvbnNvbGUubG9nKHRoaXMuaWQrXCIgcmVjZWl2ZWQgZnJvbSA6XCIrZnJvbSArICcgdGhpcyBtZXNzYWdlOiAnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuXG4gIGlmIChKU09OLnN0cmluZ2lmeShtZXNzYWdlKS5pbmRleE9mKCdIZWxsbycpID09PSAwKSB7XG4gICAgLy8gcmVwbHkgdG8gdGhlIGdyZWV0aW5nXG4gICAgdGhpcy5zZW5kKGZyb20sICdIaSAnICsgZnJvbSArICcsIG5pY2UgdG8gbWVldCB5b3UhJyk7XG4gIH1cbn07XG5cblxuSGVsbG9BZ2VudC5wcm90b3R5cGUuYnJvYWRjYXN0ID0gZnVuY3Rpb24obWVzc2FnZSl7XG4gIHZhciBtZSA9IHRoaXNcbiAgdmFyIGFsbEFnZW50cyA9IE9iamVjdC5rZXlzKHRoaXMuY29ubmVjdGlvbnNbMF0udHJhbnNwb3J0LmFnZW50cyk7XG4vLyAgY29uc29sZS5sb2coYWxsQWdlbnRzKVxuICBhbGxBZ2VudHMuZm9yRWFjaChmdW5jdGlvbiAoYWdlbnQpe1xuICAgIG1lLnNlbmQoYWdlbnQsIG1lc3NhZ2UpO1xuICB9KVxufVxuXG5IZWxsb0FnZW50LnByb3RvdHlwZS5zZW5kTXVsdGkgPSBmdW5jdGlvbihyZWNpcGllbnRzLCBtZXNzYWdlKXtcbiAgdmFyIG1lID0gdGhpc1xuICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGFnZW50KXtcbiAgLy8gIGNvbnNvbGUubG9nKGFnZW50LCBtZXNzYWdlKVxuICAgIG1lLnNlbmQoYWdlbnQsIG1lc3NhZ2UpO1xuICB9KVxufVxuXG5cbmV4cG9ydCB7SGVsbG9BZ2VudH07XG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xuaW1wb3J0ICogYXMgYXV0aCBmcm9tICdzb2xpZC1hdXRoLWNsaWVudCc7XG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcblxuY2xhc3MgTG9naW5FbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcbiAgICAgIHdlYklkOiB7dHlwZTogU3RyaW5nfSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndlYklkID0gbnVsbFxuICB9XG5cbiAgcmVuZGVyKCl7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgPCEtLSBpZiB0aGlzLndlYklkID09IG51bGwgLCBsb2dpbiBidXR0b24gaXMgZGlhcGxheWVkIC0tPlxuICAgICR7dGhpcy53ZWJJZCA9PSBudWxsID9cbiAgICAgIGh0bWxgXG4gICAgICA8YnV0dG9uIEBjbGljaz0ke3RoaXMubG9naW59PkxvZ2luPC9idXR0b24+XG4gICAgICBgXG4gICAgICA6IGh0bWxgXG4gICAgICA8IS0tIGVsc2UgbG9nb3V0IGJ1dHRvbiBpcyBkaXNwbGF5ZWQgLS0+XG4gICAgICA8YnV0dG9uIEBjbGljaz0ke3RoaXMubG9nb3V0fT5Mb2dvdXQ8L2J1dHRvbj5cbiAgICAgICR7dGhpcy53ZWJJZH1cbiAgICAgIGBcbiAgICB9XG4gICAgYDtcbiAgfVxuXG4gIGZpcnN0VXBkYXRlZCgpe1xuICAgIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xuICAgIGF1dGgudHJhY2tTZXNzaW9uKHNlc3Npb24gPT4ge1xuICAgICAgaWYgKCFzZXNzaW9uKXtcbiAgICAgICAgdGhpcy53ZWJJZD1udWxsXG4gICAgICAgIHRoaXMuYWdlbnQuc2VuZCgnTWVzc2FnZXMnLCAge2FjdGlvbjpcImluZm9cIiwgaW5mbzpcIk5vdCBsb2dnZWRcIn0pO1xuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgdGhpcy53ZWJJZCA9IHNlc3Npb24ud2ViSWRcbiAgICAgICAgdGhpcy5hZ2VudC5zZW5kKCdNZXNzYWdlcycsICB7YWN0aW9uOlwiaW5mb1wiLCBpbmZvOlwiTG9naW4gXCIrdGhpcy53ZWJJZH0pO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBsb2dpbihldmVudCkge1xuICAgIHRoaXMucG9wdXBMb2dpbigpO1xuICB9XG5cbiAgbG9nb3V0KGV2ZW50KSB7XG4gICAgYXV0aC5sb2dvdXQoKS50aGVuKCgpID0+IGFsZXJ0KCdHb29kYnllIScpKTtcbiAgfVxuXG4gIGFzeW5jIHBvcHVwTG9naW4oKSB7XG4gICAgbGV0IHNlc3Npb24gPSBhd2FpdCBhdXRoLmN1cnJlbnRTZXNzaW9uKCk7XG4gICAgbGV0IHBvcHVwVXJpID0gJy4vZGlzdC1wb3B1cC9wb3B1cC5odG1sJztcbiAgICBpZiAoIXNlc3Npb24pXG4gICAgc2Vzc2lvbiA9IGF3YWl0IGF1dGgucG9wdXBMb2dpbih7wqBwb3B1cFVyaSB9KTtcbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbG9naW4tZWxlbWVudCcsIExvZ2luRWxlbWVudCk7XG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XG5cbmNsYXNzIE1lc3NhZ2VzRWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXG4gICAgICBtZXNzYWdlczoge3R5cGU6IEFycmF5fVxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9IFwidW5rbm93blwiXG4gICAgdGhpcy5tZXNzYWdlcyA9ICBbXVxuICB9XG4gIHJlbmRlcigpe1xuICAgIHJldHVybiBodG1sYFxuICAgIDxwPiR7dGhpcy5uYW1lfTwvcD5cbiAgPCEtLSAgPHByZSBjbGFzcz1cInByZS1zY3JvbGxhYmxlXCI+LS0+XG4gICAgPHVsIGlkPVwibWVzc2FnZXNsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDIwdmg7IG92ZXJmbG93OiBhdXRvXCI+XG4gICAgJHt0aGlzLm1lc3NhZ2VzLm1hcCgobSkgPT4gaHRtbGA8bGk+PGI+QWdlbnQgJHttLmZyb219PC9iPiBzYXkgXCIke20ubWVzc2FnZX1cIjwvbGk+YCl9XG4gICAgPC91bD5cblxuICA8IS0tICA8L3ByZT4tLT5cbiAgICBgO1xuICB9XG5cbiAgZmlyc3RVcGRhdGVkKCl7XG4gICAgdmFyIGFwcCA9IHRoaXM7XG4gICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xuXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XG4gICAgICAgIHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgICAgIGNhc2UgXCJpbmZvXCI6XG4gICAgICAgICAgYXBwLmFkZEluZm8oZnJvbSwgbWVzc2FnZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBhZGRJbmZvKGZyb20sIG1lc3NhZ2Upe1xuICAgIHRoaXMubWVzc2FnZXMucmV2ZXJzZSgpXG4gICAgdGhpcy5tZXNzYWdlcyA9IFsuLi4gdGhpcy5tZXNzYWdlcywge21lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLCBmcm9tOiBmcm9tfV1cbiAgICB0aGlzLm1lc3NhZ2VzLnJldmVyc2UoKVxuICB9XG5cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdtZXNzYWdlcy1lbGVtZW50JywgTWVzc2FnZXNFbGVtZW50KTtcbiIsImltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XG5cbmltcG9ydCAnLi9sb2dpbi1lbGVtZW50LmpzJ1xuaW1wb3J0ICcuL21lc3NhZ2VzLWVsZW1lbnQuanMnXG5cbmNsYXNzIEFwcEVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvbWV0aGluZzoge3R5cGU6IFN0cmluZ30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb21ldGhpbmcgPSBcIndvcmxkXCJcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIHJldHVybiBodG1sYFxuICAgIEhlbGxvIDxiPiR7dGhpcy5zb21ldGhpbmd9PC9iPiBmcm9tIGFwcC1lbGVtZW50ICFcbiAgICA8bG9naW4tZWxlbWVudCBuYW1lPVwiTG9naW5cIj48L2xvZ2luLWVsZW1lbnQ+XG4gICAgPG1lc3NhZ2VzLWVsZW1lbnQgbmFtZT1cIk1lc3NhZ2VzXCI+PC9tZXNzYWdlcy1lbGVtZW50PlxuICAgIGA7XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2FwcC1lbGVtZW50JywgQXBwRWxlbWVudCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")}]);